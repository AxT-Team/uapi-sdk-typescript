/* tslint:disable */
/* eslint-disable */
/**
 * UAPI
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface EndpointsAggregate {
    'endpoints'?: Array<EndpointsAggregateEndpointsInner>;
    'unaggregated'?: EndpointsAggregateUnaggregated;
}
export interface EndpointsAggregateEndpointsInner {
    'path'?: string;
    'count'?: number;
}
export interface EndpointsAggregateUnaggregated {
    'count'?: number;
    'oldest_log'?: string;
}
export interface GetAiTranslateLanguages200Response {
    'code'?: number;
    'message'?: string;
    'data'?: GetAiTranslateLanguages200ResponseData;
    'performance'?: GetAiTranslateLanguages200ResponsePerformance;
}
export interface GetAiTranslateLanguages200ResponseData {
    'languages'?: Array<GetAiTranslateLanguages200ResponseDataLanguagesInner>;
    'styles'?: Array<GetAiTranslateLanguages200ResponseDataStylesInner>;
    'contexts'?: Array<GetAiTranslateLanguages200ResponseDataContextsInner>;
}
export interface GetAiTranslateLanguages200ResponseDataContextsInner {
    'code'?: string;
    'name'?: string;
    'description'?: string;
}
export interface GetAiTranslateLanguages200ResponseDataLanguagesInner {
    'code'?: string;
    'name'?: string;
    'native'?: string;
}
export interface GetAiTranslateLanguages200ResponseDataStylesInner {
    'code'?: string;
    'name'?: string;
    'description'?: string;
}
export interface GetAiTranslateLanguages200ResponsePerformance {
    'fast_mode_available'?: boolean;
    'batch_translation_available'?: boolean;
    'max_text_length'?: number;
    'max_batch_size'?: number;
    'typical_response_time_ms'?: GetAiTranslateLanguages200ResponsePerformanceTypicalResponseTimeMs;
}
export interface GetAiTranslateLanguages200ResponsePerformanceTypicalResponseTimeMs {
    'fast_mode'?: number;
    'normal_mode'?: number;
}
export interface GetAnswerbookAsk200Response {
    'code'?: number;
    'question'?: string;
    'answer'?: string;
}
export interface GetAnswerbookAsk400Response {
    'code'?: number;
    'message'?: string;
}
export interface GetAnswerbookAsk500Response {
    'code'?: number;
    'message'?: string;
}
export interface GetAvatarGravatar400Response {
    'code'?: string;
    'message'?: string;
}
export interface GetAvatarGravatar404Response {
    'code'?: string;
    'message'?: string;
}
export interface GetClipzyGet200Response {
    /**
     * 加密并使用 LZString 压缩后的 Base64 数据。
     */
    'compressedData'?: string;
}
export interface GetClipzyGet400Response {
    'error'?: string;
}
export interface GetClipzyGet404Response {
    'error'?: string;
}
export interface GetClipzyRaw400Response {
    'error'?: string;
}
export interface GetClipzyRaw403Response {
    'error'?: string;
}
export interface GetConvertUnixtime200Response {
    /**
     * 状态码，200代表操作成功。
     */
    'code'?: number;
    /**
     * 标准格式（YYYY-MM-DD HH:mm:ss）的日期时间字符串。
     */
    'datetime'?: string;
    /**
     * 转换后的10位秒级Unix时间戳。
     */
    'timestamp'?: number;
}
export interface GetConvertUnixtime400Response {
    /**
     * 机器可读的错误代码。
     */
    'code'?: string;
    /**
     * 包含错误详情的对象。
     */
    'details'?: object;
    /**
     * 人类可读的错误描述信息。
     */
    'message'?: string;
}
export interface GetDailyNewsImage500Response {
    /**
     * 机器可读的错误代码。
     */
    'code'?: string;
    /**
     * 人类可读的错误描述信息。
     */
    'message'?: string;
}
export interface GetDailyNewsImage502Response {
    /**
     * 机器可读的错误代码。
     */
    'code'?: string;
    /**
     * 人类可读的错误描述信息。
     */
    'message'?: string;
}
export interface GetGameEpicFree200Response {
    /**
     * 状态码，200代表成功。
     */
    'code'?: number;
    /**
     * 免费游戏列表数组。
     */
    'data'?: Array<GetGameEpicFree200ResponseDataInner>;
}
export interface GetGameEpicFree200ResponseDataInner {
    /**
     * 游戏的唯一标识ID。
     */
    'id'?: string;
    /**
     * 游戏的完整标题名称。
     */
    'title'?: string;
    /**
     * 游戏封面图片的URL地址。
     */
    'cover'?: string;
    /**
     * 游戏的原价，单位为人民币元。
     */
    'original_price'?: number;
    /**
     * 格式化后的原价描述字符串。
     */
    'original_price_desc'?: string;
    /**
     * 游戏的简介描述。
     */
    'description'?: string;
    /**
     * 游戏的发行商或销售商。
     */
    'seller'?: string;
    /**
     * 当前是否处于免费状态。
     */
    'is_free_now'?: boolean;
    /**
     * 免费开始时间的可读字符串格式。
     */
    'free_start'?: string;
    /**
     * 免费开始时间的13位毫秒时间戳。
     */
    'free_start_at'?: number;
    /**
     * 免费结束时间的可读字符串格式。
     */
    'free_end'?: string;
    /**
     * 免费结束时间的13位毫秒时间戳。
     */
    'free_end_at'?: number;
    /**
     * 游戏在Epic Games商店的详情页链接。
     */
    'link'?: string;
}
export interface GetGameEpicFree500Response {
    'code'?: string;
    'message'?: string;
}
export interface GetGameMinecraftHistoryid200Response {
    /**
     * 状态码，200代表成功。
     */
    'code'?: number;
    /**
     * 一个包含所有历史用户名的数组，按时间倒序排列。
     */
    'history'?: Array<GetGameMinecraftHistoryid200ResponseHistoryInner>;
    /**
     * 玩家当前的用户名。
     */
    'id'?: string;
    /**
     * 历史名称的总数（包含当前名称）。
     */
    'name_num'?: number;
    /**
     * 被查询玩家的32位无破折号UUID。
     */
    'uuid'?: string;
}
export interface GetGameMinecraftHistoryid200ResponseHistoryInner {
    /**
     * 更名为此名称的时间，格式为 `YYYY/MM/DD HH:mm:ss`。如果是初始名称，则为 `Initial`。
     */
    'changedToAt'?: string;
    /**
     * 当时使用的用户名。
     */
    'name'?: string;
}
export interface GetGameMinecraftHistoryid400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetGameMinecraftHistoryid404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetGameMinecraftHistoryid502Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetGameMinecraftServerstatus200Response {
    /**
     * 状态码，200代表成功。
     */
    'code'?: number;
    /**
     * 服务器图标的 Base64 Data URI。你可以直接在 `<img>` 标签的 `src` 属性中使用它。
     */
    'favicon_url'?: string;
    /**
     * 服务器解析后的IP地址。
     */
    'ip'?: string;
    /**
     * 服务器配置的最大玩家容量。
     */
    'max_players'?: number;
    /**
     * 纯文本格式的服务器MOTD（每日消息），去除了所有颜色和格式代码。
     */
    'motd_clean'?: string;
    /**
     * HTML格式的服务器MOTD，保留了颜色和样式，方便你在网页上直接渲染。
     */
    'motd_html'?: string;
    /**
     * 服务器当前是否在线。
     */
    'online'?: boolean;
    /**
     * 当前在线的玩家数量。
     */
    'players'?: number;
    /**
     * 服务器使用的端口。
     */
    'port'?: number;
    /**
     * 服务器报告的版本信息。
     */
    'version'?: string;
}
export interface GetGameMinecraftServerstatus400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetGameMinecraftServerstatus404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetGameMinecraftServerstatus502Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetGameMinecraftUserinfo200Response {
    /**
     * 状态码，200代表成功。
     */
    'code'?: number;
    /**
     * 玩家当前使用的皮肤图片URL。
     */
    'skin_url'?: string;
    /**
     * 玩家当前的准确用户名（注意大小写可能与输入不同）。
     */
    'username'?: string;
    /**
     * 玩家的32位无破折号UUID。
     */
    'uuid'?: string;
}
export interface GetGameMinecraftUserinfo400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetGameMinecraftUserinfo404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetGameSteamSummary200Response {
    /**
     * 32x32 像素的小尺寸头像URL。
     */
    'avatar'?: string;
    /**
     * 184x184 像素的大尺寸头像URL。
     */
    'avatarfull'?: string;
    /**
     * 64x64 像素的中等尺寸头像URL。
     */
    'avatarmedium'?: string;
    /**
     * 状态码，200代表成功。
     */
    'code'?: number;
    /**
     * 社区资料的可见性状态: 1=私密, 3=公开。
     */
    'communityvisibilitystate'?: number;
    /**
     * 用户个人资料中设置的国家代码 (ISO 3166-1)，前提是用户已设置并公开。
     */
    'loccountrycode'?: string;
    /**
     * 玩家的当前昵称。
     */
    'personaname'?: string;
    /**
     * 用户当前的在线状态: 0-离线, 1-在线, 2-忙碌, 3-离开, 4-打盹, 5-想交易, 6-想玩。
     */
    'personastate'?: number;
    /**
     * 玩家设置的主要部落的64位ID。
     */
    'primaryclanid'?: string;
    /**
     * 如果用户设置了个人资料，则为1。
     */
    'profilestate'?: number;
    /**
     * 用户的Steam社区个人资料页完整URL。
     */
    'profileurl'?: string;
    /**
     * 用户的真实姓名，前提是用户已设置并公开。
     */
    'realname'?: string;
    /**
     * 被查询用户的64位SteamID。
     */
    'steamid'?: string;
    /**
     * 账户创建时的Unix时间戳（秒）。
     */
    'timecreated'?: number;
    /**
     * 我们为你格式化好的账户创建时间，更直观。
     */
    'timecreated_str'?: string;
}
export interface GetGameSteamSummary400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetGameSteamSummary401Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetGameSteamSummary404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetGameSteamSummary502Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetGithubRepo200Response {
    'full_name'?: string;
    'description'?: string;
    'homepage'?: string;
    'default_branch'?: string;
    'primary_branch'?: string;
    'default_branch_sha'?: string;
    'visibility'?: string;
    'archived'?: boolean;
    'disabled'?: boolean;
    'fork'?: boolean;
    'language'?: string;
    'topics'?: Array<string>;
    'license'?: string;
    'stargazers'?: number;
    'forks'?: number;
    'open_issues'?: number;
    'watchers'?: number;
    'pushed_at'?: string;
    'created_at'?: string;
    'updated_at'?: string;
    'languages'?: { [key: string]: number; };
    'collaborators'?: Array<GetGithubRepo200ResponseCollaboratorsInner> | null;
    'maintainers'?: Array<GetGithubRepo200ResponseCollaboratorsInner>;
}
export interface GetGithubRepo200ResponseCollaboratorsInner {
    'login'?: string;
    'name'?: string;
    'email'?: string;
    'url'?: string;
}
export interface GetGithubRepo400Response {
    'code'?: string;
    'message'?: string;
}
export interface GetGithubRepo502Response {
    'code'?: string;
    'message'?: string;
}
export interface GetHistoryProgrammer200Response {
    'code'?: number;
    'message'?: string;
    'date'?: string;
    'events'?: Array<GetHistoryProgrammer200ResponseEventsInner>;
}
export interface GetHistoryProgrammer200ResponseEventsInner {
    'year'?: number;
    'title'?: string;
    'description'?: string;
    'category'?: string;
    'importance'?: number;
    'relevance_score'?: number;
    'url'?: string;
}
export interface GetHistoryProgrammer400Response {
    'code'?: string;
    'message'?: string;
}
export interface GetHistoryProgrammerToday200Response {
    'code'?: number;
    'message'?: string;
    'date'?: string;
    'events'?: Array<GetHistoryProgrammerToday200ResponseEventsInner>;
}
export interface GetHistoryProgrammerToday200ResponseEventsInner {
    'year'?: number;
    'title'?: string;
    'description'?: string;
    'category'?: string;
    'importance'?: number;
    'relevance_score'?: number;
    'url'?: string;
}
export interface GetHistoryProgrammerToday500Response {
    'code'?: string;
    'message'?: string;
}
export interface GetImageBingDaily502Response {
    'code'?: string;
    'message'?: string;
}
export interface GetImageMotou400Response {
    'error'?: string;
}
export interface GetImageMotou500Response {
    'error'?: string;
}
export interface GetImageQrcode200Response {
    /**
     * 图片的URL。当`format=json_url`时是临时公网URL；当`format=json`时是Base64 Data URI。
     */
    'url'?: string;
}
export interface GetImageQrcode400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetImageQrcode500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetImageTobase64200Response {
    /**
     * 转换后的完整Base64 Data URI，可以直接在CSS或HTML中使用。
     */
    'base64'?: string;
    /**
     * 状态码，200代表成功。
     */
    'code'?: number;
    /**
     * 操作结果描述。
     */
    'msg'?: string;
}
export interface GetImageTobase64400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetImageTobase64502Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetMiscHotboard200Response {
    /**
     * 热榜条目列表。
     */
    'list'?: Array<GetMiscHotboard200ResponseListInner>;
    'type'?: string;
    'update_time'?: string;
}
export interface GetMiscHotboard200ResponseListInner {
    /**
     * 额外信息，不同平台该字段内容不同，例如微博热搜的标签（如\'新\'、\'爆\'）。
     */
    'extra'?: { [key: string]: any; };
    'hot_value'?: string;
    'index'?: number;
    'title'?: string;
    'url'?: string;
}
export interface GetMiscHotboard400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetMiscHotboard500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetMiscHotboard502Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetMiscPhoneinfo200Response {
    'city'?: string;
    'province'?: string;
    /**
     * 运营商 (Service Provider) 名称。
     */
    'sp'?: string;
}
export interface GetMiscPhoneinfo400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetMiscPhoneinfo500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetMiscRandomnumber200Response {
    /**
     * 生成的随机数列表。
     */
    'numbers'?: Array<number>;
}
export interface GetMiscRandomnumber400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetMiscTimestamp200Response {
    'datetime_local'?: string;
    'datetime_utc'?: string;
    'input'?: string;
    'type'?: string;
    'unix_timestamp'?: number;
}
export interface GetMiscTimestamp400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetMiscTrackingCarriers200Response {
    'code'?: string;
    'message'?: string;
    'data'?: GetMiscTrackingCarriers200ResponseData;
}
export interface GetMiscTrackingCarriers200ResponseData {
    /**
     * 支持的快递公司总数
     */
    'total'?: number;
    /**
     * 快递公司列表
     */
    'carriers'?: Array<GetMiscTrackingCarriers200ResponseDataCarriersInner>;
}
export interface GetMiscTrackingCarriers200ResponseDataCarriersInner {
    /**
     * 快递公司编码，用于API调用时的carrier_code参数
     */
    'code'?: string;
    /**
     * 快递公司中文名称，用于界面显示
     */
    'name'?: string;
}
export interface GetMiscTrackingDetect200Response {
    'code'?: string;
    'message'?: string;
    'data'?: GetMiscTrackingDetect200ResponseData;
}
export interface GetMiscTrackingDetect200ResponseData {
    /**
     * 查询的快递单号
     */
    'tracking_number'?: string;
    /**
     * 最可能的快递公司编码
     */
    'carrier_code'?: string;
    /**
     * 最可能的快递公司名称
     */
    'carrier_name'?: string;
    /**
     * 其他可能的快递公司列表（如果存在）
     */
    'alternatives'?: Array<GetMiscTrackingDetect200ResponseDataAlternativesInner>;
}
export interface GetMiscTrackingDetect200ResponseDataAlternativesInner {
    /**
     * 快递公司编码
     */
    'code'?: string;
    /**
     * 快递公司名称
     */
    'name'?: string;
}
export interface GetMiscTrackingDetect404Response {
    'code'?: string;
    'message'?: string;
}
export interface GetMiscTrackingQuery200Response {
    'code'?: string;
    'message'?: string;
    'data'?: GetMiscTrackingQuery200ResponseData;
}
export interface GetMiscTrackingQuery200ResponseData {
    /**
     * 快递单号
     */
    'tracking_number'?: string;
    /**
     * 快递公司编码
     */
    'carrier_code'?: string;
    /**
     * 快递公司名称
     */
    'carrier_name'?: string;
    /**
     * 物流轨迹数量
     */
    'track_count'?: number;
    /**
     * 物流轨迹列表，按时间倒序排列
     */
    'tracks'?: Array<GetMiscTrackingQuery200ResponseDataTracksInner>;
}
export interface GetMiscTrackingQuery200ResponseDataTracksInner {
    /**
     * 物流更新时间
     */
    'time'?: string;
    /**
     * 物流状态描述
     */
    'context'?: string;
}
export interface GetMiscTrackingQuery400Response {
    'code'?: string;
    'message'?: string;
}
export interface GetMiscTrackingQuery404Response {
    'code'?: string;
    'message'?: string;
}
export interface GetMiscWeather200Response {
    'adcode'?: string;
    'city'?: string;
    'humidity'?: number;
    'province'?: string;
    'report_time'?: string;
    'temperature'?: number;
    'weather'?: string;
    'wind_direction'?: string;
    'wind_power'?: string;
}
export interface GetMiscWeather400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetMiscWeather410Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetMiscWeather500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetMiscWeather502Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetMiscWorldtime200Response {
    'datetime'?: string;
    'offset_seconds'?: number;
    'offset_string'?: string;
    'query'?: string;
    'timestamp_unix'?: number;
    'timezone'?: string;
    'weekday'?: string;
}
export interface GetMiscWorldtime400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetMiscWorldtime404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetNetworkDns200Response {
    'code'?: number;
    'domain'?: string;
    'error'?: string;
    'records'?: Array<GetNetworkDns200ResponseRecordsInner>;
    'type'?: string;
}
export interface GetNetworkDns200ResponseRecordsInner {
    'content'?: string;
    'flag'?: number;
    'port'?: number;
    'pri'?: number;
    'tag'?: string;
    'target'?: string;
    'weight'?: number;
}
export interface GetNetworkDns400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetNetworkDns404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetNetworkIcp200Response {
    'code'?: string;
    'domain'?: string;
    'msg'?: string;
    /**
     * 主办单位的性质 (企业/个人)
     */
    'natureName'?: string;
    /**
     * ICP备案号
     */
    'serviceLicence'?: string;
    /**
     * 主办单位名称
     */
    'unitName'?: string;
}
export interface GetNetworkIcp404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetNetworkIpinfo200Response {
    /**
     * 自治系统编号 (由GeoLite2或商业版提供)
     */
    'asn'?: string;
    /**
     * IP范围起始 (仅在默认查询中提供)
     */
    'beginip'?: string;
    'code'?: number;
    /**
     * IP范围结束 (仅在默认查询中提供)
     */
    'endip'?: string;
    'ip'?: string;
    /**
     * 运营商
     */
    'isp'?: string;
    'latitude'?: number;
    /**
     * 归属
     */
    'llc'?: string;
    'longitude'?: number;
    /**
     * 格式：国家 省份 城市
     */
    'region'?: string;
    /**
     * 行政区 (仅在商业查询中提供)
     */
    'district'?: string;
    /**
     * 行政区划代码 (仅在商业查询中提供)
     */
    'area_code'?: string;
    /**
     * 城市区号 (仅在商业查询中提供)
     */
    'city_code'?: string;
    /**
     * 邮政编码 (仅在商业查询中提供)
     */
    'zip_code'?: string;
    /**
     * 时区 (仅在商业查询中提供)
     */
    'time_zone'?: string;
    /**
     * 应用场景 (仅在商业查询中提供)
     */
    'scenes'?: string;
    /**
     * 海拔（米）(仅在商业查询中提供)
     */
    'elevation'?: string;
    /**
     * 气象站代码 (仅在商业查询中提供)
     */
    'weather_station'?: string;
}
export interface GetNetworkIpinfo400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetNetworkIpinfo404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetNetworkIpinfo500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetNetworkMyip400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetNetworkMyip500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetNetworkPing200Response {
    /**
     * 平均延迟(ms)
     */
    'avg'?: number;
    'code'?: number;
    'host'?: string;
    'ip'?: string;
    'location'?: string;
    /**
     * 最大延迟(ms)
     */
    'max'?: number;
    /**
     * 最小延迟(ms)
     */
    'min'?: number;
}
export interface GetNetworkPing400Response {
    'code'?: string;
    'message'?: string;
}
export interface GetNetworkPing429Response {
    'code'?: string;
    'message'?: string;
}
export interface GetNetworkPingmyip200Response {
    /**
     * 平均延迟(ms)
     */
    'avg'?: number;
    'code'?: number;
    'host'?: string;
    'ip'?: string;
    'location'?: string;
    /**
     * 最大延迟(ms)
     */
    'max'?: number;
    /**
     * 最小延迟(ms)
     */
    'min'?: number;
}
export interface GetNetworkPingmyip404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetNetworkPortscan200Response {
    'code'?: number;
    'ip'?: string;
    'port'?: number;
    /**
     * \"open\", \"closed\", 或 \"timeout\"
     */
    'port_status'?: string;
    'protocol'?: string;
}
export interface GetNetworkPortscan400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetNetworkPortscan500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetNetworkUrlstatus200Response {
    'code'?: number;
    /**
     * HTTP响应状态码
     */
    'status'?: number;
    'url'?: string;
}
export interface GetNetworkUrlstatus502Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
/**
 * @type GetNetworkWhois200Response
 */
export type GetNetworkWhois200Response = GetNetworkWhois200ResponseOneOf | GetNetworkWhois200ResponseOneOf1;

/**
 * ### 文本格式响应 当 `format=text` 或未指定时，`whois` 字段包含原始的WHOIS查询文本。这保留了最完整的信息，适合需要自行解析或展示原始数据的场景。
 */
export interface GetNetworkWhois200ResponseOneOf {
    'code'?: number;
    /**
     * **WHOIS原始文本**  返回未经处理的原始WHOIS查询结果文本。
     */
    'whois'?: string;
}
/**
 * ### JSON格式响应 当 `format=json` 时，`whois` 字段返回结构化的JSON对象。  > [!NOTE] > **注意**：返回的具体字段可能因域名注册局和隐私保护设置而异。某些敏感信息可能会被部分隐藏或标记为 `REDACTED FOR PRIVACY`。
 */
export interface GetNetworkWhois200ResponseOneOf1 {
    'code'?: number;
    /**
     * ### 结构化WHOIS信息  返回经过解析的JSON对象，包含以下主要部分：  - **域名信息**: 包含域名ID、注册状态、DNS服务器等 - **注册商信息**: 注册服务商的详细信息 - **注册人信息**: 域名所有者的相关信息（可能因隐私保护而部分隐藏） - **重要日期**: 包括注册日期、更新日期和到期日期
     */
    'whois'?: object;
}
export interface GetNetworkWhois404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetNetworkWxdomain200Response {
    'domain'?: string;
    /**
     * 状态标题
     */
    'title'?: string;
    /**
     * 状态类型
     */
    'type'?: string;
}
export interface GetNetworkWxdomain502Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetRandomImage404Response {
    'code'?: string;
    'message'?: string;
}
export interface GetRandomImage500Response {
    'code'?: string;
    'message'?: string;
}
export interface GetRandomString200Response {
    'code'?: number;
    'text'?: string;
}
export interface GetRandomString400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetRandomString500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetSaying200Response {
    /**
     * 随机获取到的名言或诗词内容。
     */
    'text'?: string;
}
export interface GetSaying500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetSearchEngines200Response {
    'engine'?: GetSearchEngines200ResponseEngine;
    'limits'?: GetSearchEngines200ResponseLimits;
    /**
     * 支持的所有参数说明列表
     */
    'supported_parameters'?: Array<string>;
}
/**
 * 搜索引擎的基本信息
 */
export interface GetSearchEngines200ResponseEngine {
    /**
     * 引擎标识名称
     */
    'name'?: string;
    /**
     * 引擎显示名称
     */
    'display_name'?: string;
    /**
     * 引擎描述
     */
    'description'?: string;
    /**
     * 引擎是否可用
     */
    'available'?: boolean;
    /**
     * 引擎版本号
     */
    'version'?: string;
    /**
     * 支持的特性列表
     */
    'features'?: Array<string>;
}
/**
 * 搜索结果数量限制
 */
export interface GetSearchEngines200ResponseLimits {
    /**
     * 默认返回结果数
     */
    'default'?: number;
    /**
     * 最大返回结果数
     */
    'max'?: number;
}
export interface GetSensitiveWordAnalyzeQuery400Response {
    'code'?: string;
    'message'?: string;
}
export interface GetSocialBilibiliArchives200Response {
    /**
     * 总稿件数
     */
    'total'?: number;
    /**
     * 当前页码
     */
    'page'?: number;
    /**
     * 每页数量
     */
    'size'?: number;
    /**
     * 视频列表
     */
    'videos'?: Array<GetSocialBilibiliArchives200ResponseVideosInner>;
}
export interface GetSocialBilibiliArchives200ResponseVideosInner {
    /**
     * 视频AID
     */
    'aid'?: number;
    /**
     * BV号
     */
    'bvid'?: string;
    /**
     * 标题
     */
    'title'?: string;
    /**
     * 封面URL
     */
    'cover'?: string;
    /**
     * 时长(秒)
     */
    'duration'?: number;
    /**
     * 播放量
     */
    'play_count'?: number;
    /**
     * 发布时间戳
     */
    'publish_time'?: number;
    /**
     * 创建时间戳
     */
    'create_time'?: number;
    /**
     * 视频状态
     */
    'state'?: number;
    /**
     * 是否付费视频。0=免费，1=付费
     */
    'is_ugc_pay'?: number;
    /**
     * 是否为互动视频
     */
    'is_interactive'?: boolean;
}
export interface GetSocialBilibiliArchives400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetSocialBilibiliArchives404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetSocialBilibiliArchives500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetSocialBilibiliLiveroom200Response {
    /**
     * 主播的用户ID (mid)。
     */
    'uid'?: number;
    /**
     * 直播间的真实房间号（长号）。
     */
    'room_id'?: number;
    /**
     * 直播间的短号（靓号）。如果没有设置，则为0。
     */
    'short_id'?: number;
    /**
     * 主播的粉丝数（关注数量）。
     */
    'attention'?: number;
    /**
     * 直播间当前的人气值。注意这不是真实在线人数。
     */
    'online'?: number;
    /**
     * 直播状态。0:未开播, 1:直播中, 2:轮播中。
     */
    'live_status'?: number;
    /**
     * 分区ID。
     */
    'area_id'?: number;
    /**
     * 父分区名称。
     */
    'parent_area_name'?: string;
    /**
     * 子分区名称。
     */
    'area_name'?: string;
    /**
     * 直播间背景图的URL。
     */
    'background'?: string;
    /**
     * 当前直播间的标题。
     */
    'title'?: string;
    /**
     * 用户设置的直播间封面URL。
     */
    'user_cover'?: string;
    /**
     * 直播间公告或描述，支持换行符。
     */
    'description'?: string;
    /**
     * 本次直播开始的时间，格式为 `YYYY-MM-DD HH:mm:ss`。如果未开播，则为空字符串。
     */
    'live_time'?: string;
    /**
     * 直播间设置的标签，以逗号分隔。
     */
    'tags'?: string;
    /**
     * 直播间热词列表，通常用于弹幕互动。
     */
    'hot_words'?: Array<string>;
    /**
     * 主播佩戴的头像框、大航海等级等信息，结构可能比较复杂。
     */
    'new_pendants'?: object;
}
export interface GetSocialBilibiliReplies200Response {
    'page'?: GetSocialBilibiliReplies200ResponsePage;
    /**
     * 热门评论列表。结构与 `replies` 中的对象一致。如果当前页是第一页，且有热门评论，则此数组非空。
     */
    'hots'?: Array<object> | null;
    /**
     * 当前页的评论列表。
     */
    'replies'?: Array<GetSocialBilibiliReplies200ResponseRepliesInner>;
}
/**
 * 分页信息概览。
 */
export interface GetSocialBilibiliReplies200ResponsePage {
    /**
     * 当前所在的页码。
     */
    'num'?: number;
    /**
     * 每页的项数。
     */
    'size'?: number;
    /**
     * 根评论（即直接评论视频的评论）的总数。
     */
    'count'?: number;
    /**
     * 评论区总评论数，包含了所有的楼中楼回复。
     */
    'acount'?: number;
}
export interface GetSocialBilibiliReplies200ResponseRepliesInner {
    /**
     * 评论的唯一ID (Reply ID)。
     */
    'rpid'?: number;
    /**
     * 评论区对象ID，即视频的aid。
     */
    'oid'?: number;
    /**
     * 发表评论的用户的mid。
     */
    'mid'?: number;
    /**
     * 根评论的rpid。如果为0，表示这条评论是根评论。
     */
    'root'?: number;
    /**
     * 回复的父级评论的rpid。如果为0，表示是根评论。
     */
    'parent'?: number;
    /**
     * 这条评论下的回复（楼中楼）数量。
     */
    'count'?: number;
    /**
     * 评论发送时间的Unix时间戳（秒）。
     */
    'ctime'?: number;
    /**
     * 该评论获得的点赞数。
     */
    'like'?: number;
    'member'?: GetSocialBilibiliReplies200ResponseRepliesInnerMember;
    'content'?: GetSocialBilibiliReplies200ResponseRepliesInnerContent;
    /**
     * 楼中楼回复列表。结构与顶层评论对象一致，但通常此数组为空，需要单独请求。
     */
    'replies'?: Array<object>;
}
/**
 * 评论内容。
 */
export interface GetSocialBilibiliReplies200ResponseRepliesInnerContent {
    /**
     * 评论的文本内容。
     */
    'message'?: string;
}
/**
 * 发表评论的用户信息。
 */
export interface GetSocialBilibiliReplies200ResponseRepliesInnerMember {
    /**
     * 用户昵称。
     */
    'uname'?: string;
    /**
     * 用户性别。
     */
    'sex'?: string;
    /**
     * 用户头像的URL。
     */
    'avatar'?: string;
    'level_info'?: GetSocialBilibiliReplies200ResponseRepliesInnerMemberLevelInfo;
}
export interface GetSocialBilibiliReplies200ResponseRepliesInnerMemberLevelInfo {
    /**
     * 用户的B站等级。
     */
    'current_level'?: number;
}
export interface GetSocialBilibiliUserinfo200Response {
    'code'?: number;
    'data'?: GetSocialBilibiliUserinfo200ResponseData;
    'message'?: string;
}
export interface GetSocialBilibiliUserinfo200ResponseData {
    'face'?: string;
    'level'?: number;
    'mid'?: number;
    'name'?: string;
    'sex'?: string;
    'sign'?: string;
}
export interface GetSocialBilibiliUserinfo400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetSocialBilibiliUserinfo404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetSocialBilibiliUserinfo502Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetSocialBilibiliVideoinfo200Response {
    /**
     * 稿件的BV号。
     */
    'bvid'?: string;
    /**
     * 稿件的AV号。
     */
    'aid'?: number;
    /**
     * 稿件分P总数。如果是单P视频，则为1。
     */
    'videos'?: number;
    /**
     * 视频所属的子分区名称。
     */
    'tname'?: string;
    /**
     * 视频类型。1代表原创，2代表转载。
     */
    'copyright'?: number;
    /**
     * 稿件封面图片的URL。这是一个可以直接在网页上展示的链接。
     */
    'pic'?: string;
    /**
     * 稿件的标题。
     */
    'title'?: string;
    /**
     * 稿件发布时间的Unix时间戳（秒）。
     */
    'pubdate'?: number;
    /**
     * 用户投稿时间的Unix时间戳（秒）。
     */
    'ctime'?: number;
    /**
     * 视频简介。可能会包含HTML换行符。
     */
    'desc'?: string;
    /**
     * 稿件总时长（所有分P累加），单位为秒。
     */
    'duration'?: number;
    'owner'?: GetSocialBilibiliVideoinfo200ResponseOwner;
    'stat'?: GetSocialBilibiliVideoinfo200ResponseStat;
    /**
     * 视频分P列表。即使是单P视频，该数组也包含一个元素。
     */
    'pages'?: Array<GetSocialBilibiliVideoinfo200ResponsePagesInner>;
}
/**
 * 视频UP主信息。
 */
export interface GetSocialBilibiliVideoinfo200ResponseOwner {
    /**
     * UP主的UID。
     */
    'mid'?: number;
    /**
     * UP主昵称。
     */
    'name'?: string;
    /**
     * UP主头像的URL。
     */
    'face'?: string;
}
export interface GetSocialBilibiliVideoinfo200ResponsePagesInner {
    /**
     * 分P的唯一标识CID，用于获取弹幕等。
     */
    'cid'?: number;
    /**
     * 分P的序号，从1开始。
     */
    'page'?: number;
    /**
     * 分P的标题。对于单P视频，通常是视频主标题。
     */
    'part'?: string;
    /**
     * 该分P的持续时间，单位为秒。
     */
    'duration'?: number;
}
/**
 * 视频的核心数据统计。
 */
export interface GetSocialBilibiliVideoinfo200ResponseStat {
    /**
     * 播放数。
     */
    'view'?: number;
    /**
     * 弹幕数。
     */
    'danmaku'?: number;
    /**
     * 评论数。
     */
    'reply'?: number;
    /**
     * 收藏数。
     */
    'favorite'?: number;
    /**
     * 投币数。
     */
    'coin'?: number;
    /**
     * 分享数。
     */
    'share'?: number;
    /**
     * 获赞数。
     */
    'like'?: number;
}
export interface GetSocialQqGroupinfo200Response {
    /**
     * 群号
     */
    'group_id'?: string;
    /**
     * 群名称
     */
    'group_name'?: string;
    /**
     * 群头像URL（标准尺寸100x100）
     */
    'avatar_url'?: string;
    /**
     * 群描述/简介
     */
    'description'?: string;
    /**
     * 群标签
     */
    'tag'?: string;
    /**
     * 加群链接（QR码URL）
     */
    'join_url'?: string;
    /**
     * 最后更新时间（ISO 8601格式）
     */
    'last_updated'?: string;
}
export interface GetSocialQqGroupinfo400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetSocialQqGroupinfo404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetSocialQqGroupinfo500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetSocialQqUserinfo200Response {
    /**
     * QQ号
     */
    'qq'?: string;
    /**
     * 用户昵称
     */
    'nickname'?: string;
    /**
     * 个性签名
     */
    'long_nick'?: string;
    /**
     * 头像URL
     */
    'avatar_url'?: string;
    /**
     * 年龄
     */
    'age'?: number;
    /**
     * 性别
     */
    'sex'?: string;
    /**
     * QQ个性域名
     */
    'qid'?: string;
    /**
     * QQ等级
     */
    'qq_level'?: number;
    /**
     * 地理位置（省市）
     */
    'location'?: string;
    /**
     * QQ邮箱
     */
    'email'?: string;
    /**
     * 是否为VIP用户
     */
    'is_vip'?: boolean;
    /**
     * VIP等级
     */
    'vip_level'?: number;
    /**
     * 注册时间（ISO 8601格式）
     */
    'reg_time'?: string;
    /**
     * 最后更新时间（ISO 8601格式）
     */
    'last_updated'?: string;
}
export interface GetSocialQqUserinfo400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetSocialQqUserinfo404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetStatusRatelimit200Response {
    /**
     * Total number of accepted requests
     */
    'accepts'?: number;
    /**
     * Number of current in-flight requests
     */
    'in_flight'?: number;
    /**
     * Last update time of the status
     */
    'last_update'?: string;
    /**
     * Current concurrency limit
     */
    'limit'?: number;
    /**
     * Calculated system load (in_flight / limit)
     */
    'load'?: number;
    /**
     * Minimum observed RTT in milliseconds
     */
    'min_rtt'?: number;
    /**
     * Total number of rejected requests
     */
    'rejects'?: number;
    /**
     * Smoothed RTT in milliseconds
     */
    'rtt'?: number;
    /**
     * Total number of throttled requests
     */
    'throttled'?: number;
}
export interface GetStatusRatelimit401Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetStatusUsage200Response {
    'endpoints'?: Array<EndpointsAggregateEndpointsInner>;
    'unaggregated'?: EndpointsAggregateUnaggregated;
    'path'?: string;
    'count'?: number;
}
export interface GetStatusUsage404Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetStatusUsage500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetTextMd5200Response {
    'md5'?: string;
}
export interface GetTextMd5400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetWebTomarkdownAsyncStatus200Response {
    'task_id'?: string;
    'status'?: string;
    'url'?: string;
    'progress'?: number;
    'created_at'?: string;
    'message'?: string;
    'started_at'?: string;
    'elapsed'?: number;
    'completed_at'?: string;
    'duration'?: number;
    'result'?: GetWebTomarkdownAsyncStatus200ResponseAnyOf2Result;
    'error'?: string;
}
export interface GetWebTomarkdownAsyncStatus200ResponseAnyOf {
    'task_id'?: string;
    'status'?: string;
    'url'?: string;
    'progress'?: number;
    'created_at'?: string;
    'message'?: string;
}
export interface GetWebTomarkdownAsyncStatus200ResponseAnyOf1 {
    'task_id'?: string;
    'status'?: string;
    'url'?: string;
    'progress'?: number;
    'created_at'?: string;
    'started_at'?: string;
    'elapsed'?: number;
    'message'?: string;
}
export interface GetWebTomarkdownAsyncStatus200ResponseAnyOf2 {
    'task_id'?: string;
    'status'?: string;
    'url'?: string;
    'progress'?: number;
    'created_at'?: string;
    'started_at'?: string;
    'completed_at'?: string;
    'duration'?: number;
    'result'?: GetWebTomarkdownAsyncStatus200ResponseAnyOf2Result;
}
export interface GetWebTomarkdownAsyncStatus200ResponseAnyOf2Result {
    'markdown'?: string;
    'size'?: number;
}
export interface GetWebTomarkdownAsyncStatus200ResponseAnyOf3 {
    'task_id'?: string;
    'status'?: string;
    'url'?: string;
    'progress'?: number;
    'created_at'?: string;
    'started_at'?: string;
    'completed_at'?: string;
    'duration'?: number;
    'error'?: string;
}
export interface GetWebTomarkdownAsyncStatus404Response {
    'error'?: string;
    'message'?: string;
    'code'?: number;
}
export interface GetWebparseExtractimages200Response {
    'count'?: number;
    'images'?: Array<string>;
    'url'?: string;
}
export interface GetWebparseExtractimages500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface GetWebparseMetadata200Response {
    'page_url'?: string;
    'title'?: string;
    'description'?: string;
    'keywords'?: Array<string>;
    'favicon_url'?: string;
    'language'?: string;
    'author'?: string;
    'published_time'?: string;
    'canonical_url'?: string;
    'generator'?: string;
    'open_graph'?: object;
}
export interface GetWebparseMetadata500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface PostAiTranslate200Response {
    'code'?: number;
    'message'?: string;
    /**
     * 标识是否为批量翻译请求。
     */
    'is_batch'?: boolean;
    'data'?: PostAiTranslate200ResponseData;
    /**
     * 批量翻译结果列表，仅在批量翻译时返回。
     */
    'batch_data'?: Array<PostAiTranslate200ResponseBatchDataInner>;
    'batch_summary'?: PostAiTranslate200ResponseBatchSummary;
    'performance'?: PostAiTranslate200ResponsePerformance;
    'quality_metrics'?: PostAiTranslate200ResponseQualityMetrics;
}
export interface PostAiTranslate200ResponseBatchDataInner {
    'original_text'?: string;
    'translated_text'?: string;
    'confidence_score'?: number;
}
/**
 * 批量翻译汇总信息，仅在批量翻译时返回。
 */
export interface PostAiTranslate200ResponseBatchSummary {
    'total_items'?: number;
    'success_items'?: number;
    'failed_items'?: number;
    'average_quality'?: number;
}
/**
 * 单个翻译的详细结果，仅在单个翻译时返回。
 */
export interface PostAiTranslate200ResponseData {
    'original_text'?: string;
    'translated_text'?: string;
    'detected_lang'?: string;
    'confidence_score'?: number;
    'alternatives'?: Array<string>;
    'explanation'?: PostAiTranslate200ResponseDataExplanation;
}
export interface PostAiTranslate200ResponseDataExplanation {
    'key_phrases'?: Array<object>;
    'cultural_notes'?: Array<string>;
    'grammar_notes'?: Array<string>;
}
export interface PostAiTranslate200ResponsePerformance {
    'processing_time_ms'?: number;
    'cache_hit'?: boolean;
}
/**
 * 翻译质量指标，仅在单个翻译时返回。
 */
export interface PostAiTranslate200ResponseQualityMetrics {
    'fluency_score'?: number;
    'accuracy_score'?: number;
    'completeness_score'?: number;
    'total_score'?: number;
}
export interface PostAiTranslate400Response {
    'code'?: number;
    'message'?: string;
    'error'?: string;
}
export interface PostAiTranslate401Response {
    'code'?: number;
    'message'?: string;
    'error'?: string;
}
export interface PostAiTranslate429Response {
    'code'?: number;
    'message'?: string;
    'error'?: string;
}
export interface PostAiTranslate500Response {
    'code'?: number;
    'message'?: string;
    'error'?: string;
    'is_batch'?: boolean;
}
export interface PostAiTranslateRequest {
    /**
     * 单个翻译时使用的待翻译文本，与texts参数二选一。最大长度10,000字符。
     */
    'text'?: string;
    /**
     * 批量翻译时使用的待翻译文本列表，与text参数二选一。最多50条，总计最大100,000字符。
     */
    'texts'?: Array<string>;
    /**
     * 源语言代码，可选。如果不指定，系统会自动检测源语言。
     */
    'source_lang'?: string;
    /**
     * 翻译风格，可选。支持casual(随意口语化)、professional(专业商务，默认)、academic(学术正式)、literary(文学艺术)。
     */
    'style'?: PostAiTranslateRequestStyleEnum;
    /**
     * 翻译上下文场景，可选。支持general(通用，默认)、business(商务)、technical(技术)、medical(医疗)、legal(法律)、marketing(市场营销)、entertainment(娱乐)、education(教育)、news(新闻)。
     */
    'context'?: PostAiTranslateRequestContextEnum;
    /**
     * 是否保留原文格式，包括换行、缩进等。
     */
    'preserve_format'?: boolean;
    /**
     * 是否启用快速模式。快速模式响应时间约800ms，准确率95%+；普通模式响应时间约2000ms，准确率98%+。
     */
    'fast_mode'?: boolean;
    /**
     * 批量翻译时的最大并发数，范围1-10。仅在批量翻译时有效。
     */
    'max_concurrency'?: number;
}

export const PostAiTranslateRequestStyleEnum = {
    Casual: 'casual',
    Professional: 'professional',
    Academic: 'academic',
    Literary: 'literary'
} as const;

export type PostAiTranslateRequestStyleEnum = typeof PostAiTranslateRequestStyleEnum[keyof typeof PostAiTranslateRequestStyleEnum];
export const PostAiTranslateRequestContextEnum = {
    General: 'general',
    Business: 'business',
    Technical: 'technical',
    Medical: 'medical',
    Legal: 'legal',
    Marketing: 'marketing',
    Entertainment: 'entertainment',
    Education: 'education',
    News: 'news'
} as const;

export type PostAiTranslateRequestContextEnum = typeof PostAiTranslateRequestContextEnum[keyof typeof PostAiTranslateRequestContextEnum];

export interface PostAnswerbookAsk200Response {
    'code'?: number;
    'question'?: string;
    'answer'?: string;
}
export interface PostAnswerbookAskRequest {
    /**
     * 你想要提问的问题
     */
    'question': string;
}
export interface PostClipzyStore200Response {
    /**
     * 用于构建分享链接的唯一 ID。
     */
    'id'?: string;
}
export interface PostClipzyStore400Response {
    'error'?: string;
    'details'?: string;
}
export interface PostClipzyStore413Response {
    'error'?: string;
    'details'?: string;
}
export interface PostClipzyStoreRequest {
    /**
     * 必需：经过加密和 LZString 压缩后的 Base64 字符串。请参考文档首页的JS代码示例。
     */
    'compressedData': string;
    /**
     * 可选：片段的留存时间（秒）。正数表示秒数（最大约30天），-1 表示永久存储。默认为 3600。
     */
    'ttl'?: number;
}
export interface PostConvertJson200Response {
    /**
     * 状态码，200代表操作成功。
     */
    'code'?: number;
    /**
     * 格式化后的JSON字符串，带有标准缩进和换行。
     */
    'content'?: string;
}
export interface PostConvertJson400Response {
    /**
     * 机器可读的错误代码。
     */
    'code'?: string;
    /**
     * 包含错误详情的对象。
     */
    'details'?: object;
    /**
     * 人类可读的错误描述信息。
     */
    'message'?: string;
}
export interface PostConvertJsonRequest {
    /**
     * 需要被格式化的原始JSON字符串。
     */
    'content': string;
}
export interface PostImageCompress400Response {
    /**
     * 机器可读的错误代码。
     */
    'code'?: string;
    /**
     * 人类可读的错误描述信息。
     */
    'message'?: string;
}
export interface PostImageCompress500Response {
    /**
     * 机器可读的错误代码。
     */
    'code'?: string;
    /**
     * 人类可读的错误描述信息。
     */
    'message'?: string;
}
export interface PostImageFrombase64200Response {
    /**
     * 状态码，200代表成功。
     */
    'code'?: number;
    /**
     * 图片保存后在服务器上的绝对访问URL。
     */
    'image_url'?: string;
    /**
     * 操作结果描述。
     */
    'msg'?: string;
}
export interface PostImageFrombase64400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface PostImageFrombase64500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface PostImageFrombase64Request {
    /**
     * 图片的Base64 Data URI，必须包含MIME类型头。例如：`data:image/png;base64,...`
     */
    'imageData': string;
}
export interface PostImageMotou400Response {
    'error'?: string;
}
export interface PostImageMotou500Response {
    'error'?: string;
}
export interface PostImageSpeechless400Response {
    'error'?: string;
}
export interface PostImageSpeechless500Response {
    'error'?: string;
}
export interface PostImageSpeechlessRequest {
    /**
     * 表情包上方的文字内容。你们怎么不说话了，是不是都在偷偷 _______
     */
    'top_text'?: string;
    /**
     * 表情包下方的文字内容。求求你_______
     */
    'bottom_text'?: string;
}
export interface PostImageSvg400Response {
    'code'?: string;
    'message'?: string;
}
export interface PostImageSvg500Response {
    'code'?: string;
    'message'?: string;
}
export interface PostSearchAggregate200Response {
    /**
     * 实际执行的搜索查询
     */
    'query'?: string;
    /**
     * 搜索结果总数
     */
    'total_results'?: number;
    /**
     * 搜索结果列表
     */
    'results'?: Array<PostSearchAggregate200ResponseResultsInner>;
    /**
     * 各搜索引擎的结果数量统计
     */
    'sources'?: Array<PostSearchAggregate200ResponseSourcesInner>;
    /**
     * 处理耗时（毫秒）
     */
    'process_time_ms'?: number;
    /**
     * 结果是否来自缓存
     */
    'cached'?: boolean;
}
export interface PostSearchAggregate200ResponseResultsInner {
    /**
     * 结果标题
     */
    'title'?: string;
    /**
     * 结果链接
     */
    'url'?: string;
    /**
     * 结果摘要/描述
     */
    'snippet'?: string;
    /**
     * 来源域名
     */
    'domain'?: string;
    /**
     * 搜索引擎标识
     */
    'source'?: string;
    /**
     * 原始排名位置
     */
    'position'?: number;
    /**
     * 综合得分 (0-1，经过机器学习排序)
     */
    'score'?: number;
    /**
     * 发布时间 (ISO 8601 格式)
     */
    'publish_time'?: string;
    /**
     * 作者信息
     */
    'author'?: string | null;
}
export interface PostSearchAggregate200ResponseSourcesInner {
    'name'?: string;
    'status'?: string;
    'result_count'?: number;
    'elapsed_ms'?: number;
    'first_result_host'?: string;
}
export interface PostSearchAggregate400Response {
    'code'?: string;
    'message'?: string;
    'timestamp'?: string;
}
export interface PostSearchAggregate401Response {
    'code'?: string;
    'message'?: string;
    'timestamp'?: string;
}
export interface PostSearchAggregate429Response {
    'code'?: string;
    'message'?: string;
    'timestamp'?: string;
}
export interface PostSearchAggregate500Response {
    'code'?: string;
    'message'?: string;
    'timestamp'?: string;
}
export interface PostSearchAggregateRequest {
    /**
     * 搜索查询关键词，支持中英文
     */
    'query': string;
    /**
     * 限制搜索特定网站，不需要 `site:` 前缀
     */
    'site'?: string;
    /**
     * 限制文件类型，不需要 `filetype:` 前缀。支持 pdf、doc、docx、ppt、pptx、xls、xlsx、txt 等
     */
    'filetype'?: string;
    /**
     * 是否获取页面完整正文（会影响响应时间）
     */
    'fetch_full'?: boolean;
    /**
     * 请求超时时间（毫秒），范围 1000-30000
     */
    'timeout_ms'?: number;
}
export interface PostSensitiveWordAnalyze200Response {
    'results'?: Array<PostSensitiveWordAnalyze200ResponseResultsInner>;
    'total'?: number;
}
export interface PostSensitiveWordAnalyze200ResponseResultsInner {
    'k'?: string;
    'r'?: string;
    's'?: Array<number>;
    'v'?: Array<string>;
    't'?: Array<string>;
    'd'?: string;
}
export interface PostSensitiveWordAnalyze400Response {
    'code'?: string;
    'message'?: string;
}
export interface PostSensitiveWordAnalyze401Response {
    'code'?: string;
    'message'?: string;
}
export interface PostSensitiveWordAnalyze429Response {
    'code'?: string;
    'message'?: string;
}
export interface PostSensitiveWordAnalyzeRequest {
    /**
     * 要分析的关键词列表，单次最多100个，每个关键词最长50字符。
     */
    'keywords': Array<string>;
}
export interface PostSensitiveWordQuickCheck200Response {
    'status'?: string;
    'original_text'?: string;
    'masked_text'?: string;
    'forbidden_words'?: Array<string>;
}
export interface PostSensitiveWordQuickCheckRequest {
    /**
     * 需要检测的文本内容。支持简体和繁体中文。
     */
    'text': string;
}
export interface PostTextAesDecrypt200Response {
    'plaintext'?: string;
}
export interface PostTextAesDecrypt400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface PostTextAesDecrypt500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface PostTextAesDecryptRequest {
    /**
     * 密钥，长度必须为16、24或32字节，对应AES-128/192/256。
     */
    'key': string;
    /**
     * Base64编码的密文。
     */
    'text': string;
    /**
     * 16�ֽڵ�IV/Nonce����Ϊ16���ַ�
     */
    'nonce': string;
}
export interface PostTextAesEncrypt200Response {
    'ciphertext'?: string;
}
export interface PostTextAesEncrypt400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface PostTextAesEncrypt500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface PostTextAesEncryptRequest {
    /**
     * Key must be 16, 24, or 32 bytes long to select AES-128, AES-192, or AES-256.
     */
    'key': string;
    'text': string;
}
export interface PostTextAnalyze200Response {
    'characters'?: number;
    'lines'?: number;
    'paragraphs'?: number;
    'sentences'?: number;
    'words'?: number;
}
export interface PostTextAnalyze400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface PostTextAnalyzeRequest {
    'text': string;
}
export interface PostTextBase64Decode200Response {
    'decoded'?: string;
}
export interface PostTextBase64Decode400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface PostTextBase64DecodeRequest {
    'text': string;
}
export interface PostTextBase64Encode200Response {
    'encoded'?: string;
}
export interface PostTextBase64Encode400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface PostTextBase64EncodeRequest {
    'text': string;
}
export interface PostTextMd5400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface PostTextMd5Request {
    /**
     * 需要计算哈希值的文本
     */
    'text': string;
}
export interface PostTextMd5Verify200Response {
    'match'?: boolean;
}
export interface PostTextMd5Verify400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface PostTextMd5VerifyRequest {
    'hash': string;
    'text': string;
}
export interface PostTranslateText200Response {
    /**
     * The source language detected.
     */
    'source_lang'?: string;
    /**
     * The translated text.
     */
    'translated_text'?: string;
}
export interface PostTranslateText400Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface PostTranslateText500Response {
    'code'?: string;
    'details'?: object;
    'message'?: string;
}
export interface PostTranslateTextRequest {
    /**
     * 待翻译的文本内容。
     */
    'text': string;
}
export interface PostWebTomarkdownAsync202Response {
    /**
     * 任务唯一标识符
     */
    'task_id'?: string;
    /**
     * 任务状态
     */
    'status'?: string;
    /**
     * 要转换的URL
     */
    'url'?: string;
    /**
     * 任务创建时间（ISO 8601格式）
     */
    'created_at'?: string;
    /**
     * 提示信息
     */
    'message'?: string;
}
export interface PostWebTomarkdownAsync400Response {
    'error'?: string;
    'message'?: string;
    'code'?: number;
}
export interface SingleEndpoint {
    'path'?: string;
    'count'?: number;
}

/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 获取 UAPI Pro Search 引擎的详细信息，包括支持的功能特性、参数限制和使用说明。  ## 功能概述  此接口返回搜索引擎的完整配置信息，你可以用它来： - 了解搜索引擎支持哪些功能（如站内搜索、文件类型过滤等） - 获取参数的默认值和限制范围 - 查看当前引擎版本和可用状态  适合在应用初始化时调用，或用于动态配置搜索界面。       
         * @summary 获取搜索引擎信息
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchEngines: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/engines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 通过URL查询参数分析单个关键词，便于GET请求调用。
         * @summary 查询参数分析
         * @param {string} keyword 要分析的关键词，最长50字符。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSensitiveWordAnalyzeQuery: async (keyword: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('getSensitiveWordAnalyzeQuery', 'keyword', keyword)
            const localVarPath = `/sensitive-word/analyze-query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想在你的应用中集成搜索功能？我们提供了一个强大的搜索引擎API，让你可以轻松实现实时网页搜索。  ## 功能概述  UAPI Pro Search 是自研的智能搜索引擎，采用机器学习算法对搜索结果进行智能排序，确保最相关的内容排在前面。你可以用它搜索任何关键词，也可以限定在特定网站或特定文件类型中搜索。  - **实时网页搜索**: 毫秒级响应，快速返回搜索结果 - **智能排序**: 采用机器学习回归排序算法，结果更精准 - **站内搜索**: 支持 `site:` 操作符，在指定网站内搜索 - **文件类型过滤**: 支持 `filetype:` 操作符，快速找到 PDF、Word 等特定格式文件  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。       
         * @summary 智能搜索
         * @param {PostSearchAggregateRequest} postSearchAggregateRequest 包含搜索参数的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSearchAggregate: async (postSearchAggregateRequest: PostSearchAggregateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSearchAggregateRequest' is not null or undefined
            assertParamExists('postSearchAggregate', 'postSearchAggregateRequest', postSearchAggregateRequest)
            const localVarPath = `/search/aggregate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSearchAggregateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 分析单个或多个关键词的敏感程度，返回详细的风险评分和分析结果。  > [!VIP] > 本API基于先进的分析模型，提供三级缓存策略和并发处理能力。  ## 功能概述  - **模型驱动**: 使用先进的分析模型进行语义分析。 - **高性能**: 采用三级缓存策略（持久化存储 → 统一缓存 → 模型分析），确保高频请求的响应速度。 - **并发支持**: 支持批量并发处理，单次最多可分析100个关键词。 - **详细评分**: 提供色情、辱骂、暴力三个维度的详细风险评分。 - **变体识别**: 能够自动识别关键词的常见变体形式，如拼音、缩写等。  ## 风险评分说明  返回的 `s` 字段包含三个维度的风险评分，范围均为0.0至1.0：  - **s[0] - 色情风险**: 评估内容涉及色情信息的程度。 - **s[1] - 辱骂/仇恨言论风险**: 评估内容是否包含侮辱性或仇恨性言论。 - **s[2] - 暴力/威胁风险**: 评估内容是否涉及暴力或威胁信息。  风险等级可参考：0.0-0.3为低风险，0.3-0.7为中等风险，0.7-1.0为高风险。  ## 响应字段说明  | 字段 | 类型 | 说明 | |------|------|------| | `results` | array | 分析结果对象的数组。 | | `results[].k` | string | 您在请求中提供的原始关键词。 | | `results[].r` | string | 模型对该关键词的分析过程和判断理由的简要说明。 | | `results[].s` | array[float] | 一个包含三个浮点数的数组，分别代表[色情, 辱骂, 暴力]三个维度的风险评分。分值范围从0.0到1.0，越高代表风险越大。 | | `results[].v` | array[string] | 模型识别出的该关键词的常见变体形式，例如拼音、谐音、缩写等。 | | `results[].t` | array[string] | 根据分析结果为关键词附加的分类标签，便于进行程序化处理和过滤。 | | `results[].d` | string | 对整体分析结果的一句简短总结，适合直接展示给用户或记录在日志中。 | | `total` | integer | 本次请求成功分析的关键词总数。 |       
         * @summary 分析敏感词
         * @param {PostSensitiveWordAnalyzeRequest} postSensitiveWordAnalyzeRequest 包含待检测文本 \&#39;keywords\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSensitiveWordAnalyze: async (postSensitiveWordAnalyzeRequest: PostSensitiveWordAnalyzeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSensitiveWordAnalyzeRequest' is not null or undefined
            assertParamExists('postSensitiveWordAnalyze', 'postSensitiveWordAnalyzeRequest', postSensitiveWordAnalyzeRequest)
            const localVarPath = `/sensitive-word/analyze`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSensitiveWordAnalyzeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 在你的社区或应用中，需要来过滤掉不和谐的声音吗？这个接口可以助你一臂之力。  ## 功能概述  我们对敏感词检测接口进行了大幅升级，现在采用高效的 **Aho-Corasick 算法**，实现了多模式字符串匹配。这意味着你不再需要手动编写复杂的正则表达式，系统会自动高效地检测出文本中的所有敏感词。  ### 主要特性  - **高性能算法**：基于 Aho-Corasick 算法，单次扫描即可检测多个敏感词模式 - **简繁体支持**：自动识别和处理简体中文、繁体中文内容 - **多模匹配**：无需编写正则表达式，系统内置智能匹配逻辑 - **快速响应**：相比传统方法，检测速度显著提升  无论是论坛、社交平台还是评论系统，这个接口都能帮你快速构建内容审核功能。
         * @summary 敏感词检测（快速）
         * @param {PostSensitiveWordQuickCheckRequest} postSensitiveWordQuickCheckRequest 包含待检测文本 \&#39;text\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSensitiveWordQuickCheck: async (postSensitiveWordQuickCheckRequest: PostSensitiveWordQuickCheckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSensitiveWordQuickCheckRequest' is not null or undefined
            assertParamExists('postSensitiveWordQuickCheck', 'postSensitiveWordQuickCheckRequest', postSensitiveWordQuickCheckRequest)
            const localVarPath = `/text/profanitycheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSensitiveWordQuickCheckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 获取 UAPI Pro Search 引擎的详细信息，包括支持的功能特性、参数限制和使用说明。  ## 功能概述  此接口返回搜索引擎的完整配置信息，你可以用它来： - 了解搜索引擎支持哪些功能（如站内搜索、文件类型过滤等） - 获取参数的默认值和限制范围 - 查看当前引擎版本和可用状态  适合在应用初始化时调用，或用于动态配置搜索界面。       
         * @summary 获取搜索引擎信息
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchEngines(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSearchEngines200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchEngines(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSearchEngines']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 通过URL查询参数分析单个关键词，便于GET请求调用。
         * @summary 查询参数分析
         * @param {string} keyword 要分析的关键词，最长50字符。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSensitiveWordAnalyzeQuery(keyword: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostSensitiveWordAnalyze200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSensitiveWordAnalyzeQuery(keyword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSensitiveWordAnalyzeQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想在你的应用中集成搜索功能？我们提供了一个强大的搜索引擎API，让你可以轻松实现实时网页搜索。  ## 功能概述  UAPI Pro Search 是自研的智能搜索引擎，采用机器学习算法对搜索结果进行智能排序，确保最相关的内容排在前面。你可以用它搜索任何关键词，也可以限定在特定网站或特定文件类型中搜索。  - **实时网页搜索**: 毫秒级响应，快速返回搜索结果 - **智能排序**: 采用机器学习回归排序算法，结果更精准 - **站内搜索**: 支持 `site:` 操作符，在指定网站内搜索 - **文件类型过滤**: 支持 `filetype:` 操作符，快速找到 PDF、Word 等特定格式文件  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。       
         * @summary 智能搜索
         * @param {PostSearchAggregateRequest} postSearchAggregateRequest 包含搜索参数的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSearchAggregate(postSearchAggregateRequest: PostSearchAggregateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostSearchAggregate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSearchAggregate(postSearchAggregateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postSearchAggregate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 分析单个或多个关键词的敏感程度，返回详细的风险评分和分析结果。  > [!VIP] > 本API基于先进的分析模型，提供三级缓存策略和并发处理能力。  ## 功能概述  - **模型驱动**: 使用先进的分析模型进行语义分析。 - **高性能**: 采用三级缓存策略（持久化存储 → 统一缓存 → 模型分析），确保高频请求的响应速度。 - **并发支持**: 支持批量并发处理，单次最多可分析100个关键词。 - **详细评分**: 提供色情、辱骂、暴力三个维度的详细风险评分。 - **变体识别**: 能够自动识别关键词的常见变体形式，如拼音、缩写等。  ## 风险评分说明  返回的 `s` 字段包含三个维度的风险评分，范围均为0.0至1.0：  - **s[0] - 色情风险**: 评估内容涉及色情信息的程度。 - **s[1] - 辱骂/仇恨言论风险**: 评估内容是否包含侮辱性或仇恨性言论。 - **s[2] - 暴力/威胁风险**: 评估内容是否涉及暴力或威胁信息。  风险等级可参考：0.0-0.3为低风险，0.3-0.7为中等风险，0.7-1.0为高风险。  ## 响应字段说明  | 字段 | 类型 | 说明 | |------|------|------| | `results` | array | 分析结果对象的数组。 | | `results[].k` | string | 您在请求中提供的原始关键词。 | | `results[].r` | string | 模型对该关键词的分析过程和判断理由的简要说明。 | | `results[].s` | array[float] | 一个包含三个浮点数的数组，分别代表[色情, 辱骂, 暴力]三个维度的风险评分。分值范围从0.0到1.0，越高代表风险越大。 | | `results[].v` | array[string] | 模型识别出的该关键词的常见变体形式，例如拼音、谐音、缩写等。 | | `results[].t` | array[string] | 根据分析结果为关键词附加的分类标签，便于进行程序化处理和过滤。 | | `results[].d` | string | 对整体分析结果的一句简短总结，适合直接展示给用户或记录在日志中。 | | `total` | integer | 本次请求成功分析的关键词总数。 |       
         * @summary 分析敏感词
         * @param {PostSensitiveWordAnalyzeRequest} postSensitiveWordAnalyzeRequest 包含待检测文本 \&#39;keywords\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSensitiveWordAnalyze(postSensitiveWordAnalyzeRequest: PostSensitiveWordAnalyzeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostSensitiveWordAnalyze200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSensitiveWordAnalyze(postSensitiveWordAnalyzeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postSensitiveWordAnalyze']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 在你的社区或应用中，需要来过滤掉不和谐的声音吗？这个接口可以助你一臂之力。  ## 功能概述  我们对敏感词检测接口进行了大幅升级，现在采用高效的 **Aho-Corasick 算法**，实现了多模式字符串匹配。这意味着你不再需要手动编写复杂的正则表达式，系统会自动高效地检测出文本中的所有敏感词。  ### 主要特性  - **高性能算法**：基于 Aho-Corasick 算法，单次扫描即可检测多个敏感词模式 - **简繁体支持**：自动识别和处理简体中文、繁体中文内容 - **多模匹配**：无需编写正则表达式，系统内置智能匹配逻辑 - **快速响应**：相比传统方法，检测速度显著提升  无论是论坛、社交平台还是评论系统，这个接口都能帮你快速构建内容审核功能。
         * @summary 敏感词检测（快速）
         * @param {PostSensitiveWordQuickCheckRequest} postSensitiveWordQuickCheckRequest 包含待检测文本 \&#39;text\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSensitiveWordQuickCheck(postSensitiveWordQuickCheckRequest: PostSensitiveWordQuickCheckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostSensitiveWordQuickCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSensitiveWordQuickCheck(postSensitiveWordQuickCheckRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postSensitiveWordQuickCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 获取 UAPI Pro Search 引擎的详细信息，包括支持的功能特性、参数限制和使用说明。  ## 功能概述  此接口返回搜索引擎的完整配置信息，你可以用它来： - 了解搜索引擎支持哪些功能（如站内搜索、文件类型过滤等） - 获取参数的默认值和限制范围 - 查看当前引擎版本和可用状态  适合在应用初始化时调用，或用于动态配置搜索界面。       
         * @summary 获取搜索引擎信息
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchEngines(options?: RawAxiosRequestConfig): AxiosPromise<GetSearchEngines200Response> {
            return localVarFp.getSearchEngines(options).then((request) => request(axios, basePath));
        },
        /**
         * 通过URL查询参数分析单个关键词，便于GET请求调用。
         * @summary 查询参数分析
         * @param {string} keyword 要分析的关键词，最长50字符。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSensitiveWordAnalyzeQuery(keyword: string, options?: RawAxiosRequestConfig): AxiosPromise<PostSensitiveWordAnalyze200Response> {
            return localVarFp.getSensitiveWordAnalyzeQuery(keyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 想在你的应用中集成搜索功能？我们提供了一个强大的搜索引擎API，让你可以轻松实现实时网页搜索。  ## 功能概述  UAPI Pro Search 是自研的智能搜索引擎，采用机器学习算法对搜索结果进行智能排序，确保最相关的内容排在前面。你可以用它搜索任何关键词，也可以限定在特定网站或特定文件类型中搜索。  - **实时网页搜索**: 毫秒级响应，快速返回搜索结果 - **智能排序**: 采用机器学习回归排序算法，结果更精准 - **站内搜索**: 支持 `site:` 操作符，在指定网站内搜索 - **文件类型过滤**: 支持 `filetype:` 操作符，快速找到 PDF、Word 等特定格式文件  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。       
         * @summary 智能搜索
         * @param {PostSearchAggregateRequest} postSearchAggregateRequest 包含搜索参数的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSearchAggregate(postSearchAggregateRequest: PostSearchAggregateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostSearchAggregate200Response> {
            return localVarFp.postSearchAggregate(postSearchAggregateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 分析单个或多个关键词的敏感程度，返回详细的风险评分和分析结果。  > [!VIP] > 本API基于先进的分析模型，提供三级缓存策略和并发处理能力。  ## 功能概述  - **模型驱动**: 使用先进的分析模型进行语义分析。 - **高性能**: 采用三级缓存策略（持久化存储 → 统一缓存 → 模型分析），确保高频请求的响应速度。 - **并发支持**: 支持批量并发处理，单次最多可分析100个关键词。 - **详细评分**: 提供色情、辱骂、暴力三个维度的详细风险评分。 - **变体识别**: 能够自动识别关键词的常见变体形式，如拼音、缩写等。  ## 风险评分说明  返回的 `s` 字段包含三个维度的风险评分，范围均为0.0至1.0：  - **s[0] - 色情风险**: 评估内容涉及色情信息的程度。 - **s[1] - 辱骂/仇恨言论风险**: 评估内容是否包含侮辱性或仇恨性言论。 - **s[2] - 暴力/威胁风险**: 评估内容是否涉及暴力或威胁信息。  风险等级可参考：0.0-0.3为低风险，0.3-0.7为中等风险，0.7-1.0为高风险。  ## 响应字段说明  | 字段 | 类型 | 说明 | |------|------|------| | `results` | array | 分析结果对象的数组。 | | `results[].k` | string | 您在请求中提供的原始关键词。 | | `results[].r` | string | 模型对该关键词的分析过程和判断理由的简要说明。 | | `results[].s` | array[float] | 一个包含三个浮点数的数组，分别代表[色情, 辱骂, 暴力]三个维度的风险评分。分值范围从0.0到1.0，越高代表风险越大。 | | `results[].v` | array[string] | 模型识别出的该关键词的常见变体形式，例如拼音、谐音、缩写等。 | | `results[].t` | array[string] | 根据分析结果为关键词附加的分类标签，便于进行程序化处理和过滤。 | | `results[].d` | string | 对整体分析结果的一句简短总结，适合直接展示给用户或记录在日志中。 | | `total` | integer | 本次请求成功分析的关键词总数。 |       
         * @summary 分析敏感词
         * @param {PostSensitiveWordAnalyzeRequest} postSensitiveWordAnalyzeRequest 包含待检测文本 \&#39;keywords\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSensitiveWordAnalyze(postSensitiveWordAnalyzeRequest: PostSensitiveWordAnalyzeRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostSensitiveWordAnalyze200Response> {
            return localVarFp.postSensitiveWordAnalyze(postSensitiveWordAnalyzeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 在你的社区或应用中，需要来过滤掉不和谐的声音吗？这个接口可以助你一臂之力。  ## 功能概述  我们对敏感词检测接口进行了大幅升级，现在采用高效的 **Aho-Corasick 算法**，实现了多模式字符串匹配。这意味着你不再需要手动编写复杂的正则表达式，系统会自动高效地检测出文本中的所有敏感词。  ### 主要特性  - **高性能算法**：基于 Aho-Corasick 算法，单次扫描即可检测多个敏感词模式 - **简繁体支持**：自动识别和处理简体中文、繁体中文内容 - **多模匹配**：无需编写正则表达式，系统内置智能匹配逻辑 - **快速响应**：相比传统方法，检测速度显著提升  无论是论坛、社交平台还是评论系统，这个接口都能帮你快速构建内容审核功能。
         * @summary 敏感词检测（快速）
         * @param {PostSensitiveWordQuickCheckRequest} postSensitiveWordQuickCheckRequest 包含待检测文本 \&#39;text\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSensitiveWordQuickCheck(postSensitiveWordQuickCheckRequest: PostSensitiveWordQuickCheckRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostSensitiveWordQuickCheck200Response> {
            return localVarFp.postSensitiveWordQuickCheck(postSensitiveWordQuickCheckRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 获取 UAPI Pro Search 引擎的详细信息，包括支持的功能特性、参数限制和使用说明。  ## 功能概述  此接口返回搜索引擎的完整配置信息，你可以用它来： - 了解搜索引擎支持哪些功能（如站内搜索、文件类型过滤等） - 获取参数的默认值和限制范围 - 查看当前引擎版本和可用状态  适合在应用初始化时调用，或用于动态配置搜索界面。       
     * @summary 获取搜索引擎信息
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSearchEngines(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSearchEngines(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 通过URL查询参数分析单个关键词，便于GET请求调用。
     * @summary 查询参数分析
     * @param {string} keyword 要分析的关键词，最长50字符。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSensitiveWordAnalyzeQuery(keyword: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSensitiveWordAnalyzeQuery(keyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想在你的应用中集成搜索功能？我们提供了一个强大的搜索引擎API，让你可以轻松实现实时网页搜索。  ## 功能概述  UAPI Pro Search 是自研的智能搜索引擎，采用机器学习算法对搜索结果进行智能排序，确保最相关的内容排在前面。你可以用它搜索任何关键词，也可以限定在特定网站或特定文件类型中搜索。  - **实时网页搜索**: 毫秒级响应，快速返回搜索结果 - **智能排序**: 采用机器学习回归排序算法，结果更精准 - **站内搜索**: 支持 `site:` 操作符，在指定网站内搜索 - **文件类型过滤**: 支持 `filetype:` 操作符，快速找到 PDF、Word 等特定格式文件  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。       
     * @summary 智能搜索
     * @param {PostSearchAggregateRequest} postSearchAggregateRequest 包含搜索参数的JSON对象
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSearchAggregate(postSearchAggregateRequest: PostSearchAggregateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postSearchAggregate(postSearchAggregateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 分析单个或多个关键词的敏感程度，返回详细的风险评分和分析结果。  > [!VIP] > 本API基于先进的分析模型，提供三级缓存策略和并发处理能力。  ## 功能概述  - **模型驱动**: 使用先进的分析模型进行语义分析。 - **高性能**: 采用三级缓存策略（持久化存储 → 统一缓存 → 模型分析），确保高频请求的响应速度。 - **并发支持**: 支持批量并发处理，单次最多可分析100个关键词。 - **详细评分**: 提供色情、辱骂、暴力三个维度的详细风险评分。 - **变体识别**: 能够自动识别关键词的常见变体形式，如拼音、缩写等。  ## 风险评分说明  返回的 `s` 字段包含三个维度的风险评分，范围均为0.0至1.0：  - **s[0] - 色情风险**: 评估内容涉及色情信息的程度。 - **s[1] - 辱骂/仇恨言论风险**: 评估内容是否包含侮辱性或仇恨性言论。 - **s[2] - 暴力/威胁风险**: 评估内容是否涉及暴力或威胁信息。  风险等级可参考：0.0-0.3为低风险，0.3-0.7为中等风险，0.7-1.0为高风险。  ## 响应字段说明  | 字段 | 类型 | 说明 | |------|------|------| | `results` | array | 分析结果对象的数组。 | | `results[].k` | string | 您在请求中提供的原始关键词。 | | `results[].r` | string | 模型对该关键词的分析过程和判断理由的简要说明。 | | `results[].s` | array[float] | 一个包含三个浮点数的数组，分别代表[色情, 辱骂, 暴力]三个维度的风险评分。分值范围从0.0到1.0，越高代表风险越大。 | | `results[].v` | array[string] | 模型识别出的该关键词的常见变体形式，例如拼音、谐音、缩写等。 | | `results[].t` | array[string] | 根据分析结果为关键词附加的分类标签，便于进行程序化处理和过滤。 | | `results[].d` | string | 对整体分析结果的一句简短总结，适合直接展示给用户或记录在日志中。 | | `total` | integer | 本次请求成功分析的关键词总数。 |       
     * @summary 分析敏感词
     * @param {PostSensitiveWordAnalyzeRequest} postSensitiveWordAnalyzeRequest 包含待检测文本 \&#39;keywords\&#39; 的JSON对象
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSensitiveWordAnalyze(postSensitiveWordAnalyzeRequest: PostSensitiveWordAnalyzeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postSensitiveWordAnalyze(postSensitiveWordAnalyzeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 在你的社区或应用中，需要来过滤掉不和谐的声音吗？这个接口可以助你一臂之力。  ## 功能概述  我们对敏感词检测接口进行了大幅升级，现在采用高效的 **Aho-Corasick 算法**，实现了多模式字符串匹配。这意味着你不再需要手动编写复杂的正则表达式，系统会自动高效地检测出文本中的所有敏感词。  ### 主要特性  - **高性能算法**：基于 Aho-Corasick 算法，单次扫描即可检测多个敏感词模式 - **简繁体支持**：自动识别和处理简体中文、繁体中文内容 - **多模匹配**：无需编写正则表达式，系统内置智能匹配逻辑 - **快速响应**：相比传统方法，检测速度显著提升  无论是论坛、社交平台还是评论系统，这个接口都能帮你快速构建内容审核功能。
     * @summary 敏感词检测（快速）
     * @param {PostSensitiveWordQuickCheckRequest} postSensitiveWordQuickCheckRequest 包含待检测文本 \&#39;text\&#39; 的JSON对象
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSensitiveWordQuickCheck(postSensitiveWordQuickCheckRequest: PostSensitiveWordQuickCheckRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postSensitiveWordQuickCheck(postSensitiveWordQuickCheckRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClipzyApi - axios parameter creator
 */
export const ClipzyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **此接口用于“最高安全等级”方法。**  您提供第一步中获得的ID，它会返回存储在服务器上的**加密数据**。您需要在自己的客户端中，使用您自己保管的密钥来解密它。
         * @summary 步骤2 (方法一): 获取加密数据
         * @param {string} id 片段的唯一 ID。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClipzyGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getClipzyGet', 'id', id)
            const localVarPath = `/api/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **此接口用于“方便自动化”方法。**  您提供第一步获得的ID，并附上您自己保管的**解密密钥**作为 `key` 参数。服务器会直接为您解密，并返回纯文本内容。  > [!IMPORTANT] > 查看文档首页的 **cURL 示例**，了解此接口最典型的用法。
         * @summary 步骤2 (方法二): 获取原始文本
         * @param {string} id 片段的唯一 ID。
         * @param {string} key 用于解密的 Base64 编码的 AES 密钥。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClipzyRaw: async (id: string, key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getClipzyRaw', 'id', id)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getClipzyRaw', 'key', key)
            const localVarPath = `/api/raw/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 这是所有流程的第一步。您的客户端应用需要先在本地准备好 **加密后的数据**，然后调用此接口进行上传。成功后，您会得到一个用于后续操作的唯一ID。  > [!NOTE] > 您发送给此接口的应该是**密文**，而不是原始文本。请参考文档首页的JavaScript示例来了解如何在客户端进行加密。
         * @summary 步骤1：上传加密数据
         * @param {PostClipzyStoreRequest} postClipzyStoreRequest 包含加密数据和可选的TTL。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postClipzyStore: async (postClipzyStoreRequest: PostClipzyStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postClipzyStoreRequest' is not null or undefined
            assertParamExists('postClipzyStore', 'postClipzyStoreRequest', postClipzyStoreRequest)
            const localVarPath = `/api/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postClipzyStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClipzyApi - functional programming interface
 */
export const ClipzyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClipzyApiAxiosParamCreator(configuration)
    return {
        /**
         * **此接口用于“最高安全等级”方法。**  您提供第一步中获得的ID，它会返回存储在服务器上的**加密数据**。您需要在自己的客户端中，使用您自己保管的密钥来解密它。
         * @summary 步骤2 (方法一): 获取加密数据
         * @param {string} id 片段的唯一 ID。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClipzyGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetClipzyGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClipzyGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClipzyApi.getClipzyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * **此接口用于“方便自动化”方法。**  您提供第一步获得的ID，并附上您自己保管的**解密密钥**作为 `key` 参数。服务器会直接为您解密，并返回纯文本内容。  > [!IMPORTANT] > 查看文档首页的 **cURL 示例**，了解此接口最典型的用法。
         * @summary 步骤2 (方法二): 获取原始文本
         * @param {string} id 片段的唯一 ID。
         * @param {string} key 用于解密的 Base64 编码的 AES 密钥。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClipzyRaw(id: string, key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClipzyRaw(id, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClipzyApi.getClipzyRaw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 这是所有流程的第一步。您的客户端应用需要先在本地准备好 **加密后的数据**，然后调用此接口进行上传。成功后，您会得到一个用于后续操作的唯一ID。  > [!NOTE] > 您发送给此接口的应该是**密文**，而不是原始文本。请参考文档首页的JavaScript示例来了解如何在客户端进行加密。
         * @summary 步骤1：上传加密数据
         * @param {PostClipzyStoreRequest} postClipzyStoreRequest 包含加密数据和可选的TTL。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postClipzyStore(postClipzyStoreRequest: PostClipzyStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostClipzyStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postClipzyStore(postClipzyStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClipzyApi.postClipzyStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClipzyApi - factory interface
 */
export const ClipzyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClipzyApiFp(configuration)
    return {
        /**
         * **此接口用于“最高安全等级”方法。**  您提供第一步中获得的ID，它会返回存储在服务器上的**加密数据**。您需要在自己的客户端中，使用您自己保管的密钥来解密它。
         * @summary 步骤2 (方法一): 获取加密数据
         * @param {string} id 片段的唯一 ID。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClipzyGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetClipzyGet200Response> {
            return localVarFp.getClipzyGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * **此接口用于“方便自动化”方法。**  您提供第一步获得的ID，并附上您自己保管的**解密密钥**作为 `key` 参数。服务器会直接为您解密，并返回纯文本内容。  > [!IMPORTANT] > 查看文档首页的 **cURL 示例**，了解此接口最典型的用法。
         * @summary 步骤2 (方法二): 获取原始文本
         * @param {string} id 片段的唯一 ID。
         * @param {string} key 用于解密的 Base64 编码的 AES 密钥。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClipzyRaw(id: string, key: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getClipzyRaw(id, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 这是所有流程的第一步。您的客户端应用需要先在本地准备好 **加密后的数据**，然后调用此接口进行上传。成功后，您会得到一个用于后续操作的唯一ID。  > [!NOTE] > 您发送给此接口的应该是**密文**，而不是原始文本。请参考文档首页的JavaScript示例来了解如何在客户端进行加密。
         * @summary 步骤1：上传加密数据
         * @param {PostClipzyStoreRequest} postClipzyStoreRequest 包含加密数据和可选的TTL。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postClipzyStore(postClipzyStoreRequest: PostClipzyStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostClipzyStore200Response> {
            return localVarFp.postClipzyStore(postClipzyStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClipzyApi - object-oriented interface
 */
export class ClipzyApi extends BaseAPI {
    /**
     * **此接口用于“最高安全等级”方法。**  您提供第一步中获得的ID，它会返回存储在服务器上的**加密数据**。您需要在自己的客户端中，使用您自己保管的密钥来解密它。
     * @summary 步骤2 (方法一): 获取加密数据
     * @param {string} id 片段的唯一 ID。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getClipzyGet(id: string, options?: RawAxiosRequestConfig) {
        return ClipzyApiFp(this.configuration).getClipzyGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **此接口用于“方便自动化”方法。**  您提供第一步获得的ID，并附上您自己保管的**解密密钥**作为 `key` 参数。服务器会直接为您解密，并返回纯文本内容。  > [!IMPORTANT] > 查看文档首页的 **cURL 示例**，了解此接口最典型的用法。
     * @summary 步骤2 (方法二): 获取原始文本
     * @param {string} id 片段的唯一 ID。
     * @param {string} key 用于解密的 Base64 编码的 AES 密钥。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getClipzyRaw(id: string, key: string, options?: RawAxiosRequestConfig) {
        return ClipzyApiFp(this.configuration).getClipzyRaw(id, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 这是所有流程的第一步。您的客户端应用需要先在本地准备好 **加密后的数据**，然后调用此接口进行上传。成功后，您会得到一个用于后续操作的唯一ID。  > [!NOTE] > 您发送给此接口的应该是**密文**，而不是原始文本。请参考文档首页的JavaScript示例来了解如何在客户端进行加密。
     * @summary 步骤1：上传加密数据
     * @param {PostClipzyStoreRequest} postClipzyStoreRequest 包含加密数据和可选的TTL。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postClipzyStore(postClipzyStoreRequest: PostClipzyStoreRequest, options?: RawAxiosRequestConfig) {
        return ClipzyApiFp(this.configuration).postClipzyStore(postClipzyStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConvertApi - axios parameter creator
 */
export const ConvertApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 时间戳和日期字符串，哪个用着更顺手？别纠结了，这个接口让你轻松拥有两种格式！  ## 功能概述 这是一个非常智能的转换器。你给它一个 Unix 时间戳，它还你一个人类可读的日期时间；你给它一个日期时间字符串，它还你一个 Unix 时间戳。它会自动识别你输入的是哪种格式。  ## 使用须知 这个接口非常智能，能够自动识别输入格式：  - **输入时间戳**：支持10位秒级（如 `1672531200`）和13位毫秒级（如 `1672531200000`）。 - **输入日期字符串**：为了确保准确性，推荐使用 `YYYY-MM-DD HH:mm:ss` 标准格式（如 `2023-01-01 08:00:00`）。  > [!TIP] > 无论你输入哪种格式，响应中都会同时包含标准日期字符串和秒级Unix时间戳，方便你按需取用。  ## 错误处理指南 - **400 Bad Request**: 如果你提供的 `time` 参数既不是有效的时间戳，也不是我们支持的日期格式，就会收到这个错误。请检查你的输入值。
         * @summary Unix时间戳与日期字符串双向转换
         * @param {string} time 一个智能时间参数，可传入Unix时间戳（10位或13位）或标准日期字符串（如 \&#39;2023-10-27 10:30:00\&#39;），系统将自动识别并转换。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertUnixtime: async (time: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'time' is not null or undefined
            assertParamExists('getConvertUnixtime', 'time', time)
            const localVarPath = `/convert/unixtime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 还在为一团乱麻的 JSON 字符串头疼吗？这个接口能瞬间让它变得井井有条，赏心悦目。  ## 功能概述 你只需要提供一个原始的、可能是压缩过的或者格式混乱的 JSON 字符串，这个 API 就会返回一个经过美化（带标准缩进和换行）的版本。这在调试 API 响应、或者需要在前端界面清晰展示 JSON 数据时非常有用。  ## 使用须知 > [!NOTE] > **请求格式** > 请注意，待格式化的 JSON 字符串需要被包裹在另一个 JSON 对象中，作为 `content` 字段的值提交。具体格式请参考请求体示例。  ## 错误处理指南 - **400 Bad Request**: 最常见的原因是你提供的 `content` 字符串本身不是一个有效的 JSON。请仔细检查括号、引号是否正确闭合，或者有没有多余的逗号等语法错误。
         * @summary 美化并格式化JSON字符串
         * @param {PostConvertJsonRequest} postConvertJsonRequest 这是一个JSON对象，里面必须包含一个名为 &#x60;content&#x60; 的字段。这个字段的值，就是你希望格式化的、原始的JSON字符串。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConvertJson: async (postConvertJsonRequest: PostConvertJsonRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postConvertJsonRequest' is not null or undefined
            assertParamExists('postConvertJson', 'postConvertJsonRequest', postConvertJsonRequest)
            const localVarPath = `/convert/json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postConvertJsonRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConvertApi - functional programming interface
 */
export const ConvertApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConvertApiAxiosParamCreator(configuration)
    return {
        /**
         * 时间戳和日期字符串，哪个用着更顺手？别纠结了，这个接口让你轻松拥有两种格式！  ## 功能概述 这是一个非常智能的转换器。你给它一个 Unix 时间戳，它还你一个人类可读的日期时间；你给它一个日期时间字符串，它还你一个 Unix 时间戳。它会自动识别你输入的是哪种格式。  ## 使用须知 这个接口非常智能，能够自动识别输入格式：  - **输入时间戳**：支持10位秒级（如 `1672531200`）和13位毫秒级（如 `1672531200000`）。 - **输入日期字符串**：为了确保准确性，推荐使用 `YYYY-MM-DD HH:mm:ss` 标准格式（如 `2023-01-01 08:00:00`）。  > [!TIP] > 无论你输入哪种格式，响应中都会同时包含标准日期字符串和秒级Unix时间戳，方便你按需取用。  ## 错误处理指南 - **400 Bad Request**: 如果你提供的 `time` 参数既不是有效的时间戳，也不是我们支持的日期格式，就会收到这个错误。请检查你的输入值。
         * @summary Unix时间戳与日期字符串双向转换
         * @param {string} time 一个智能时间参数，可传入Unix时间戳（10位或13位）或标准日期字符串（如 \&#39;2023-10-27 10:30:00\&#39;），系统将自动识别并转换。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConvertUnixtime(time: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetConvertUnixtime200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConvertUnixtime(time, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConvertApi.getConvertUnixtime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 还在为一团乱麻的 JSON 字符串头疼吗？这个接口能瞬间让它变得井井有条，赏心悦目。  ## 功能概述 你只需要提供一个原始的、可能是压缩过的或者格式混乱的 JSON 字符串，这个 API 就会返回一个经过美化（带标准缩进和换行）的版本。这在调试 API 响应、或者需要在前端界面清晰展示 JSON 数据时非常有用。  ## 使用须知 > [!NOTE] > **请求格式** > 请注意，待格式化的 JSON 字符串需要被包裹在另一个 JSON 对象中，作为 `content` 字段的值提交。具体格式请参考请求体示例。  ## 错误处理指南 - **400 Bad Request**: 最常见的原因是你提供的 `content` 字符串本身不是一个有效的 JSON。请仔细检查括号、引号是否正确闭合，或者有没有多余的逗号等语法错误。
         * @summary 美化并格式化JSON字符串
         * @param {PostConvertJsonRequest} postConvertJsonRequest 这是一个JSON对象，里面必须包含一个名为 &#x60;content&#x60; 的字段。这个字段的值，就是你希望格式化的、原始的JSON字符串。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postConvertJson(postConvertJsonRequest: PostConvertJsonRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostConvertJson200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postConvertJson(postConvertJsonRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConvertApi.postConvertJson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConvertApi - factory interface
 */
export const ConvertApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConvertApiFp(configuration)
    return {
        /**
         * 时间戳和日期字符串，哪个用着更顺手？别纠结了，这个接口让你轻松拥有两种格式！  ## 功能概述 这是一个非常智能的转换器。你给它一个 Unix 时间戳，它还你一个人类可读的日期时间；你给它一个日期时间字符串，它还你一个 Unix 时间戳。它会自动识别你输入的是哪种格式。  ## 使用须知 这个接口非常智能，能够自动识别输入格式：  - **输入时间戳**：支持10位秒级（如 `1672531200`）和13位毫秒级（如 `1672531200000`）。 - **输入日期字符串**：为了确保准确性，推荐使用 `YYYY-MM-DD HH:mm:ss` 标准格式（如 `2023-01-01 08:00:00`）。  > [!TIP] > 无论你输入哪种格式，响应中都会同时包含标准日期字符串和秒级Unix时间戳，方便你按需取用。  ## 错误处理指南 - **400 Bad Request**: 如果你提供的 `time` 参数既不是有效的时间戳，也不是我们支持的日期格式，就会收到这个错误。请检查你的输入值。
         * @summary Unix时间戳与日期字符串双向转换
         * @param {string} time 一个智能时间参数，可传入Unix时间戳（10位或13位）或标准日期字符串（如 \&#39;2023-10-27 10:30:00\&#39;），系统将自动识别并转换。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertUnixtime(time: string, options?: RawAxiosRequestConfig): AxiosPromise<GetConvertUnixtime200Response> {
            return localVarFp.getConvertUnixtime(time, options).then((request) => request(axios, basePath));
        },
        /**
         * 还在为一团乱麻的 JSON 字符串头疼吗？这个接口能瞬间让它变得井井有条，赏心悦目。  ## 功能概述 你只需要提供一个原始的、可能是压缩过的或者格式混乱的 JSON 字符串，这个 API 就会返回一个经过美化（带标准缩进和换行）的版本。这在调试 API 响应、或者需要在前端界面清晰展示 JSON 数据时非常有用。  ## 使用须知 > [!NOTE] > **请求格式** > 请注意，待格式化的 JSON 字符串需要被包裹在另一个 JSON 对象中，作为 `content` 字段的值提交。具体格式请参考请求体示例。  ## 错误处理指南 - **400 Bad Request**: 最常见的原因是你提供的 `content` 字符串本身不是一个有效的 JSON。请仔细检查括号、引号是否正确闭合，或者有没有多余的逗号等语法错误。
         * @summary 美化并格式化JSON字符串
         * @param {PostConvertJsonRequest} postConvertJsonRequest 这是一个JSON对象，里面必须包含一个名为 &#x60;content&#x60; 的字段。这个字段的值，就是你希望格式化的、原始的JSON字符串。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConvertJson(postConvertJsonRequest: PostConvertJsonRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostConvertJson200Response> {
            return localVarFp.postConvertJson(postConvertJsonRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConvertApi - object-oriented interface
 */
export class ConvertApi extends BaseAPI {
    /**
     * 时间戳和日期字符串，哪个用着更顺手？别纠结了，这个接口让你轻松拥有两种格式！  ## 功能概述 这是一个非常智能的转换器。你给它一个 Unix 时间戳，它还你一个人类可读的日期时间；你给它一个日期时间字符串，它还你一个 Unix 时间戳。它会自动识别你输入的是哪种格式。  ## 使用须知 这个接口非常智能，能够自动识别输入格式：  - **输入时间戳**：支持10位秒级（如 `1672531200`）和13位毫秒级（如 `1672531200000`）。 - **输入日期字符串**：为了确保准确性，推荐使用 `YYYY-MM-DD HH:mm:ss` 标准格式（如 `2023-01-01 08:00:00`）。  > [!TIP] > 无论你输入哪种格式，响应中都会同时包含标准日期字符串和秒级Unix时间戳，方便你按需取用。  ## 错误处理指南 - **400 Bad Request**: 如果你提供的 `time` 参数既不是有效的时间戳，也不是我们支持的日期格式，就会收到这个错误。请检查你的输入值。
     * @summary Unix时间戳与日期字符串双向转换
     * @param {string} time 一个智能时间参数，可传入Unix时间戳（10位或13位）或标准日期字符串（如 \&#39;2023-10-27 10:30:00\&#39;），系统将自动识别并转换。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConvertUnixtime(time: string, options?: RawAxiosRequestConfig) {
        return ConvertApiFp(this.configuration).getConvertUnixtime(time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 还在为一团乱麻的 JSON 字符串头疼吗？这个接口能瞬间让它变得井井有条，赏心悦目。  ## 功能概述 你只需要提供一个原始的、可能是压缩过的或者格式混乱的 JSON 字符串，这个 API 就会返回一个经过美化（带标准缩进和换行）的版本。这在调试 API 响应、或者需要在前端界面清晰展示 JSON 数据时非常有用。  ## 使用须知 > [!NOTE] > **请求格式** > 请注意，待格式化的 JSON 字符串需要被包裹在另一个 JSON 对象中，作为 `content` 字段的值提交。具体格式请参考请求体示例。  ## 错误处理指南 - **400 Bad Request**: 最常见的原因是你提供的 `content` 字符串本身不是一个有效的 JSON。请仔细检查括号、引号是否正确闭合，或者有没有多余的逗号等语法错误。
     * @summary 美化并格式化JSON字符串
     * @param {PostConvertJsonRequest} postConvertJsonRequest 这是一个JSON对象，里面必须包含一个名为 &#x60;content&#x60; 的字段。这个字段的值，就是你希望格式化的、原始的JSON字符串。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postConvertJson(postConvertJsonRequest: PostConvertJsonRequest, options?: RawAxiosRequestConfig) {
        return ConvertApiFp(this.configuration).postConvertJson(postConvertJsonRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DailyApi - axios parameter creator
 */
export const DailyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 想用一张图快速了解天下大事？这个接口为你一键生成今日新闻摘要，非常适合用在早报、数字看板或应用首页等场景。  ## 功能概述 此接口会实时抓取各大平台的热点新闻，并动态地将它们渲染成一张清晰、美观的摘要图片。你调用接口，直接就能得到一张可以展示的图片。  ## 使用须知 调用此接口时，请务必注意以下两点：  1.  **响应格式是图片**：接口成功时直接返回 `image/jpeg` 格式的二进制数据，而非 JSON。请确保你的客户端能正确处理二进制流，例如直接在 `<img>` 标签中显示，或保存为 `.jpg` 文件。  2.  **设置合理超时**：由于涉及实时新闻抓取和图片渲染，处理过程可能耗时数秒。建议将客户端请求超时时间设置为至少10秒，以防止因等待过久而失败。  > [!IMPORTANT] > 未能正确处理图片响应或超时设置过短，是导致调用失败的最常见原因。
         * @summary 生成每日新闻摘要图片
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDailyNewsImage: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/daily/news-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DailyApi - functional programming interface
 */
export const DailyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DailyApiAxiosParamCreator(configuration)
    return {
        /**
         * 想用一张图快速了解天下大事？这个接口为你一键生成今日新闻摘要，非常适合用在早报、数字看板或应用首页等场景。  ## 功能概述 此接口会实时抓取各大平台的热点新闻，并动态地将它们渲染成一张清晰、美观的摘要图片。你调用接口，直接就能得到一张可以展示的图片。  ## 使用须知 调用此接口时，请务必注意以下两点：  1.  **响应格式是图片**：接口成功时直接返回 `image/jpeg` 格式的二进制数据，而非 JSON。请确保你的客户端能正确处理二进制流，例如直接在 `<img>` 标签中显示，或保存为 `.jpg` 文件。  2.  **设置合理超时**：由于涉及实时新闻抓取和图片渲染，处理过程可能耗时数秒。建议将客户端请求超时时间设置为至少10秒，以防止因等待过久而失败。  > [!IMPORTANT] > 未能正确处理图片响应或超时设置过短，是导致调用失败的最常见原因。
         * @summary 生成每日新闻摘要图片
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDailyNewsImage(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDailyNewsImage(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailyApi.getDailyNewsImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DailyApi - factory interface
 */
export const DailyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DailyApiFp(configuration)
    return {
        /**
         * 想用一张图快速了解天下大事？这个接口为你一键生成今日新闻摘要，非常适合用在早报、数字看板或应用首页等场景。  ## 功能概述 此接口会实时抓取各大平台的热点新闻，并动态地将它们渲染成一张清晰、美观的摘要图片。你调用接口，直接就能得到一张可以展示的图片。  ## 使用须知 调用此接口时，请务必注意以下两点：  1.  **响应格式是图片**：接口成功时直接返回 `image/jpeg` 格式的二进制数据，而非 JSON。请确保你的客户端能正确处理二进制流，例如直接在 `<img>` 标签中显示，或保存为 `.jpg` 文件。  2.  **设置合理超时**：由于涉及实时新闻抓取和图片渲染，处理过程可能耗时数秒。建议将客户端请求超时时间设置为至少10秒，以防止因等待过久而失败。  > [!IMPORTANT] > 未能正确处理图片响应或超时设置过短，是导致调用失败的最常见原因。
         * @summary 生成每日新闻摘要图片
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDailyNewsImage(options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getDailyNewsImage(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DailyApi - object-oriented interface
 */
export class DailyApi extends BaseAPI {
    /**
     * 想用一张图快速了解天下大事？这个接口为你一键生成今日新闻摘要，非常适合用在早报、数字看板或应用首页等场景。  ## 功能概述 此接口会实时抓取各大平台的热点新闻，并动态地将它们渲染成一张清晰、美观的摘要图片。你调用接口，直接就能得到一张可以展示的图片。  ## 使用须知 调用此接口时，请务必注意以下两点：  1.  **响应格式是图片**：接口成功时直接返回 `image/jpeg` 格式的二进制数据，而非 JSON。请确保你的客户端能正确处理二进制流，例如直接在 `<img>` 标签中显示，或保存为 `.jpg` 文件。  2.  **设置合理超时**：由于涉及实时新闻抓取和图片渲染，处理过程可能耗时数秒。建议将客户端请求超时时间设置为至少10秒，以防止因等待过久而失败。  > [!IMPORTANT] > 未能正确处理图片响应或超时设置过短，是导致调用失败的最常见原因。
     * @summary 生成每日新闻摘要图片
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDailyNewsImage(options?: RawAxiosRequestConfig) {
        return DailyApiFp(this.configuration).getDailyNewsImage(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GameApi - axios parameter creator
 */
export const GameApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 白嫖党的福音来了！想第一时间知道Epic商店本周送了哪些游戏大作吗？  ## 功能概述 这个接口帮你实时追踪Epic Games商店的每周免费游戏活动。无需任何参数，调用后即可获得当前所有免费游戏的完整信息，包括游戏封面、原价、剩余时间等，再也不用担心错过心仪的免费游戏了！  ## 使用场景 - 开发游戏资讯应用或网站 - 制作Epic免费游戏推送机器人 - 为用户提供游戏收藏建议 - 构建个人游戏库管理工具  > [!TIP] > **关于时间格式** > 为了方便不同场景的使用，我们同时提供了可读的时间字符串（如 `2025/01/10 00:00:00`）和13位毫秒时间戳。前端显示用字符串，程序逻辑用时间戳
         * @summary 获取Epic Games免费游戏
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameEpicFree: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/game/epic-free`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想知道某个大佬以前叫什么名字吗？这个接口可以帮你追溯一个 Minecraft 玩家的“黑历史”！  ## 功能概述 通过提供一个玩家的 UUID，你可以获取到该玩家所有曾用名及其变更时间的列表。这对于识别回归的老玩家或者社区管理非常有用。  ## 使用须知 > [!NOTE] > **UUID 格式** > 查询时，请务必提供玩家的 **32位无破折号** Minecraft UUID，例如 `ee9b4ed1aac1491eb7611471be374b80`。
         * @summary 查询Minecraft玩家历史用户名
         * @param {string} uuid 玩家的 Minecraft UUID，请务必使用32位无破折号的格式。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameMinecraftHistoryid: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getGameMinecraftHistoryid', 'uuid', uuid)
            const localVarPath = `/game/minecraft/historyid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想在加入服务器前看看有多少人在线？或者检查一下服务器开没开？用这个接口就对了！  ## 功能概述 你可以通过提供服务器地址（域名或IP），来获取一个 Minecraft Java 版服务器的实时状态。返回信息非常丰富，包括服务器是否在线、当前玩家数、最大玩家数、服务器版本、MOTD（每日消息）以及服务器图标等。
         * @summary 查询Minecraft服务器状态
         * @param {string} server Minecraft服务器的地址，可以是域名（如 &#x60;hypixel.net&#x60;）或 &#x60;IP:端口&#x60; 的形式（如 &#x60;mc.example.com:25565&#x60;）。如果省略端口，将默认使用 &#x60;25565&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameMinecraftServerstatus: async (server: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('getGameMinecraftServerstatus', 'server', server)
            const localVarPath = `/game/minecraft/serverstatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (server !== undefined) {
                localVarQueryParameter['server'] = server;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 只需要一个玩家的用户名，就能快速获取到他的正版皮肤和独一无二的UUID！  ## 功能概述 这是一个基础但非常实用的接口。通过玩家当前的游戏内名称（Username），你可以查询到他对应的UUID（唯一标识符）和当前皮肤的URL地址。这是构建许多其他玩家相关服务的第一步。
         * @summary 查询Minecraft玩家信息
         * @param {string} username 玩家的 Minecraft 游戏内名称（正版ID）。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameMinecraftUserinfo: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getGameMinecraftUserinfo', 'username', username)
            const localVarPath = `/game/minecraft/userinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想在你的网站或应用中展示用户的 Steam 个人资料？这个接口就是为你准备的。  ## 功能概述 通过一个用户的 Steam 标识（支持多种格式），你可以获取到他公开的个人资料摘要，包括昵称、头像、在线状态、真实姓名（如果公开）和个人资料主页URL等信息。  ## 支持的参数格式 接口现在支持以下几种标识符格式： - **`steamid`**: 64位SteamID（如 `76561197960287930`） - **`id`**: 自定义URL名称（如 `gabelogannewell`） - **`id3`**: Steam ID3格式（如 `STEAM_0:0:22202`） - 完整的个人资料链接 - 好友代码  ## 使用须知  > [!IMPORTANT] > **API Key 安全** > 此接口需要一个 Steam Web API Key。我们强烈建议由后端统一配置和调用，以避免在客户端泄露。当然，你也可以通过 `key` 查询参数临时提供一个Key来覆盖后端配置。  在处理响应时，请注意以下数字代码的含义： - **`personastate` (用户状态)**: 0-离线, 1-在线, 2-忙碌, 3-离开, 4-打盹, 5-想交易, 6-想玩。 - **`communityvisibilitystate` (社区可见性)**: 1-私密, 3-公开 (API通常只能查到这两种状态)。
         * @summary 获取Steam用户公开摘要
         * @param {string} [steamid] 用户的 Steam 标识。可以是以下任意一种格式： - 纯数字的 **SteamID64** - 用户的 **自定义 URL 名称** (Vanity URL) - 完整的 **个人资料链接** (包含 SteamID64 或自定义名称) - 好友代码 (如 &#x60;22202&#x60;)
         * @param {string} [id] 用户的 Steam 自定义URL名称（Vanity URL）。例如个人资料链接中 &#x60;/id/&#x60; 后面的部分。
         * @param {string} [id3] 用户的 Steam ID3 格式标识符。传统的 Steam ID 格式，形如 STEAM_X:Y:Z。
         * @param {string} [key] 你的 Steam Web API Key。这是一个可选参数，如果提供，它将覆盖我们在后端配置的全局Key。这为你提供了更大的灵活性，但请务必注意Key的保密，不要在前端暴露。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameSteamSummary: async (steamid?: string, id?: string, id3?: string, key?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/game/steam/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (steamid !== undefined) {
                localVarQueryParameter['steamid'] = steamid;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (id3 !== undefined) {
                localVarQueryParameter['id3'] = id3;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameApi - functional programming interface
 */
export const GameApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GameApiAxiosParamCreator(configuration)
    return {
        /**
         * 白嫖党的福音来了！想第一时间知道Epic商店本周送了哪些游戏大作吗？  ## 功能概述 这个接口帮你实时追踪Epic Games商店的每周免费游戏活动。无需任何参数，调用后即可获得当前所有免费游戏的完整信息，包括游戏封面、原价、剩余时间等，再也不用担心错过心仪的免费游戏了！  ## 使用场景 - 开发游戏资讯应用或网站 - 制作Epic免费游戏推送机器人 - 为用户提供游戏收藏建议 - 构建个人游戏库管理工具  > [!TIP] > **关于时间格式** > 为了方便不同场景的使用，我们同时提供了可读的时间字符串（如 `2025/01/10 00:00:00`）和13位毫秒时间戳。前端显示用字符串，程序逻辑用时间戳
         * @summary 获取Epic Games免费游戏
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGameEpicFree(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGameEpicFree200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGameEpicFree(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getGameEpicFree']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想知道某个大佬以前叫什么名字吗？这个接口可以帮你追溯一个 Minecraft 玩家的“黑历史”！  ## 功能概述 通过提供一个玩家的 UUID，你可以获取到该玩家所有曾用名及其变更时间的列表。这对于识别回归的老玩家或者社区管理非常有用。  ## 使用须知 > [!NOTE] > **UUID 格式** > 查询时，请务必提供玩家的 **32位无破折号** Minecraft UUID，例如 `ee9b4ed1aac1491eb7611471be374b80`。
         * @summary 查询Minecraft玩家历史用户名
         * @param {string} uuid 玩家的 Minecraft UUID，请务必使用32位无破折号的格式。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGameMinecraftHistoryid(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGameMinecraftHistoryid200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGameMinecraftHistoryid(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getGameMinecraftHistoryid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想在加入服务器前看看有多少人在线？或者检查一下服务器开没开？用这个接口就对了！  ## 功能概述 你可以通过提供服务器地址（域名或IP），来获取一个 Minecraft Java 版服务器的实时状态。返回信息非常丰富，包括服务器是否在线、当前玩家数、最大玩家数、服务器版本、MOTD（每日消息）以及服务器图标等。
         * @summary 查询Minecraft服务器状态
         * @param {string} server Minecraft服务器的地址，可以是域名（如 &#x60;hypixel.net&#x60;）或 &#x60;IP:端口&#x60; 的形式（如 &#x60;mc.example.com:25565&#x60;）。如果省略端口，将默认使用 &#x60;25565&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGameMinecraftServerstatus(server: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGameMinecraftServerstatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGameMinecraftServerstatus(server, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getGameMinecraftServerstatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 只需要一个玩家的用户名，就能快速获取到他的正版皮肤和独一无二的UUID！  ## 功能概述 这是一个基础但非常实用的接口。通过玩家当前的游戏内名称（Username），你可以查询到他对应的UUID（唯一标识符）和当前皮肤的URL地址。这是构建许多其他玩家相关服务的第一步。
         * @summary 查询Minecraft玩家信息
         * @param {string} username 玩家的 Minecraft 游戏内名称（正版ID）。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGameMinecraftUserinfo(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGameMinecraftUserinfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGameMinecraftUserinfo(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getGameMinecraftUserinfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想在你的网站或应用中展示用户的 Steam 个人资料？这个接口就是为你准备的。  ## 功能概述 通过一个用户的 Steam 标识（支持多种格式），你可以获取到他公开的个人资料摘要，包括昵称、头像、在线状态、真实姓名（如果公开）和个人资料主页URL等信息。  ## 支持的参数格式 接口现在支持以下几种标识符格式： - **`steamid`**: 64位SteamID（如 `76561197960287930`） - **`id`**: 自定义URL名称（如 `gabelogannewell`） - **`id3`**: Steam ID3格式（如 `STEAM_0:0:22202`） - 完整的个人资料链接 - 好友代码  ## 使用须知  > [!IMPORTANT] > **API Key 安全** > 此接口需要一个 Steam Web API Key。我们强烈建议由后端统一配置和调用，以避免在客户端泄露。当然，你也可以通过 `key` 查询参数临时提供一个Key来覆盖后端配置。  在处理响应时，请注意以下数字代码的含义： - **`personastate` (用户状态)**: 0-离线, 1-在线, 2-忙碌, 3-离开, 4-打盹, 5-想交易, 6-想玩。 - **`communityvisibilitystate` (社区可见性)**: 1-私密, 3-公开 (API通常只能查到这两种状态)。
         * @summary 获取Steam用户公开摘要
         * @param {string} [steamid] 用户的 Steam 标识。可以是以下任意一种格式： - 纯数字的 **SteamID64** - 用户的 **自定义 URL 名称** (Vanity URL) - 完整的 **个人资料链接** (包含 SteamID64 或自定义名称) - 好友代码 (如 &#x60;22202&#x60;)
         * @param {string} [id] 用户的 Steam 自定义URL名称（Vanity URL）。例如个人资料链接中 &#x60;/id/&#x60; 后面的部分。
         * @param {string} [id3] 用户的 Steam ID3 格式标识符。传统的 Steam ID 格式，形如 STEAM_X:Y:Z。
         * @param {string} [key] 你的 Steam Web API Key。这是一个可选参数，如果提供，它将覆盖我们在后端配置的全局Key。这为你提供了更大的灵活性，但请务必注意Key的保密，不要在前端暴露。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGameSteamSummary(steamid?: string, id?: string, id3?: string, key?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGameSteamSummary200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGameSteamSummary(steamid, id, id3, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getGameSteamSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GameApi - factory interface
 */
export const GameApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GameApiFp(configuration)
    return {
        /**
         * 白嫖党的福音来了！想第一时间知道Epic商店本周送了哪些游戏大作吗？  ## 功能概述 这个接口帮你实时追踪Epic Games商店的每周免费游戏活动。无需任何参数，调用后即可获得当前所有免费游戏的完整信息，包括游戏封面、原价、剩余时间等，再也不用担心错过心仪的免费游戏了！  ## 使用场景 - 开发游戏资讯应用或网站 - 制作Epic免费游戏推送机器人 - 为用户提供游戏收藏建议 - 构建个人游戏库管理工具  > [!TIP] > **关于时间格式** > 为了方便不同场景的使用，我们同时提供了可读的时间字符串（如 `2025/01/10 00:00:00`）和13位毫秒时间戳。前端显示用字符串，程序逻辑用时间戳
         * @summary 获取Epic Games免费游戏
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameEpicFree(options?: RawAxiosRequestConfig): AxiosPromise<GetGameEpicFree200Response> {
            return localVarFp.getGameEpicFree(options).then((request) => request(axios, basePath));
        },
        /**
         * 想知道某个大佬以前叫什么名字吗？这个接口可以帮你追溯一个 Minecraft 玩家的“黑历史”！  ## 功能概述 通过提供一个玩家的 UUID，你可以获取到该玩家所有曾用名及其变更时间的列表。这对于识别回归的老玩家或者社区管理非常有用。  ## 使用须知 > [!NOTE] > **UUID 格式** > 查询时，请务必提供玩家的 **32位无破折号** Minecraft UUID，例如 `ee9b4ed1aac1491eb7611471be374b80`。
         * @summary 查询Minecraft玩家历史用户名
         * @param {string} uuid 玩家的 Minecraft UUID，请务必使用32位无破折号的格式。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameMinecraftHistoryid(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<GetGameMinecraftHistoryid200Response> {
            return localVarFp.getGameMinecraftHistoryid(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 想在加入服务器前看看有多少人在线？或者检查一下服务器开没开？用这个接口就对了！  ## 功能概述 你可以通过提供服务器地址（域名或IP），来获取一个 Minecraft Java 版服务器的实时状态。返回信息非常丰富，包括服务器是否在线、当前玩家数、最大玩家数、服务器版本、MOTD（每日消息）以及服务器图标等。
         * @summary 查询Minecraft服务器状态
         * @param {string} server Minecraft服务器的地址，可以是域名（如 &#x60;hypixel.net&#x60;）或 &#x60;IP:端口&#x60; 的形式（如 &#x60;mc.example.com:25565&#x60;）。如果省略端口，将默认使用 &#x60;25565&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameMinecraftServerstatus(server: string, options?: RawAxiosRequestConfig): AxiosPromise<GetGameMinecraftServerstatus200Response> {
            return localVarFp.getGameMinecraftServerstatus(server, options).then((request) => request(axios, basePath));
        },
        /**
         * 只需要一个玩家的用户名，就能快速获取到他的正版皮肤和独一无二的UUID！  ## 功能概述 这是一个基础但非常实用的接口。通过玩家当前的游戏内名称（Username），你可以查询到他对应的UUID（唯一标识符）和当前皮肤的URL地址。这是构建许多其他玩家相关服务的第一步。
         * @summary 查询Minecraft玩家信息
         * @param {string} username 玩家的 Minecraft 游戏内名称（正版ID）。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameMinecraftUserinfo(username: string, options?: RawAxiosRequestConfig): AxiosPromise<GetGameMinecraftUserinfo200Response> {
            return localVarFp.getGameMinecraftUserinfo(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 想在你的网站或应用中展示用户的 Steam 个人资料？这个接口就是为你准备的。  ## 功能概述 通过一个用户的 Steam 标识（支持多种格式），你可以获取到他公开的个人资料摘要，包括昵称、头像、在线状态、真实姓名（如果公开）和个人资料主页URL等信息。  ## 支持的参数格式 接口现在支持以下几种标识符格式： - **`steamid`**: 64位SteamID（如 `76561197960287930`） - **`id`**: 自定义URL名称（如 `gabelogannewell`） - **`id3`**: Steam ID3格式（如 `STEAM_0:0:22202`） - 完整的个人资料链接 - 好友代码  ## 使用须知  > [!IMPORTANT] > **API Key 安全** > 此接口需要一个 Steam Web API Key。我们强烈建议由后端统一配置和调用，以避免在客户端泄露。当然，你也可以通过 `key` 查询参数临时提供一个Key来覆盖后端配置。  在处理响应时，请注意以下数字代码的含义： - **`personastate` (用户状态)**: 0-离线, 1-在线, 2-忙碌, 3-离开, 4-打盹, 5-想交易, 6-想玩。 - **`communityvisibilitystate` (社区可见性)**: 1-私密, 3-公开 (API通常只能查到这两种状态)。
         * @summary 获取Steam用户公开摘要
         * @param {string} [steamid] 用户的 Steam 标识。可以是以下任意一种格式： - 纯数字的 **SteamID64** - 用户的 **自定义 URL 名称** (Vanity URL) - 完整的 **个人资料链接** (包含 SteamID64 或自定义名称) - 好友代码 (如 &#x60;22202&#x60;)
         * @param {string} [id] 用户的 Steam 自定义URL名称（Vanity URL）。例如个人资料链接中 &#x60;/id/&#x60; 后面的部分。
         * @param {string} [id3] 用户的 Steam ID3 格式标识符。传统的 Steam ID 格式，形如 STEAM_X:Y:Z。
         * @param {string} [key] 你的 Steam Web API Key。这是一个可选参数，如果提供，它将覆盖我们在后端配置的全局Key。这为你提供了更大的灵活性，但请务必注意Key的保密，不要在前端暴露。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameSteamSummary(steamid?: string, id?: string, id3?: string, key?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetGameSteamSummary200Response> {
            return localVarFp.getGameSteamSummary(steamid, id, id3, key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GameApi - object-oriented interface
 */
export class GameApi extends BaseAPI {
    /**
     * 白嫖党的福音来了！想第一时间知道Epic商店本周送了哪些游戏大作吗？  ## 功能概述 这个接口帮你实时追踪Epic Games商店的每周免费游戏活动。无需任何参数，调用后即可获得当前所有免费游戏的完整信息，包括游戏封面、原价、剩余时间等，再也不用担心错过心仪的免费游戏了！  ## 使用场景 - 开发游戏资讯应用或网站 - 制作Epic免费游戏推送机器人 - 为用户提供游戏收藏建议 - 构建个人游戏库管理工具  > [!TIP] > **关于时间格式** > 为了方便不同场景的使用，我们同时提供了可读的时间字符串（如 `2025/01/10 00:00:00`）和13位毫秒时间戳。前端显示用字符串，程序逻辑用时间戳
     * @summary 获取Epic Games免费游戏
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGameEpicFree(options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getGameEpicFree(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想知道某个大佬以前叫什么名字吗？这个接口可以帮你追溯一个 Minecraft 玩家的“黑历史”！  ## 功能概述 通过提供一个玩家的 UUID，你可以获取到该玩家所有曾用名及其变更时间的列表。这对于识别回归的老玩家或者社区管理非常有用。  ## 使用须知 > [!NOTE] > **UUID 格式** > 查询时，请务必提供玩家的 **32位无破折号** Minecraft UUID，例如 `ee9b4ed1aac1491eb7611471be374b80`。
     * @summary 查询Minecraft玩家历史用户名
     * @param {string} uuid 玩家的 Minecraft UUID，请务必使用32位无破折号的格式。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGameMinecraftHistoryid(uuid: string, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getGameMinecraftHistoryid(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想在加入服务器前看看有多少人在线？或者检查一下服务器开没开？用这个接口就对了！  ## 功能概述 你可以通过提供服务器地址（域名或IP），来获取一个 Minecraft Java 版服务器的实时状态。返回信息非常丰富，包括服务器是否在线、当前玩家数、最大玩家数、服务器版本、MOTD（每日消息）以及服务器图标等。
     * @summary 查询Minecraft服务器状态
     * @param {string} server Minecraft服务器的地址，可以是域名（如 &#x60;hypixel.net&#x60;）或 &#x60;IP:端口&#x60; 的形式（如 &#x60;mc.example.com:25565&#x60;）。如果省略端口，将默认使用 &#x60;25565&#x60;。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGameMinecraftServerstatus(server: string, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getGameMinecraftServerstatus(server, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 只需要一个玩家的用户名，就能快速获取到他的正版皮肤和独一无二的UUID！  ## 功能概述 这是一个基础但非常实用的接口。通过玩家当前的游戏内名称（Username），你可以查询到他对应的UUID（唯一标识符）和当前皮肤的URL地址。这是构建许多其他玩家相关服务的第一步。
     * @summary 查询Minecraft玩家信息
     * @param {string} username 玩家的 Minecraft 游戏内名称（正版ID）。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGameMinecraftUserinfo(username: string, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getGameMinecraftUserinfo(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想在你的网站或应用中展示用户的 Steam 个人资料？这个接口就是为你准备的。  ## 功能概述 通过一个用户的 Steam 标识（支持多种格式），你可以获取到他公开的个人资料摘要，包括昵称、头像、在线状态、真实姓名（如果公开）和个人资料主页URL等信息。  ## 支持的参数格式 接口现在支持以下几种标识符格式： - **`steamid`**: 64位SteamID（如 `76561197960287930`） - **`id`**: 自定义URL名称（如 `gabelogannewell`） - **`id3`**: Steam ID3格式（如 `STEAM_0:0:22202`） - 完整的个人资料链接 - 好友代码  ## 使用须知  > [!IMPORTANT] > **API Key 安全** > 此接口需要一个 Steam Web API Key。我们强烈建议由后端统一配置和调用，以避免在客户端泄露。当然，你也可以通过 `key` 查询参数临时提供一个Key来覆盖后端配置。  在处理响应时，请注意以下数字代码的含义： - **`personastate` (用户状态)**: 0-离线, 1-在线, 2-忙碌, 3-离开, 4-打盹, 5-想交易, 6-想玩。 - **`communityvisibilitystate` (社区可见性)**: 1-私密, 3-公开 (API通常只能查到这两种状态)。
     * @summary 获取Steam用户公开摘要
     * @param {string} [steamid] 用户的 Steam 标识。可以是以下任意一种格式： - 纯数字的 **SteamID64** - 用户的 **自定义 URL 名称** (Vanity URL) - 完整的 **个人资料链接** (包含 SteamID64 或自定义名称) - 好友代码 (如 &#x60;22202&#x60;)
     * @param {string} [id] 用户的 Steam 自定义URL名称（Vanity URL）。例如个人资料链接中 &#x60;/id/&#x60; 后面的部分。
     * @param {string} [id3] 用户的 Steam ID3 格式标识符。传统的 Steam ID 格式，形如 STEAM_X:Y:Z。
     * @param {string} [key] 你的 Steam Web API Key。这是一个可选参数，如果提供，它将覆盖我们在后端配置的全局Key。这为你提供了更大的灵活性，但请务必注意Key的保密，不要在前端暴露。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGameSteamSummary(steamid?: string, id?: string, id3?: string, key?: string, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getGameSteamSummary(steamid, id, id3, key, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImageApi - axios parameter creator
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 提供一个超高速、高可用的Gravatar头像代理服务。内置了强大的ETag条件缓存，确保用户在更新Gravatar头像后能几乎立刻看到变化，同时最大化地利用缓存。
         * @summary 获取Gravatar头像
         * @param {string} [email] 用户的 Email 地址。如果未提供 &#x60;hash&#x60; 参数，则此参数为必需。
         * @param {string} [hash] 用户 Email 地址的小写 MD5 哈希值。如果提供此参数，将忽略 &#x60;email&#x60; 参数。
         * @param {number} [s] 头像的尺寸，单位为像素。有效范围是 1 到 2048。
         * @param {string} [d] 当用户没有自己的 Gravatar 头像时，显示的默认头像类型。可选值包括 &#x60;mp&#x60;, &#x60;identicon&#x60;, &#x60;monsterid&#x60;, &#x60;wavatar&#x60;, &#x60;retro&#x60;, &#x60;robohash&#x60;, &#x60;blank&#x60;, &#x60;404&#x60;。
         * @param {string} [r] 头像分级。可选值：&#x60;g&#x60;, &#x60;pg&#x60;, &#x60;r&#x60;, &#x60;x&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvatarGravatar: async (email?: string, hash?: string, s?: number, d?: string, r?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/avatar/gravatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            if (s !== undefined) {
                localVarQueryParameter['s'] = s;
            }

            if (d !== undefined) {
                localVarQueryParameter['d'] = d;
            }

            if (r !== undefined) {
                localVarQueryParameter['r'] = r;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 每天都想换张新壁纸？让必应的美图点亮你的一天吧！  ## 功能概述 这个接口会获取 Bing 搜索引擎当天全球同步的每日壁纸，并直接以图片形式返回。你可以用它来做应用的启动页、网站背景，或者任何需要每日更新精美图片的地方。  ## 使用须知  > [!NOTE] > **响应格式是图片** > 请注意，此接口成功时直接返回图片二进制数据（通常为 `image/jpeg`），而非 JSON 格式。请确保客户端能够正确处理。  我们内置了备用方案：如果从必应官方获取图片失败，系统会尝试返回一张预存的高质量风景图，以保证服务的稳定性。
         * @summary 获取必应每日壁纸
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageBingDaily: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image/bing-daily`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想在线rua一下好友的头像吗？这个趣味接口可以满足你。  ## 功能概述 此接口通过GET方法，专门用于通过QQ号生成摸摸头GIF。你只需要提供一个QQ号码，我们就会自动获取其公开头像，并制作成一个可爱的动图。  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/gif` 格式的二进制数据。 - **背景颜色**：你可以通过 `bg_color` 参数来控制GIF的背景。使用 `transparent` 选项可以让它更好地融入各种聊天背景中。
         * @summary 生成摸摸头GIF (QQ号方式)
         * @param {string} qq 你想要摸头的对象的QQ号码。
         * @param {GetImageMotouBgColorEnum} [bgColor] GIF的背景颜色。留空则由后端服务决定默认值。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageMotou: async (qq: string, bgColor?: GetImageMotouBgColorEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qq' is not null or undefined
            assertParamExists('getImageMotou', 'qq', qq)
            const localVarPath = `/image/motou`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (qq !== undefined) {
                localVarQueryParameter['qq'] = qq;
            }

            if (bgColor !== undefined) {
                localVarQueryParameter['bg_color'] = bgColor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 无论是网址、文本还是联系方式，通通可以变成一个二维码！这是一个非常灵活的二维码生成工具。  ## 功能概述 你提供一段文本内容，我们为你生成对应的二维码图片。你可以自定义尺寸，并选择不同的返回格式以适应不同场景。  ## 使用须知  > [!IMPORTANT] > **关键参数 `format`** > 此参数决定了成功响应的内容类型和结构，请务必根据你的需求选择并正确处理响应： > - **`image`** (默认): 直接返回 `image/png` 格式的图片二进制数据，适合在 `<img>` 标签中直接使用。 > - **`json`**: 返回一个包含 Base64 Data URI 的 JSON 对象，适合需要在前端直接嵌入CSS或HTML的场景。 > - **`json_url`**: 返回一个包含图片临时URL的JSON对象，适合需要图片链接的场景。
         * @summary 动态生成二维码
         * @param {string} text 你希望编码到二维码中的任何文本内容，比如一个URL、一段话或者一个JSON字符串。
         * @param {number} [size] 二维码图片的边长（正方形），单位是像素。有效范围是 256 到 1024 之间。
         * @param {GetImageQrcodeFormatEnum} [format] 指定响应内容的格式。可选值为 &#x60;image&#x60;, &#x60;json&#x60;, &#x60;json_url&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageQrcode: async (text: string, size?: number, format?: GetImageQrcodeFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'text' is not null or undefined
            assertParamExists('getImageQrcode', 'text', text)
            const localVarPath = `/image/qrcode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 看到一张网上的图片，想把它转换成 Base64 编码以便嵌入到你的 HTML 或 CSS 中？用这个接口就对了。  ## 功能概述 你提供一个公开可访问的图片 URL，我们帮你把它下载下来，并转换成包含 MIME 类型的 Base64 Data URI 字符串返回给你。
         * @summary 将在线图片转换为Base64
         * @param {string} url 需要转换为Base64的、可公开访问的图片URL地址。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageTobase64: async (url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('getImageTobase64', 'url', url)
            const localVarPath = `/image/tobase64`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 还在为图片体积和加载速度发愁吗？体验一下我们强大的**无损压缩服务**，它能在几乎不牺牲任何肉眼可感知的画质的前提下，将图片体积压缩到极致。  ## 功能概述 你只需要上传一张常见的图片（如 PNG, JPG），选择一个压缩等级，就能获得一个体积小到惊人的压缩文件。这对于需要大量展示高清图片的网站、App 或小程序来说，是优化用户体验、节省带宽和存储成本的利器。  ## 使用须知 > [!TIP] > 为了给您最好的压缩效果，我们的算法需要进行复杂计算，处理时间可能会稍长一些，请耐心等待。  > [!WARNING] > **服务排队提醒** > 这是一个计算密集型服务。在高并发时，您的请求可能会被排队等待处理。如果您需要将其集成到对延迟敏感的生产服务中，请注意这一点。  ### 请求与响应格式 - 请求必须使用 `multipart/form-data` 格式上传文件。 - 成功响应将直接返回压缩后的文件二进制流 (`application/octet-stream`)，并附带 `Content-Disposition` 头，建议客户端根据此头信息保存文件。  ## 参数详解 ### `level` (压缩等级) 这是一个从 `1` 到 `5` 的整数，它决定了压缩的强度和策略，数字越小，压缩率越高。所有等级都经过精心调校，以在最大化压缩率的同时保证出色的视觉质量。 - `1`: **极限压缩** (推荐，体积最小，画质优异) - `2`: **高效压缩** - `3`: **智能均衡** (默认选项) - `4`: **画质优先** - `5`: **专业保真** (压缩率稍低，保留最多图像信息)  ## 错误处理指南 - **400 Bad Request**: 通常因为没有上传文件，或者 `level` 参数不在 1-5 的范围内。 - **500 Internal Server Error**: 如果在压缩过程中服务器发生内部错误，会返回此状态码。
         * @summary 无损压缩图片
         * @param {File} file 支持PNG, JPG, JPEG等常见图片格式。文件大小不超过15MB。
         * @param {PostImageCompressLevelEnum} [level] 压缩强度 (1-5)，默认为 3。数字越小，压缩率越高。
         * @param {PostImageCompressFormatEnum} [format] 输出图片格式，可以是 \&#39;png\&#39; 或 \&#39;jpeg\&#39;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImageCompress: async (file: File, level?: PostImageCompressLevelEnum, format?: PostImageCompressFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('postImageCompress', 'file', file)
            const localVarPath = `/image/compress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 当你需要在前端处理完图片（比如裁剪、加滤镜后），不通过传统表单，而是直接上传图片的场景，这个接口就派上用场了。  ## 功能概述 你只需要将图片的 Base64 编码字符串发送过来，我们就会把它解码、保存为图片文件，并返回一个可供访问的公开 URL。  ## 使用须知  > [!IMPORTANT] > **关于 `imageData` 格式** > 你发送的 `imageData` 字符串必须是完整的 Base64 Data URI 格式，它需要包含 MIME 类型信息，例如 `data:image/png;base64,iVBORw0KGgo...`。缺少 `data:image/...;base64,` 前缀将导致解码失败。
         * @summary 通过Base64编码上传图片
         * @param {PostImageFrombase64Request} postImageFrombase64Request 一个JSON对象，包含 &#x60;imageData&#x60; 字段，其值为你想要上传图片的完整Base64 Data URI。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImageFrombase64: async (postImageFrombase64Request: PostImageFrombase64Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postImageFrombase64Request' is not null or undefined
            assertParamExists('postImageFrombase64', 'postImageFrombase64Request', postImageFrombase64Request)
            const localVarPath = `/image/frombase64`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postImageFrombase64Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 除了使用QQ头像，你还可以通过上传自己的图片或提供图片URL来制作独一无二的摸摸头GIF。  ## 功能概述 此接口通过POST方法，支持两种方式生成GIF： 1.  **图片URL**：在表单中提供 `image_url` 字段。 2.  **上传图片**：在表单中上传 `file` 文件。  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/gif` 格式的二进制数据。 - **参数优先级**：如果同时提供了 `image_url` 和上传的 `file` 文件，系统将 **优先使用 `image_url`**。 - **背景颜色**：同样支持 `bg_color` 表单字段来控制GIF背景。
         * @summary 生成摸摸头GIF (图片上传或URL方式)
         * @param {string} [imageUrl] 图片的URL地址。如果提供此项，将优先使用该URL的图片。
         * @param {File} [file] 上传的图片文件。支持JPG、PNG、GIF等常见格式。
         * @param {PostImageMotouBgColorEnum} [bgColor] GIF的背景颜色。可选值为 \\\&#39;white\\\&#39;, \\\&#39;black\\\&#39;, \\\&#39;transparent\\\&#39;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImageMotou: async (imageUrl?: string, file?: File, bgColor?: PostImageMotouBgColorEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image/motou`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (imageUrl !== undefined) { 
                localVarFormParams.append('image_url', imageUrl as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (bgColor !== undefined) { 
                localVarFormParams.append('bg_color', bgColor as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 你们怎么不说话了？是不是都在偷偷玩Uapi，求求你们不要玩Uapi了  ## 效果展示 ![示例](https://uapis.cn/static/uploads/33580466897f1e5815296f235b582815.png)  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/jpeg` 格式的二进制数据。 - **文字内容**：至少需要提供 `top_text`（上方文字）或 `bottom_text`（下方文字）之一。 - **梗图逻辑**：上方描述某个行为，下方通常以「们」开头表示劝阻，形成戏谑的对比效果。
         * @summary 生成你们怎么不说话了表情包
         * @param {PostImageSpeechlessRequest} postImageSpeechlessRequest 包含表情包文字内容的JSON对象。至少需要提供上方或下方文字之一。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImageSpeechless: async (postImageSpeechlessRequest: PostImageSpeechlessRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postImageSpeechlessRequest' is not null or undefined
            assertParamExists('postImageSpeechless', 'postImageSpeechlessRequest', postImageSpeechlessRequest)
            const localVarPath = `/image/speechless`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postImageSpeechlessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 需要将灵活的 SVG 矢量图形转换为常见的光栅图像格式吗？这个接口可以帮你轻松实现。  ## 功能概述 上传一个 SVG 文件，并指定目标格式（如 PNG、JPEG 等），接口将返回转换后的图像。你还可以调整输出图像的尺寸和（对于JPEG）压缩质量，以满足不同场景的需求。
         * @summary SVG转图片
         * @param {PostImageSvgFormatEnum} [format] 输出图像的目标格式。支持的值：&#x60;png&#x60;, &#x60;jpeg&#x60;, &#x60;jpg&#x60;, &#x60;gif&#x60;, &#x60;tiff&#x60;, &#x60;bmp&#x60;。
         * @param {number} [width] 输出图像的宽度（像素）。如果省略，将根据 &#x60;height&#x60; 保持宽高比，或者使用 SVG 的原始宽度。
         * @param {number} [height] 输出图像的高度（像素）。如果省略，将根据 &#x60;width&#x60; 保持宽高比，或者使用 SVG 的原始高度。
         * @param {number} [quality] JPEG 图像的压缩质量（1-100）。仅当 &#x60;format&#x60; 为 &#x60;jpeg&#x60; 或 &#x60;jpg&#x60; 时有效。
         * @param {File} [file] 支持SVG文件
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImageSvg: async (format?: PostImageSvgFormatEnum, width?: number, height?: number, quality?: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image/svg`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageApi - functional programming interface
 */
export const ImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 提供一个超高速、高可用的Gravatar头像代理服务。内置了强大的ETag条件缓存，确保用户在更新Gravatar头像后能几乎立刻看到变化，同时最大化地利用缓存。
         * @summary 获取Gravatar头像
         * @param {string} [email] 用户的 Email 地址。如果未提供 &#x60;hash&#x60; 参数，则此参数为必需。
         * @param {string} [hash] 用户 Email 地址的小写 MD5 哈希值。如果提供此参数，将忽略 &#x60;email&#x60; 参数。
         * @param {number} [s] 头像的尺寸，单位为像素。有效范围是 1 到 2048。
         * @param {string} [d] 当用户没有自己的 Gravatar 头像时，显示的默认头像类型。可选值包括 &#x60;mp&#x60;, &#x60;identicon&#x60;, &#x60;monsterid&#x60;, &#x60;wavatar&#x60;, &#x60;retro&#x60;, &#x60;robohash&#x60;, &#x60;blank&#x60;, &#x60;404&#x60;。
         * @param {string} [r] 头像分级。可选值：&#x60;g&#x60;, &#x60;pg&#x60;, &#x60;r&#x60;, &#x60;x&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvatarGravatar(email?: string, hash?: string, s?: number, d?: string, r?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvatarGravatar(email, hash, s, d, r, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getAvatarGravatar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 每天都想换张新壁纸？让必应的美图点亮你的一天吧！  ## 功能概述 这个接口会获取 Bing 搜索引擎当天全球同步的每日壁纸，并直接以图片形式返回。你可以用它来做应用的启动页、网站背景，或者任何需要每日更新精美图片的地方。  ## 使用须知  > [!NOTE] > **响应格式是图片** > 请注意，此接口成功时直接返回图片二进制数据（通常为 `image/jpeg`），而非 JSON 格式。请确保客户端能够正确处理。  我们内置了备用方案：如果从必应官方获取图片失败，系统会尝试返回一张预存的高质量风景图，以保证服务的稳定性。
         * @summary 获取必应每日壁纸
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageBingDaily(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageBingDaily(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getImageBingDaily']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想在线rua一下好友的头像吗？这个趣味接口可以满足你。  ## 功能概述 此接口通过GET方法，专门用于通过QQ号生成摸摸头GIF。你只需要提供一个QQ号码，我们就会自动获取其公开头像，并制作成一个可爱的动图。  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/gif` 格式的二进制数据。 - **背景颜色**：你可以通过 `bg_color` 参数来控制GIF的背景。使用 `transparent` 选项可以让它更好地融入各种聊天背景中。
         * @summary 生成摸摸头GIF (QQ号方式)
         * @param {string} qq 你想要摸头的对象的QQ号码。
         * @param {GetImageMotouBgColorEnum} [bgColor] GIF的背景颜色。留空则由后端服务决定默认值。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageMotou(qq: string, bgColor?: GetImageMotouBgColorEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageMotou(qq, bgColor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getImageMotou']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 无论是网址、文本还是联系方式，通通可以变成一个二维码！这是一个非常灵活的二维码生成工具。  ## 功能概述 你提供一段文本内容，我们为你生成对应的二维码图片。你可以自定义尺寸，并选择不同的返回格式以适应不同场景。  ## 使用须知  > [!IMPORTANT] > **关键参数 `format`** > 此参数决定了成功响应的内容类型和结构，请务必根据你的需求选择并正确处理响应： > - **`image`** (默认): 直接返回 `image/png` 格式的图片二进制数据，适合在 `<img>` 标签中直接使用。 > - **`json`**: 返回一个包含 Base64 Data URI 的 JSON 对象，适合需要在前端直接嵌入CSS或HTML的场景。 > - **`json_url`**: 返回一个包含图片临时URL的JSON对象，适合需要图片链接的场景。
         * @summary 动态生成二维码
         * @param {string} text 你希望编码到二维码中的任何文本内容，比如一个URL、一段话或者一个JSON字符串。
         * @param {number} [size] 二维码图片的边长（正方形），单位是像素。有效范围是 256 到 1024 之间。
         * @param {GetImageQrcodeFormatEnum} [format] 指定响应内容的格式。可选值为 &#x60;image&#x60;, &#x60;json&#x60;, &#x60;json_url&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageQrcode(text: string, size?: number, format?: GetImageQrcodeFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageQrcode(text, size, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getImageQrcode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 看到一张网上的图片，想把它转换成 Base64 编码以便嵌入到你的 HTML 或 CSS 中？用这个接口就对了。  ## 功能概述 你提供一个公开可访问的图片 URL，我们帮你把它下载下来，并转换成包含 MIME 类型的 Base64 Data URI 字符串返回给你。
         * @summary 将在线图片转换为Base64
         * @param {string} url 需要转换为Base64的、可公开访问的图片URL地址。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageTobase64(url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetImageTobase64200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageTobase64(url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getImageTobase64']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 还在为图片体积和加载速度发愁吗？体验一下我们强大的**无损压缩服务**，它能在几乎不牺牲任何肉眼可感知的画质的前提下，将图片体积压缩到极致。  ## 功能概述 你只需要上传一张常见的图片（如 PNG, JPG），选择一个压缩等级，就能获得一个体积小到惊人的压缩文件。这对于需要大量展示高清图片的网站、App 或小程序来说，是优化用户体验、节省带宽和存储成本的利器。  ## 使用须知 > [!TIP] > 为了给您最好的压缩效果，我们的算法需要进行复杂计算，处理时间可能会稍长一些，请耐心等待。  > [!WARNING] > **服务排队提醒** > 这是一个计算密集型服务。在高并发时，您的请求可能会被排队等待处理。如果您需要将其集成到对延迟敏感的生产服务中，请注意这一点。  ### 请求与响应格式 - 请求必须使用 `multipart/form-data` 格式上传文件。 - 成功响应将直接返回压缩后的文件二进制流 (`application/octet-stream`)，并附带 `Content-Disposition` 头，建议客户端根据此头信息保存文件。  ## 参数详解 ### `level` (压缩等级) 这是一个从 `1` 到 `5` 的整数，它决定了压缩的强度和策略，数字越小，压缩率越高。所有等级都经过精心调校，以在最大化压缩率的同时保证出色的视觉质量。 - `1`: **极限压缩** (推荐，体积最小，画质优异) - `2`: **高效压缩** - `3`: **智能均衡** (默认选项) - `4`: **画质优先** - `5`: **专业保真** (压缩率稍低，保留最多图像信息)  ## 错误处理指南 - **400 Bad Request**: 通常因为没有上传文件，或者 `level` 参数不在 1-5 的范围内。 - **500 Internal Server Error**: 如果在压缩过程中服务器发生内部错误，会返回此状态码。
         * @summary 无损压缩图片
         * @param {File} file 支持PNG, JPG, JPEG等常见图片格式。文件大小不超过15MB。
         * @param {PostImageCompressLevelEnum} [level] 压缩强度 (1-5)，默认为 3。数字越小，压缩率越高。
         * @param {PostImageCompressFormatEnum} [format] 输出图片格式，可以是 \&#39;png\&#39; 或 \&#39;jpeg\&#39;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postImageCompress(file: File, level?: PostImageCompressLevelEnum, format?: PostImageCompressFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postImageCompress(file, level, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.postImageCompress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 当你需要在前端处理完图片（比如裁剪、加滤镜后），不通过传统表单，而是直接上传图片的场景，这个接口就派上用场了。  ## 功能概述 你只需要将图片的 Base64 编码字符串发送过来，我们就会把它解码、保存为图片文件，并返回一个可供访问的公开 URL。  ## 使用须知  > [!IMPORTANT] > **关于 `imageData` 格式** > 你发送的 `imageData` 字符串必须是完整的 Base64 Data URI 格式，它需要包含 MIME 类型信息，例如 `data:image/png;base64,iVBORw0KGgo...`。缺少 `data:image/...;base64,` 前缀将导致解码失败。
         * @summary 通过Base64编码上传图片
         * @param {PostImageFrombase64Request} postImageFrombase64Request 一个JSON对象，包含 &#x60;imageData&#x60; 字段，其值为你想要上传图片的完整Base64 Data URI。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postImageFrombase64(postImageFrombase64Request: PostImageFrombase64Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostImageFrombase64200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postImageFrombase64(postImageFrombase64Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.postImageFrombase64']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 除了使用QQ头像，你还可以通过上传自己的图片或提供图片URL来制作独一无二的摸摸头GIF。  ## 功能概述 此接口通过POST方法，支持两种方式生成GIF： 1.  **图片URL**：在表单中提供 `image_url` 字段。 2.  **上传图片**：在表单中上传 `file` 文件。  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/gif` 格式的二进制数据。 - **参数优先级**：如果同时提供了 `image_url` 和上传的 `file` 文件，系统将 **优先使用 `image_url`**。 - **背景颜色**：同样支持 `bg_color` 表单字段来控制GIF背景。
         * @summary 生成摸摸头GIF (图片上传或URL方式)
         * @param {string} [imageUrl] 图片的URL地址。如果提供此项，将优先使用该URL的图片。
         * @param {File} [file] 上传的图片文件。支持JPG、PNG、GIF等常见格式。
         * @param {PostImageMotouBgColorEnum} [bgColor] GIF的背景颜色。可选值为 \\\&#39;white\\\&#39;, \\\&#39;black\\\&#39;, \\\&#39;transparent\\\&#39;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postImageMotou(imageUrl?: string, file?: File, bgColor?: PostImageMotouBgColorEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postImageMotou(imageUrl, file, bgColor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.postImageMotou']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 你们怎么不说话了？是不是都在偷偷玩Uapi，求求你们不要玩Uapi了  ## 效果展示 ![示例](https://uapis.cn/static/uploads/33580466897f1e5815296f235b582815.png)  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/jpeg` 格式的二进制数据。 - **文字内容**：至少需要提供 `top_text`（上方文字）或 `bottom_text`（下方文字）之一。 - **梗图逻辑**：上方描述某个行为，下方通常以「们」开头表示劝阻，形成戏谑的对比效果。
         * @summary 生成你们怎么不说话了表情包
         * @param {PostImageSpeechlessRequest} postImageSpeechlessRequest 包含表情包文字内容的JSON对象。至少需要提供上方或下方文字之一。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postImageSpeechless(postImageSpeechlessRequest: PostImageSpeechlessRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postImageSpeechless(postImageSpeechlessRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.postImageSpeechless']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 需要将灵活的 SVG 矢量图形转换为常见的光栅图像格式吗？这个接口可以帮你轻松实现。  ## 功能概述 上传一个 SVG 文件，并指定目标格式（如 PNG、JPEG 等），接口将返回转换后的图像。你还可以调整输出图像的尺寸和（对于JPEG）压缩质量，以满足不同场景的需求。
         * @summary SVG转图片
         * @param {PostImageSvgFormatEnum} [format] 输出图像的目标格式。支持的值：&#x60;png&#x60;, &#x60;jpeg&#x60;, &#x60;jpg&#x60;, &#x60;gif&#x60;, &#x60;tiff&#x60;, &#x60;bmp&#x60;。
         * @param {number} [width] 输出图像的宽度（像素）。如果省略，将根据 &#x60;height&#x60; 保持宽高比，或者使用 SVG 的原始宽度。
         * @param {number} [height] 输出图像的高度（像素）。如果省略，将根据 &#x60;width&#x60; 保持宽高比，或者使用 SVG 的原始高度。
         * @param {number} [quality] JPEG 图像的压缩质量（1-100）。仅当 &#x60;format&#x60; 为 &#x60;jpeg&#x60; 或 &#x60;jpg&#x60; 时有效。
         * @param {File} [file] 支持SVG文件
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postImageSvg(format?: PostImageSvgFormatEnum, width?: number, height?: number, quality?: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postImageSvg(format, width, height, quality, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.postImageSvg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImageApi - factory interface
 */
export const ImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageApiFp(configuration)
    return {
        /**
         * 提供一个超高速、高可用的Gravatar头像代理服务。内置了强大的ETag条件缓存，确保用户在更新Gravatar头像后能几乎立刻看到变化，同时最大化地利用缓存。
         * @summary 获取Gravatar头像
         * @param {string} [email] 用户的 Email 地址。如果未提供 &#x60;hash&#x60; 参数，则此参数为必需。
         * @param {string} [hash] 用户 Email 地址的小写 MD5 哈希值。如果提供此参数，将忽略 &#x60;email&#x60; 参数。
         * @param {number} [s] 头像的尺寸，单位为像素。有效范围是 1 到 2048。
         * @param {string} [d] 当用户没有自己的 Gravatar 头像时，显示的默认头像类型。可选值包括 &#x60;mp&#x60;, &#x60;identicon&#x60;, &#x60;monsterid&#x60;, &#x60;wavatar&#x60;, &#x60;retro&#x60;, &#x60;robohash&#x60;, &#x60;blank&#x60;, &#x60;404&#x60;。
         * @param {string} [r] 头像分级。可选值：&#x60;g&#x60;, &#x60;pg&#x60;, &#x60;r&#x60;, &#x60;x&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvatarGravatar(email?: string, hash?: string, s?: number, d?: string, r?: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getAvatarGravatar(email, hash, s, d, r, options).then((request) => request(axios, basePath));
        },
        /**
         * 每天都想换张新壁纸？让必应的美图点亮你的一天吧！  ## 功能概述 这个接口会获取 Bing 搜索引擎当天全球同步的每日壁纸，并直接以图片形式返回。你可以用它来做应用的启动页、网站背景，或者任何需要每日更新精美图片的地方。  ## 使用须知  > [!NOTE] > **响应格式是图片** > 请注意，此接口成功时直接返回图片二进制数据（通常为 `image/jpeg`），而非 JSON 格式。请确保客户端能够正确处理。  我们内置了备用方案：如果从必应官方获取图片失败，系统会尝试返回一张预存的高质量风景图，以保证服务的稳定性。
         * @summary 获取必应每日壁纸
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageBingDaily(options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getImageBingDaily(options).then((request) => request(axios, basePath));
        },
        /**
         * 想在线rua一下好友的头像吗？这个趣味接口可以满足你。  ## 功能概述 此接口通过GET方法，专门用于通过QQ号生成摸摸头GIF。你只需要提供一个QQ号码，我们就会自动获取其公开头像，并制作成一个可爱的动图。  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/gif` 格式的二进制数据。 - **背景颜色**：你可以通过 `bg_color` 参数来控制GIF的背景。使用 `transparent` 选项可以让它更好地融入各种聊天背景中。
         * @summary 生成摸摸头GIF (QQ号方式)
         * @param {string} qq 你想要摸头的对象的QQ号码。
         * @param {GetImageMotouBgColorEnum} [bgColor] GIF的背景颜色。留空则由后端服务决定默认值。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageMotou(qq: string, bgColor?: GetImageMotouBgColorEnum, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getImageMotou(qq, bgColor, options).then((request) => request(axios, basePath));
        },
        /**
         * 无论是网址、文本还是联系方式，通通可以变成一个二维码！这是一个非常灵活的二维码生成工具。  ## 功能概述 你提供一段文本内容，我们为你生成对应的二维码图片。你可以自定义尺寸，并选择不同的返回格式以适应不同场景。  ## 使用须知  > [!IMPORTANT] > **关键参数 `format`** > 此参数决定了成功响应的内容类型和结构，请务必根据你的需求选择并正确处理响应： > - **`image`** (默认): 直接返回 `image/png` 格式的图片二进制数据，适合在 `<img>` 标签中直接使用。 > - **`json`**: 返回一个包含 Base64 Data URI 的 JSON 对象，适合需要在前端直接嵌入CSS或HTML的场景。 > - **`json_url`**: 返回一个包含图片临时URL的JSON对象，适合需要图片链接的场景。
         * @summary 动态生成二维码
         * @param {string} text 你希望编码到二维码中的任何文本内容，比如一个URL、一段话或者一个JSON字符串。
         * @param {number} [size] 二维码图片的边长（正方形），单位是像素。有效范围是 256 到 1024 之间。
         * @param {GetImageQrcodeFormatEnum} [format] 指定响应内容的格式。可选值为 &#x60;image&#x60;, &#x60;json&#x60;, &#x60;json_url&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageQrcode(text: string, size?: number, format?: GetImageQrcodeFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getImageQrcode(text, size, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 看到一张网上的图片，想把它转换成 Base64 编码以便嵌入到你的 HTML 或 CSS 中？用这个接口就对了。  ## 功能概述 你提供一个公开可访问的图片 URL，我们帮你把它下载下来，并转换成包含 MIME 类型的 Base64 Data URI 字符串返回给你。
         * @summary 将在线图片转换为Base64
         * @param {string} url 需要转换为Base64的、可公开访问的图片URL地址。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageTobase64(url: string, options?: RawAxiosRequestConfig): AxiosPromise<GetImageTobase64200Response> {
            return localVarFp.getImageTobase64(url, options).then((request) => request(axios, basePath));
        },
        /**
         * 还在为图片体积和加载速度发愁吗？体验一下我们强大的**无损压缩服务**，它能在几乎不牺牲任何肉眼可感知的画质的前提下，将图片体积压缩到极致。  ## 功能概述 你只需要上传一张常见的图片（如 PNG, JPG），选择一个压缩等级，就能获得一个体积小到惊人的压缩文件。这对于需要大量展示高清图片的网站、App 或小程序来说，是优化用户体验、节省带宽和存储成本的利器。  ## 使用须知 > [!TIP] > 为了给您最好的压缩效果，我们的算法需要进行复杂计算，处理时间可能会稍长一些，请耐心等待。  > [!WARNING] > **服务排队提醒** > 这是一个计算密集型服务。在高并发时，您的请求可能会被排队等待处理。如果您需要将其集成到对延迟敏感的生产服务中，请注意这一点。  ### 请求与响应格式 - 请求必须使用 `multipart/form-data` 格式上传文件。 - 成功响应将直接返回压缩后的文件二进制流 (`application/octet-stream`)，并附带 `Content-Disposition` 头，建议客户端根据此头信息保存文件。  ## 参数详解 ### `level` (压缩等级) 这是一个从 `1` 到 `5` 的整数，它决定了压缩的强度和策略，数字越小，压缩率越高。所有等级都经过精心调校，以在最大化压缩率的同时保证出色的视觉质量。 - `1`: **极限压缩** (推荐，体积最小，画质优异) - `2`: **高效压缩** - `3`: **智能均衡** (默认选项) - `4`: **画质优先** - `5`: **专业保真** (压缩率稍低，保留最多图像信息)  ## 错误处理指南 - **400 Bad Request**: 通常因为没有上传文件，或者 `level` 参数不在 1-5 的范围内。 - **500 Internal Server Error**: 如果在压缩过程中服务器发生内部错误，会返回此状态码。
         * @summary 无损压缩图片
         * @param {File} file 支持PNG, JPG, JPEG等常见图片格式。文件大小不超过15MB。
         * @param {PostImageCompressLevelEnum} [level] 压缩强度 (1-5)，默认为 3。数字越小，压缩率越高。
         * @param {PostImageCompressFormatEnum} [format] 输出图片格式，可以是 \&#39;png\&#39; 或 \&#39;jpeg\&#39;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImageCompress(file: File, level?: PostImageCompressLevelEnum, format?: PostImageCompressFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.postImageCompress(file, level, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 当你需要在前端处理完图片（比如裁剪、加滤镜后），不通过传统表单，而是直接上传图片的场景，这个接口就派上用场了。  ## 功能概述 你只需要将图片的 Base64 编码字符串发送过来，我们就会把它解码、保存为图片文件，并返回一个可供访问的公开 URL。  ## 使用须知  > [!IMPORTANT] > **关于 `imageData` 格式** > 你发送的 `imageData` 字符串必须是完整的 Base64 Data URI 格式，它需要包含 MIME 类型信息，例如 `data:image/png;base64,iVBORw0KGgo...`。缺少 `data:image/...;base64,` 前缀将导致解码失败。
         * @summary 通过Base64编码上传图片
         * @param {PostImageFrombase64Request} postImageFrombase64Request 一个JSON对象，包含 &#x60;imageData&#x60; 字段，其值为你想要上传图片的完整Base64 Data URI。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImageFrombase64(postImageFrombase64Request: PostImageFrombase64Request, options?: RawAxiosRequestConfig): AxiosPromise<PostImageFrombase64200Response> {
            return localVarFp.postImageFrombase64(postImageFrombase64Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 除了使用QQ头像，你还可以通过上传自己的图片或提供图片URL来制作独一无二的摸摸头GIF。  ## 功能概述 此接口通过POST方法，支持两种方式生成GIF： 1.  **图片URL**：在表单中提供 `image_url` 字段。 2.  **上传图片**：在表单中上传 `file` 文件。  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/gif` 格式的二进制数据。 - **参数优先级**：如果同时提供了 `image_url` 和上传的 `file` 文件，系统将 **优先使用 `image_url`**。 - **背景颜色**：同样支持 `bg_color` 表单字段来控制GIF背景。
         * @summary 生成摸摸头GIF (图片上传或URL方式)
         * @param {string} [imageUrl] 图片的URL地址。如果提供此项，将优先使用该URL的图片。
         * @param {File} [file] 上传的图片文件。支持JPG、PNG、GIF等常见格式。
         * @param {PostImageMotouBgColorEnum} [bgColor] GIF的背景颜色。可选值为 \\\&#39;white\\\&#39;, \\\&#39;black\\\&#39;, \\\&#39;transparent\\\&#39;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImageMotou(imageUrl?: string, file?: File, bgColor?: PostImageMotouBgColorEnum, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.postImageMotou(imageUrl, file, bgColor, options).then((request) => request(axios, basePath));
        },
        /**
         * 你们怎么不说话了？是不是都在偷偷玩Uapi，求求你们不要玩Uapi了  ## 效果展示 ![示例](https://uapis.cn/static/uploads/33580466897f1e5815296f235b582815.png)  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/jpeg` 格式的二进制数据。 - **文字内容**：至少需要提供 `top_text`（上方文字）或 `bottom_text`（下方文字）之一。 - **梗图逻辑**：上方描述某个行为，下方通常以「们」开头表示劝阻，形成戏谑的对比效果。
         * @summary 生成你们怎么不说话了表情包
         * @param {PostImageSpeechlessRequest} postImageSpeechlessRequest 包含表情包文字内容的JSON对象。至少需要提供上方或下方文字之一。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImageSpeechless(postImageSpeechlessRequest: PostImageSpeechlessRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.postImageSpeechless(postImageSpeechlessRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 需要将灵活的 SVG 矢量图形转换为常见的光栅图像格式吗？这个接口可以帮你轻松实现。  ## 功能概述 上传一个 SVG 文件，并指定目标格式（如 PNG、JPEG 等），接口将返回转换后的图像。你还可以调整输出图像的尺寸和（对于JPEG）压缩质量，以满足不同场景的需求。
         * @summary SVG转图片
         * @param {PostImageSvgFormatEnum} [format] 输出图像的目标格式。支持的值：&#x60;png&#x60;, &#x60;jpeg&#x60;, &#x60;jpg&#x60;, &#x60;gif&#x60;, &#x60;tiff&#x60;, &#x60;bmp&#x60;。
         * @param {number} [width] 输出图像的宽度（像素）。如果省略，将根据 &#x60;height&#x60; 保持宽高比，或者使用 SVG 的原始宽度。
         * @param {number} [height] 输出图像的高度（像素）。如果省略，将根据 &#x60;width&#x60; 保持宽高比，或者使用 SVG 的原始高度。
         * @param {number} [quality] JPEG 图像的压缩质量（1-100）。仅当 &#x60;format&#x60; 为 &#x60;jpeg&#x60; 或 &#x60;jpg&#x60; 时有效。
         * @param {File} [file] 支持SVG文件
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImageSvg(format?: PostImageSvgFormatEnum, width?: number, height?: number, quality?: number, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.postImageSvg(format, width, height, quality, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageApi - object-oriented interface
 */
export class ImageApi extends BaseAPI {
    /**
     * 提供一个超高速、高可用的Gravatar头像代理服务。内置了强大的ETag条件缓存，确保用户在更新Gravatar头像后能几乎立刻看到变化，同时最大化地利用缓存。
     * @summary 获取Gravatar头像
     * @param {string} [email] 用户的 Email 地址。如果未提供 &#x60;hash&#x60; 参数，则此参数为必需。
     * @param {string} [hash] 用户 Email 地址的小写 MD5 哈希值。如果提供此参数，将忽略 &#x60;email&#x60; 参数。
     * @param {number} [s] 头像的尺寸，单位为像素。有效范围是 1 到 2048。
     * @param {string} [d] 当用户没有自己的 Gravatar 头像时，显示的默认头像类型。可选值包括 &#x60;mp&#x60;, &#x60;identicon&#x60;, &#x60;monsterid&#x60;, &#x60;wavatar&#x60;, &#x60;retro&#x60;, &#x60;robohash&#x60;, &#x60;blank&#x60;, &#x60;404&#x60;。
     * @param {string} [r] 头像分级。可选值：&#x60;g&#x60;, &#x60;pg&#x60;, &#x60;r&#x60;, &#x60;x&#x60;。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAvatarGravatar(email?: string, hash?: string, s?: number, d?: string, r?: string, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getAvatarGravatar(email, hash, s, d, r, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 每天都想换张新壁纸？让必应的美图点亮你的一天吧！  ## 功能概述 这个接口会获取 Bing 搜索引擎当天全球同步的每日壁纸，并直接以图片形式返回。你可以用它来做应用的启动页、网站背景，或者任何需要每日更新精美图片的地方。  ## 使用须知  > [!NOTE] > **响应格式是图片** > 请注意，此接口成功时直接返回图片二进制数据（通常为 `image/jpeg`），而非 JSON 格式。请确保客户端能够正确处理。  我们内置了备用方案：如果从必应官方获取图片失败，系统会尝试返回一张预存的高质量风景图，以保证服务的稳定性。
     * @summary 获取必应每日壁纸
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getImageBingDaily(options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getImageBingDaily(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想在线rua一下好友的头像吗？这个趣味接口可以满足你。  ## 功能概述 此接口通过GET方法，专门用于通过QQ号生成摸摸头GIF。你只需要提供一个QQ号码，我们就会自动获取其公开头像，并制作成一个可爱的动图。  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/gif` 格式的二进制数据。 - **背景颜色**：你可以通过 `bg_color` 参数来控制GIF的背景。使用 `transparent` 选项可以让它更好地融入各种聊天背景中。
     * @summary 生成摸摸头GIF (QQ号方式)
     * @param {string} qq 你想要摸头的对象的QQ号码。
     * @param {GetImageMotouBgColorEnum} [bgColor] GIF的背景颜色。留空则由后端服务决定默认值。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getImageMotou(qq: string, bgColor?: GetImageMotouBgColorEnum, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getImageMotou(qq, bgColor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 无论是网址、文本还是联系方式，通通可以变成一个二维码！这是一个非常灵活的二维码生成工具。  ## 功能概述 你提供一段文本内容，我们为你生成对应的二维码图片。你可以自定义尺寸，并选择不同的返回格式以适应不同场景。  ## 使用须知  > [!IMPORTANT] > **关键参数 `format`** > 此参数决定了成功响应的内容类型和结构，请务必根据你的需求选择并正确处理响应： > - **`image`** (默认): 直接返回 `image/png` 格式的图片二进制数据，适合在 `<img>` 标签中直接使用。 > - **`json`**: 返回一个包含 Base64 Data URI 的 JSON 对象，适合需要在前端直接嵌入CSS或HTML的场景。 > - **`json_url`**: 返回一个包含图片临时URL的JSON对象，适合需要图片链接的场景。
     * @summary 动态生成二维码
     * @param {string} text 你希望编码到二维码中的任何文本内容，比如一个URL、一段话或者一个JSON字符串。
     * @param {number} [size] 二维码图片的边长（正方形），单位是像素。有效范围是 256 到 1024 之间。
     * @param {GetImageQrcodeFormatEnum} [format] 指定响应内容的格式。可选值为 &#x60;image&#x60;, &#x60;json&#x60;, &#x60;json_url&#x60;。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getImageQrcode(text: string, size?: number, format?: GetImageQrcodeFormatEnum, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getImageQrcode(text, size, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 看到一张网上的图片，想把它转换成 Base64 编码以便嵌入到你的 HTML 或 CSS 中？用这个接口就对了。  ## 功能概述 你提供一个公开可访问的图片 URL，我们帮你把它下载下来，并转换成包含 MIME 类型的 Base64 Data URI 字符串返回给你。
     * @summary 将在线图片转换为Base64
     * @param {string} url 需要转换为Base64的、可公开访问的图片URL地址。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getImageTobase64(url: string, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getImageTobase64(url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 还在为图片体积和加载速度发愁吗？体验一下我们强大的**无损压缩服务**，它能在几乎不牺牲任何肉眼可感知的画质的前提下，将图片体积压缩到极致。  ## 功能概述 你只需要上传一张常见的图片（如 PNG, JPG），选择一个压缩等级，就能获得一个体积小到惊人的压缩文件。这对于需要大量展示高清图片的网站、App 或小程序来说，是优化用户体验、节省带宽和存储成本的利器。  ## 使用须知 > [!TIP] > 为了给您最好的压缩效果，我们的算法需要进行复杂计算，处理时间可能会稍长一些，请耐心等待。  > [!WARNING] > **服务排队提醒** > 这是一个计算密集型服务。在高并发时，您的请求可能会被排队等待处理。如果您需要将其集成到对延迟敏感的生产服务中，请注意这一点。  ### 请求与响应格式 - 请求必须使用 `multipart/form-data` 格式上传文件。 - 成功响应将直接返回压缩后的文件二进制流 (`application/octet-stream`)，并附带 `Content-Disposition` 头，建议客户端根据此头信息保存文件。  ## 参数详解 ### `level` (压缩等级) 这是一个从 `1` 到 `5` 的整数，它决定了压缩的强度和策略，数字越小，压缩率越高。所有等级都经过精心调校，以在最大化压缩率的同时保证出色的视觉质量。 - `1`: **极限压缩** (推荐，体积最小，画质优异) - `2`: **高效压缩** - `3`: **智能均衡** (默认选项) - `4`: **画质优先** - `5`: **专业保真** (压缩率稍低，保留最多图像信息)  ## 错误处理指南 - **400 Bad Request**: 通常因为没有上传文件，或者 `level` 参数不在 1-5 的范围内。 - **500 Internal Server Error**: 如果在压缩过程中服务器发生内部错误，会返回此状态码。
     * @summary 无损压缩图片
     * @param {File} file 支持PNG, JPG, JPEG等常见图片格式。文件大小不超过15MB。
     * @param {PostImageCompressLevelEnum} [level] 压缩强度 (1-5)，默认为 3。数字越小，压缩率越高。
     * @param {PostImageCompressFormatEnum} [format] 输出图片格式，可以是 \&#39;png\&#39; 或 \&#39;jpeg\&#39;。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postImageCompress(file: File, level?: PostImageCompressLevelEnum, format?: PostImageCompressFormatEnum, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).postImageCompress(file, level, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 当你需要在前端处理完图片（比如裁剪、加滤镜后），不通过传统表单，而是直接上传图片的场景，这个接口就派上用场了。  ## 功能概述 你只需要将图片的 Base64 编码字符串发送过来，我们就会把它解码、保存为图片文件，并返回一个可供访问的公开 URL。  ## 使用须知  > [!IMPORTANT] > **关于 `imageData` 格式** > 你发送的 `imageData` 字符串必须是完整的 Base64 Data URI 格式，它需要包含 MIME 类型信息，例如 `data:image/png;base64,iVBORw0KGgo...`。缺少 `data:image/...;base64,` 前缀将导致解码失败。
     * @summary 通过Base64编码上传图片
     * @param {PostImageFrombase64Request} postImageFrombase64Request 一个JSON对象，包含 &#x60;imageData&#x60; 字段，其值为你想要上传图片的完整Base64 Data URI。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postImageFrombase64(postImageFrombase64Request: PostImageFrombase64Request, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).postImageFrombase64(postImageFrombase64Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 除了使用QQ头像，你还可以通过上传自己的图片或提供图片URL来制作独一无二的摸摸头GIF。  ## 功能概述 此接口通过POST方法，支持两种方式生成GIF： 1.  **图片URL**：在表单中提供 `image_url` 字段。 2.  **上传图片**：在表单中上传 `file` 文件。  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/gif` 格式的二进制数据。 - **参数优先级**：如果同时提供了 `image_url` 和上传的 `file` 文件，系统将 **优先使用 `image_url`**。 - **背景颜色**：同样支持 `bg_color` 表单字段来控制GIF背景。
     * @summary 生成摸摸头GIF (图片上传或URL方式)
     * @param {string} [imageUrl] 图片的URL地址。如果提供此项，将优先使用该URL的图片。
     * @param {File} [file] 上传的图片文件。支持JPG、PNG、GIF等常见格式。
     * @param {PostImageMotouBgColorEnum} [bgColor] GIF的背景颜色。可选值为 \\\&#39;white\\\&#39;, \\\&#39;black\\\&#39;, \\\&#39;transparent\\\&#39;。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postImageMotou(imageUrl?: string, file?: File, bgColor?: PostImageMotouBgColorEnum, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).postImageMotou(imageUrl, file, bgColor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 你们怎么不说话了？是不是都在偷偷玩Uapi，求求你们不要玩Uapi了  ## 效果展示 ![示例](https://uapis.cn/static/uploads/33580466897f1e5815296f235b582815.png)  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/jpeg` 格式的二进制数据。 - **文字内容**：至少需要提供 `top_text`（上方文字）或 `bottom_text`（下方文字）之一。 - **梗图逻辑**：上方描述某个行为，下方通常以「们」开头表示劝阻，形成戏谑的对比效果。
     * @summary 生成你们怎么不说话了表情包
     * @param {PostImageSpeechlessRequest} postImageSpeechlessRequest 包含表情包文字内容的JSON对象。至少需要提供上方或下方文字之一。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postImageSpeechless(postImageSpeechlessRequest: PostImageSpeechlessRequest, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).postImageSpeechless(postImageSpeechlessRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 需要将灵活的 SVG 矢量图形转换为常见的光栅图像格式吗？这个接口可以帮你轻松实现。  ## 功能概述 上传一个 SVG 文件，并指定目标格式（如 PNG、JPEG 等），接口将返回转换后的图像。你还可以调整输出图像的尺寸和（对于JPEG）压缩质量，以满足不同场景的需求。
     * @summary SVG转图片
     * @param {PostImageSvgFormatEnum} [format] 输出图像的目标格式。支持的值：&#x60;png&#x60;, &#x60;jpeg&#x60;, &#x60;jpg&#x60;, &#x60;gif&#x60;, &#x60;tiff&#x60;, &#x60;bmp&#x60;。
     * @param {number} [width] 输出图像的宽度（像素）。如果省略，将根据 &#x60;height&#x60; 保持宽高比，或者使用 SVG 的原始宽度。
     * @param {number} [height] 输出图像的高度（像素）。如果省略，将根据 &#x60;width&#x60; 保持宽高比，或者使用 SVG 的原始高度。
     * @param {number} [quality] JPEG 图像的压缩质量（1-100）。仅当 &#x60;format&#x60; 为 &#x60;jpeg&#x60; 或 &#x60;jpg&#x60; 时有效。
     * @param {File} [file] 支持SVG文件
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postImageSvg(format?: PostImageSvgFormatEnum, width?: number, height?: number, quality?: number, file?: File, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).postImageSvg(format, width, height, quality, file, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetImageMotouBgColorEnum = {
    White: 'white',
    Black: 'black',
    Transparent: 'transparent'
} as const;
export type GetImageMotouBgColorEnum = typeof GetImageMotouBgColorEnum[keyof typeof GetImageMotouBgColorEnum];
export const GetImageQrcodeFormatEnum = {
    Image: 'image',
    Json: 'json',
    JsonUrl: 'json_url'
} as const;
export type GetImageQrcodeFormatEnum = typeof GetImageQrcodeFormatEnum[keyof typeof GetImageQrcodeFormatEnum];
export const PostImageCompressLevelEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5
} as const;
export type PostImageCompressLevelEnum = typeof PostImageCompressLevelEnum[keyof typeof PostImageCompressLevelEnum];
export const PostImageCompressFormatEnum = {
    Png: 'png',
    Jpeg: 'jpeg'
} as const;
export type PostImageCompressFormatEnum = typeof PostImageCompressFormatEnum[keyof typeof PostImageCompressFormatEnum];
export const PostImageMotouBgColorEnum = {
    White: 'white',
    Black: 'black',
    Transparent: 'transparent'
} as const;
export type PostImageMotouBgColorEnum = typeof PostImageMotouBgColorEnum[keyof typeof PostImageMotouBgColorEnum];
export const PostImageSvgFormatEnum = {
    Png: 'png',
    Jpeg: 'jpeg',
    Jpg: 'jpg',
    Gif: 'gif',
    Tiff: 'tiff',
    Bmp: 'bmp'
} as const;
export type PostImageSvgFormatEnum = typeof PostImageSvgFormatEnum[keyof typeof PostImageSvgFormatEnum];


/**
 * MiscApi - axios parameter creator
 */
export const MiscApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 想查看程序员历史上某个特定日期发生的大事件？指定月份和日期，我们就能告诉你！  ## 功能概述 通过指定月份和日期，获取该日发生的程序员相关历史事件。同样使用AI智能筛选，确保事件的相关性和重要性。
         * @summary 获取指定日期的程序员历史事件
         * @param {number} month 月份，1-12之间的整数。
         * @param {number} day 日期，1-31之间的整数。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoryProgrammer: async (month: number, day: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'month' is not null or undefined
            assertParamExists('getHistoryProgrammer', 'month', month)
            // verify required parameter 'day' is not null or undefined
            assertParamExists('getHistoryProgrammer', 'day', day)
            const localVarPath = `/history/programmer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (day !== undefined) {
                localVarQueryParameter['day'] = day;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想知道程序员历史上的今天发生了什么大事吗？这个接口告诉你答案！  ## 功能概述 我们使用AI智能筛选从海量历史事件中挑选出与程序员、计算机科学相关的重要事件。每个事件都经过重要性评分和相关性评分，确保内容质量。
         * @summary 获取今天的程序员历史事件
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoryProgrammerToday: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/history/programmer/today`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想快速跟上网络热点？这个接口让你一网打尽各大主流平台的实时热榜/热搜！  ## 功能概述 你只需要指定一个平台类型，就能获取到该平台当前的热榜数据列表。每个热榜条目都包含标题、热度值和原始链接。非常适合用于制作信息聚合类应用或看板。  ## 可选值 `type` 参数接受多种不同的值，每种值对应一个不同的热榜来源。以下是目前支持的所有值：  | 分类       | 支持的 type 值 | |------------|-----------------------------------------------------------------------------------------------------------------------------------| | 视频/社区  | bilibili（哔哩哔哩弹幕网）, acfun（A站弹幕视频网站）, weibo（新浪微博热搜）, zhihu（知乎热榜）, zhihu-daily（知乎日报热榜）, douyin（抖音热榜）, kuaishou（快手热榜）, douban-movie（豆瓣电影榜单）, douban-group（豆瓣小组话题）, tieba（百度贴吧热帖）, hupu（虎扑热帖）, miyoushe（米游社话题榜）, ngabbs（NGA游戏论坛热帖）, v2ex（V2EX技术社区热帖）, 52pojie（吾爱破解热帖）, hostloc（全球主机交流论坛）, coolapk（酷安热榜） | | 新闻/资讯  | baidu（百度热搜）, thepaper（澎湃新闻热榜）, toutiao（今日头条热榜）, qq-news（腾讯新闻热榜）, sina（新浪热搜）, sina-news（新浪新闻热榜）, netease-news（网易新闻热榜）, huxiu（虎嗅网热榜）, ifanr（爱范儿热榜） | | 技术/IT    | sspai（少数派热榜）, ithome（IT之家热榜）, ithome-xijiayi（IT之家·喜加一栏目）, juejin（掘金社区热榜）, jianshu（简书热榜）, guokr（果壳热榜）, 36kr（36氪热榜）, 51cto（51CTO热榜）, csdn（CSDN博客热榜）, nodeseek（NodeSeek 技术社区）, hellogithub（HelloGitHub 项目推荐） | | 游戏       | lol（英雄联盟热帖）, genshin（原神热榜）, honkai（崩坏3热榜）, starrail（星穹铁道热榜） | | 其他       | weread（微信读书热门书籍）, weatheralarm（天气预警信息）, earthquake（地震速报）, history（历史上的今天） | 
         * @summary 获取多平台实时热榜
         * @param {GetMiscHotboardTypeEnum} type 你想要查询的热榜平台。支持多种主流平台类型，详见下方[可选值](#可选值)表格。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscHotboard: async (type: GetMiscHotboardTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getMiscHotboard', 'type', type)
            const localVarPath = `/misc/hotboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想知道一个手机号码来自哪里？是移动、联通还是电信？这个接口可以告诉你答案。  ## 功能概述 提供一个国内的手机号码，我们会查询并返回它的归属地（省份和城市）以及所属的运营商信息。
         * @summary 查询手机号码归属地信息
         * @param {string} phone 需要查询的11位中国大陆手机号码。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscPhoneinfo: async (phone: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'phone' is not null or undefined
            assertParamExists('getMiscPhoneinfo', 'phone', phone)
            const localVarPath = `/misc/phoneinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (phone !== undefined) {
                localVarQueryParameter['phone'] = phone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 需要一个简单的随机数，还是需要一串不重复的、带小数的随机数？这个接口都能满足你！  ## 功能概述 这是一个强大的随机数生成器。你可以指定生成的范围（最大/最小值）、数量、是否允许重复、以及是否生成小数（并指定小数位数）。  ## 流程图 ```mermaid graph TD     A[开始] --> B{参数校验};     B --> |通过| C{是否允许小数?};     C --> |是| D[生成随机小数];     C --> |否| E[生成随机整数];     D --> F{是否允许重复?};     E --> F;     F --> |是| G[直接生成指定数量];     F --> |否| H[生成不重复的数字];     G --> I[返回结果];     H --> I;     B --> |失败| J[返回 400 错误]; ``` ## 使用须知 > [!WARNING] > **不重复生成的逻辑限制** > 当设置 `allow_repeat=false` 时，请确保取值范围 `(max - min + 1)` 大于或等于你请求的数量 `count`。否则，系统将无法生成足够的不重复数字，请求会失败并返回 400 错误。
         * @summary 生成高度可定制的随机数
         * @param {number} [min] 生成随机数的最小值（包含）。
         * @param {number} [max] 生成随机数的最大值（包含）。
         * @param {number} [count] 需要生成的随机数的数量。
         * @param {boolean} [allowRepeat] 是否允许生成的多个数字中出现重复值。
         * @param {boolean} [allowDecimal] 是否生成小（浮点）数。如果为 false，则只生成整数。
         * @param {number} [decimalPlaces] 如果 &#x60;allow_decimal&#x3D;true&#x60;，这里可以指定小数的位数。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscRandomnumber: async (min?: number, max?: number, count?: number, allowRepeat?: boolean, allowDecimal?: boolean, decimalPlaces?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/misc/randomnumber`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (allowRepeat !== undefined) {
                localVarQueryParameter['allow_repeat'] = allowRepeat;
            }

            if (allowDecimal !== undefined) {
                localVarQueryParameter['allow_decimal'] = allowDecimal;
            }

            if (decimalPlaces !== undefined) {
                localVarQueryParameter['decimal_places'] = decimalPlaces;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 这是一个用于将Unix时间戳转换为人类可读日期时间的旧版接口。  ## 功能概述 输入一个秒级或毫秒级的时间戳，返回其对应的本地时间和UTC时间。  > [!WARNING] > **接口已过时**：这个接口已被新的 `/convert/unixtime` 取代。新接口功能更强大，支持双向转换。我们建议你迁移到新接口。  [👉 前往新版接口文档](/docs/api-reference/get-convert-unixtime)
         * @summary 转换时间戳 (旧版，推荐使用/convert/unixtime)
         * @param {string} ts 需要转换的Unix时间戳，支持10位（秒）或13位（毫秒）。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscTimestamp: async (ts: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ts' is not null or undefined
            assertParamExists('getMiscTimestamp', 'ts', ts)
            const localVarPath = `/misc/timestamp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 不确定系统支持哪些快递公司？这个接口返回完整的支持列表。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 获取系统当前支持的所有快递公司列表，包括每家公司的标准编码（code）和中文名称（name）。  ## 使用建议 - **推荐缓存**：这个列表基本不会频繁变动，建议在应用启动时调用一次并缓存到本地 - **应用场景**：适合用于构建快递公司选择器、下拉菜单等UI组件 - **缓存时长**：建议缓存24小时或更久
         * @summary 获取支持的快递公司列表
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscTrackingCarriers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/misc/tracking/carriers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 不确定手里的快递单号属于哪家快递公司？这个接口专门做识别，不查物流。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 输入快递单号，系统会根据单号规则快速识别出最可能的快递公司。如果存在多个可能的匹配结果，还会在 `alternatives` 字段中返回备选项，供你参考选择。  ## 使用须知 - **识别速度快**：只做规则匹配，不查询物流信息，响应速度通常在100ms内 - **准确率高**：基于各快递公司的单号规则进行智能识别，准确率超过95% - **备选方案**：当单号规则可能匹配多家快递公司时，会提供所有可能的选项
         * @summary 识别快递公司
         * @param {string} trackingNumber 需要识别的快递单号。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscTrackingDetect: async (trackingNumber: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingNumber' is not null or undefined
            assertParamExists('getMiscTrackingDetect', 'trackingNumber', trackingNumber)
            const localVarPath = `/misc/tracking/detect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 买了东西想知道快递到哪儿了？这个接口帮你实时追踪物流状态。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 提供一个快递单号，系统会自动识别快递公司并返回完整的物流轨迹信息。支持中通、圆通、韵达、申通、极兔、顺丰、京东、EMS、德邦等60+国内外主流快递公司。  ## 使用须知 - **自动识别**：不知道是哪家快递？系统会根据单号规则自动识别快递公司（推荐使用） - **手动指定**：如果已知快递公司，可以传递 `carrier_code` 参数，查询速度会更快 - **查询时效**：物流信息实时查询，响应时间通常在1-2秒内
         * @summary 查询快递物流信息
         * @param {string} trackingNumber 快递单号，通常是一串10-20位的数字或字母数字组合。
         * @param {string} [carrierCode] 快递公司编码（可选）。不填写时系统会自动识别，填写后可加快查询速度。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscTrackingQuery: async (trackingNumber: string, carrierCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingNumber' is not null or undefined
            assertParamExists('getMiscTrackingQuery', 'trackingNumber', trackingNumber)
            const localVarPath = `/misc/tracking/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }

            if (carrierCode !== undefined) {
                localVarQueryParameter['carrier_code'] = carrierCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 出门前，查一下天气总是个好习惯。这个接口为你提供精准、实时的天气数据。  ## 功能概述 你可以通过城市名称或高德地图的Adcode来查询指定地区的实时天气状况，包括天气现象、温度、湿度、风向和风力等。  ## 使用须知 - **参数优先级**：当你同时提供了 `city` (城市名) 和 `adcode` (城市编码) 两个参数时，系统会 **优先使用 `adcode`** 进行查询，因为它更精确。 - **查询范围**：为了保证查询的准确性，我们的服务仅支持标准的“省”、“市”、“区/县”级别的行政区划名称查询，不保证能查询到乡镇或具体地点。  ## 错误处理指南 - **410 Gone**: 这个特殊的错误码意味着你查询的地区无效或不受我们支持。比如你输入了“火星”，或者某个我们无法识别的村庄名称。这个状态码告诉你，这个“资源”是永久性地不可用了。
         * @summary 查询实时天气信息
         * @param {string} [city] 标准的城市名称，如 \&#39;北京\&#39;, \&#39;上海市\&#39;, \&#39;福田区\&#39;。请使用官方的省、市、区县行政区划名称。
         * @param {string} [adcode] 高德地图的6位数字城市编码。例如，北京市的Adcode是 \&#39;110000\&#39;。使用Adcode查询更准确、更快速。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscWeather: async (city?: string, adcode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/misc/weather`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (adcode !== undefined) {
                localVarQueryParameter['adcode'] = adcode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 需要和国外的朋友开会，想知道他那边现在几点？用这个接口一查便知。  ## 功能概述 根据标准的时区名称（例如 \'Asia/Shanghai\' 或 \'Europe/London\'），获取该时区的当前准确时间、UTC偏移量、星期等信息。
         * @summary 查询全球任意时区的时间
         * @param {string} city 你需要查询的城市或地区，请使用标准的 IANA 时区数据库名称，例如 \&#39;Shanghai\&#39;, \&#39;Asia/Tokyo\&#39;, \&#39;America/New_York\&#39;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscWorldtime: async (city: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'city' is not null or undefined
            assertParamExists('getMiscWorldtime', 'city', city)
            const localVarPath = `/misc/worldtime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscApi - functional programming interface
 */
export const MiscApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiscApiAxiosParamCreator(configuration)
    return {
        /**
         * 想查看程序员历史上某个特定日期发生的大事件？指定月份和日期，我们就能告诉你！  ## 功能概述 通过指定月份和日期，获取该日发生的程序员相关历史事件。同样使用AI智能筛选，确保事件的相关性和重要性。
         * @summary 获取指定日期的程序员历史事件
         * @param {number} month 月份，1-12之间的整数。
         * @param {number} day 日期，1-31之间的整数。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoryProgrammer(month: number, day: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHistoryProgrammer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoryProgrammer(month, day, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.getHistoryProgrammer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想知道程序员历史上的今天发生了什么大事吗？这个接口告诉你答案！  ## 功能概述 我们使用AI智能筛选从海量历史事件中挑选出与程序员、计算机科学相关的重要事件。每个事件都经过重要性评分和相关性评分，确保内容质量。
         * @summary 获取今天的程序员历史事件
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoryProgrammerToday(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHistoryProgrammerToday200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoryProgrammerToday(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.getHistoryProgrammerToday']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想快速跟上网络热点？这个接口让你一网打尽各大主流平台的实时热榜/热搜！  ## 功能概述 你只需要指定一个平台类型，就能获取到该平台当前的热榜数据列表。每个热榜条目都包含标题、热度值和原始链接。非常适合用于制作信息聚合类应用或看板。  ## 可选值 `type` 参数接受多种不同的值，每种值对应一个不同的热榜来源。以下是目前支持的所有值：  | 分类       | 支持的 type 值 | |------------|-----------------------------------------------------------------------------------------------------------------------------------| | 视频/社区  | bilibili（哔哩哔哩弹幕网）, acfun（A站弹幕视频网站）, weibo（新浪微博热搜）, zhihu（知乎热榜）, zhihu-daily（知乎日报热榜）, douyin（抖音热榜）, kuaishou（快手热榜）, douban-movie（豆瓣电影榜单）, douban-group（豆瓣小组话题）, tieba（百度贴吧热帖）, hupu（虎扑热帖）, miyoushe（米游社话题榜）, ngabbs（NGA游戏论坛热帖）, v2ex（V2EX技术社区热帖）, 52pojie（吾爱破解热帖）, hostloc（全球主机交流论坛）, coolapk（酷安热榜） | | 新闻/资讯  | baidu（百度热搜）, thepaper（澎湃新闻热榜）, toutiao（今日头条热榜）, qq-news（腾讯新闻热榜）, sina（新浪热搜）, sina-news（新浪新闻热榜）, netease-news（网易新闻热榜）, huxiu（虎嗅网热榜）, ifanr（爱范儿热榜） | | 技术/IT    | sspai（少数派热榜）, ithome（IT之家热榜）, ithome-xijiayi（IT之家·喜加一栏目）, juejin（掘金社区热榜）, jianshu（简书热榜）, guokr（果壳热榜）, 36kr（36氪热榜）, 51cto（51CTO热榜）, csdn（CSDN博客热榜）, nodeseek（NodeSeek 技术社区）, hellogithub（HelloGitHub 项目推荐） | | 游戏       | lol（英雄联盟热帖）, genshin（原神热榜）, honkai（崩坏3热榜）, starrail（星穹铁道热榜） | | 其他       | weread（微信读书热门书籍）, weatheralarm（天气预警信息）, earthquake（地震速报）, history（历史上的今天） | 
         * @summary 获取多平台实时热榜
         * @param {GetMiscHotboardTypeEnum} type 你想要查询的热榜平台。支持多种主流平台类型，详见下方[可选值](#可选值)表格。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiscHotboard(type: GetMiscHotboardTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiscHotboard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiscHotboard(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.getMiscHotboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想知道一个手机号码来自哪里？是移动、联通还是电信？这个接口可以告诉你答案。  ## 功能概述 提供一个国内的手机号码，我们会查询并返回它的归属地（省份和城市）以及所属的运营商信息。
         * @summary 查询手机号码归属地信息
         * @param {string} phone 需要查询的11位中国大陆手机号码。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiscPhoneinfo(phone: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiscPhoneinfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiscPhoneinfo(phone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.getMiscPhoneinfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 需要一个简单的随机数，还是需要一串不重复的、带小数的随机数？这个接口都能满足你！  ## 功能概述 这是一个强大的随机数生成器。你可以指定生成的范围（最大/最小值）、数量、是否允许重复、以及是否生成小数（并指定小数位数）。  ## 流程图 ```mermaid graph TD     A[开始] --> B{参数校验};     B --> |通过| C{是否允许小数?};     C --> |是| D[生成随机小数];     C --> |否| E[生成随机整数];     D --> F{是否允许重复?};     E --> F;     F --> |是| G[直接生成指定数量];     F --> |否| H[生成不重复的数字];     G --> I[返回结果];     H --> I;     B --> |失败| J[返回 400 错误]; ``` ## 使用须知 > [!WARNING] > **不重复生成的逻辑限制** > 当设置 `allow_repeat=false` 时，请确保取值范围 `(max - min + 1)` 大于或等于你请求的数量 `count`。否则，系统将无法生成足够的不重复数字，请求会失败并返回 400 错误。
         * @summary 生成高度可定制的随机数
         * @param {number} [min] 生成随机数的最小值（包含）。
         * @param {number} [max] 生成随机数的最大值（包含）。
         * @param {number} [count] 需要生成的随机数的数量。
         * @param {boolean} [allowRepeat] 是否允许生成的多个数字中出现重复值。
         * @param {boolean} [allowDecimal] 是否生成小（浮点）数。如果为 false，则只生成整数。
         * @param {number} [decimalPlaces] 如果 &#x60;allow_decimal&#x3D;true&#x60;，这里可以指定小数的位数。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiscRandomnumber(min?: number, max?: number, count?: number, allowRepeat?: boolean, allowDecimal?: boolean, decimalPlaces?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiscRandomnumber200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiscRandomnumber(min, max, count, allowRepeat, allowDecimal, decimalPlaces, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.getMiscRandomnumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 这是一个用于将Unix时间戳转换为人类可读日期时间的旧版接口。  ## 功能概述 输入一个秒级或毫秒级的时间戳，返回其对应的本地时间和UTC时间。  > [!WARNING] > **接口已过时**：这个接口已被新的 `/convert/unixtime` 取代。新接口功能更强大，支持双向转换。我们建议你迁移到新接口。  [👉 前往新版接口文档](/docs/api-reference/get-convert-unixtime)
         * @summary 转换时间戳 (旧版，推荐使用/convert/unixtime)
         * @param {string} ts 需要转换的Unix时间戳，支持10位（秒）或13位（毫秒）。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiscTimestamp(ts: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiscTimestamp200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiscTimestamp(ts, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.getMiscTimestamp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 不确定系统支持哪些快递公司？这个接口返回完整的支持列表。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 获取系统当前支持的所有快递公司列表，包括每家公司的标准编码（code）和中文名称（name）。  ## 使用建议 - **推荐缓存**：这个列表基本不会频繁变动，建议在应用启动时调用一次并缓存到本地 - **应用场景**：适合用于构建快递公司选择器、下拉菜单等UI组件 - **缓存时长**：建议缓存24小时或更久
         * @summary 获取支持的快递公司列表
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiscTrackingCarriers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiscTrackingCarriers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiscTrackingCarriers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.getMiscTrackingCarriers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 不确定手里的快递单号属于哪家快递公司？这个接口专门做识别，不查物流。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 输入快递单号，系统会根据单号规则快速识别出最可能的快递公司。如果存在多个可能的匹配结果，还会在 `alternatives` 字段中返回备选项，供你参考选择。  ## 使用须知 - **识别速度快**：只做规则匹配，不查询物流信息，响应速度通常在100ms内 - **准确率高**：基于各快递公司的单号规则进行智能识别，准确率超过95% - **备选方案**：当单号规则可能匹配多家快递公司时，会提供所有可能的选项
         * @summary 识别快递公司
         * @param {string} trackingNumber 需要识别的快递单号。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiscTrackingDetect(trackingNumber: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiscTrackingDetect200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiscTrackingDetect(trackingNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.getMiscTrackingDetect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 买了东西想知道快递到哪儿了？这个接口帮你实时追踪物流状态。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 提供一个快递单号，系统会自动识别快递公司并返回完整的物流轨迹信息。支持中通、圆通、韵达、申通、极兔、顺丰、京东、EMS、德邦等60+国内外主流快递公司。  ## 使用须知 - **自动识别**：不知道是哪家快递？系统会根据单号规则自动识别快递公司（推荐使用） - **手动指定**：如果已知快递公司，可以传递 `carrier_code` 参数，查询速度会更快 - **查询时效**：物流信息实时查询，响应时间通常在1-2秒内
         * @summary 查询快递物流信息
         * @param {string} trackingNumber 快递单号，通常是一串10-20位的数字或字母数字组合。
         * @param {string} [carrierCode] 快递公司编码（可选）。不填写时系统会自动识别，填写后可加快查询速度。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiscTrackingQuery(trackingNumber: string, carrierCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiscTrackingQuery200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiscTrackingQuery(trackingNumber, carrierCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.getMiscTrackingQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 出门前，查一下天气总是个好习惯。这个接口为你提供精准、实时的天气数据。  ## 功能概述 你可以通过城市名称或高德地图的Adcode来查询指定地区的实时天气状况，包括天气现象、温度、湿度、风向和风力等。  ## 使用须知 - **参数优先级**：当你同时提供了 `city` (城市名) 和 `adcode` (城市编码) 两个参数时，系统会 **优先使用 `adcode`** 进行查询，因为它更精确。 - **查询范围**：为了保证查询的准确性，我们的服务仅支持标准的“省”、“市”、“区/县”级别的行政区划名称查询，不保证能查询到乡镇或具体地点。  ## 错误处理指南 - **410 Gone**: 这个特殊的错误码意味着你查询的地区无效或不受我们支持。比如你输入了“火星”，或者某个我们无法识别的村庄名称。这个状态码告诉你，这个“资源”是永久性地不可用了。
         * @summary 查询实时天气信息
         * @param {string} [city] 标准的城市名称，如 \&#39;北京\&#39;, \&#39;上海市\&#39;, \&#39;福田区\&#39;。请使用官方的省、市、区县行政区划名称。
         * @param {string} [adcode] 高德地图的6位数字城市编码。例如，北京市的Adcode是 \&#39;110000\&#39;。使用Adcode查询更准确、更快速。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiscWeather(city?: string, adcode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiscWeather200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiscWeather(city, adcode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.getMiscWeather']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 需要和国外的朋友开会，想知道他那边现在几点？用这个接口一查便知。  ## 功能概述 根据标准的时区名称（例如 \'Asia/Shanghai\' 或 \'Europe/London\'），获取该时区的当前准确时间、UTC偏移量、星期等信息。
         * @summary 查询全球任意时区的时间
         * @param {string} city 你需要查询的城市或地区，请使用标准的 IANA 时区数据库名称，例如 \&#39;Shanghai\&#39;, \&#39;Asia/Tokyo\&#39;, \&#39;America/New_York\&#39;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMiscWorldtime(city: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMiscWorldtime200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMiscWorldtime(city, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.getMiscWorldtime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MiscApi - factory interface
 */
export const MiscApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiscApiFp(configuration)
    return {
        /**
         * 想查看程序员历史上某个特定日期发生的大事件？指定月份和日期，我们就能告诉你！  ## 功能概述 通过指定月份和日期，获取该日发生的程序员相关历史事件。同样使用AI智能筛选，确保事件的相关性和重要性。
         * @summary 获取指定日期的程序员历史事件
         * @param {number} month 月份，1-12之间的整数。
         * @param {number} day 日期，1-31之间的整数。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoryProgrammer(month: number, day: number, options?: RawAxiosRequestConfig): AxiosPromise<GetHistoryProgrammer200Response> {
            return localVarFp.getHistoryProgrammer(month, day, options).then((request) => request(axios, basePath));
        },
        /**
         * 想知道程序员历史上的今天发生了什么大事吗？这个接口告诉你答案！  ## 功能概述 我们使用AI智能筛选从海量历史事件中挑选出与程序员、计算机科学相关的重要事件。每个事件都经过重要性评分和相关性评分，确保内容质量。
         * @summary 获取今天的程序员历史事件
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoryProgrammerToday(options?: RawAxiosRequestConfig): AxiosPromise<GetHistoryProgrammerToday200Response> {
            return localVarFp.getHistoryProgrammerToday(options).then((request) => request(axios, basePath));
        },
        /**
         * 想快速跟上网络热点？这个接口让你一网打尽各大主流平台的实时热榜/热搜！  ## 功能概述 你只需要指定一个平台类型，就能获取到该平台当前的热榜数据列表。每个热榜条目都包含标题、热度值和原始链接。非常适合用于制作信息聚合类应用或看板。  ## 可选值 `type` 参数接受多种不同的值，每种值对应一个不同的热榜来源。以下是目前支持的所有值：  | 分类       | 支持的 type 值 | |------------|-----------------------------------------------------------------------------------------------------------------------------------| | 视频/社区  | bilibili（哔哩哔哩弹幕网）, acfun（A站弹幕视频网站）, weibo（新浪微博热搜）, zhihu（知乎热榜）, zhihu-daily（知乎日报热榜）, douyin（抖音热榜）, kuaishou（快手热榜）, douban-movie（豆瓣电影榜单）, douban-group（豆瓣小组话题）, tieba（百度贴吧热帖）, hupu（虎扑热帖）, miyoushe（米游社话题榜）, ngabbs（NGA游戏论坛热帖）, v2ex（V2EX技术社区热帖）, 52pojie（吾爱破解热帖）, hostloc（全球主机交流论坛）, coolapk（酷安热榜） | | 新闻/资讯  | baidu（百度热搜）, thepaper（澎湃新闻热榜）, toutiao（今日头条热榜）, qq-news（腾讯新闻热榜）, sina（新浪热搜）, sina-news（新浪新闻热榜）, netease-news（网易新闻热榜）, huxiu（虎嗅网热榜）, ifanr（爱范儿热榜） | | 技术/IT    | sspai（少数派热榜）, ithome（IT之家热榜）, ithome-xijiayi（IT之家·喜加一栏目）, juejin（掘金社区热榜）, jianshu（简书热榜）, guokr（果壳热榜）, 36kr（36氪热榜）, 51cto（51CTO热榜）, csdn（CSDN博客热榜）, nodeseek（NodeSeek 技术社区）, hellogithub（HelloGitHub 项目推荐） | | 游戏       | lol（英雄联盟热帖）, genshin（原神热榜）, honkai（崩坏3热榜）, starrail（星穹铁道热榜） | | 其他       | weread（微信读书热门书籍）, weatheralarm（天气预警信息）, earthquake（地震速报）, history（历史上的今天） | 
         * @summary 获取多平台实时热榜
         * @param {GetMiscHotboardTypeEnum} type 你想要查询的热榜平台。支持多种主流平台类型，详见下方[可选值](#可选值)表格。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscHotboard(type: GetMiscHotboardTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetMiscHotboard200Response> {
            return localVarFp.getMiscHotboard(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 想知道一个手机号码来自哪里？是移动、联通还是电信？这个接口可以告诉你答案。  ## 功能概述 提供一个国内的手机号码，我们会查询并返回它的归属地（省份和城市）以及所属的运营商信息。
         * @summary 查询手机号码归属地信息
         * @param {string} phone 需要查询的11位中国大陆手机号码。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscPhoneinfo(phone: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMiscPhoneinfo200Response> {
            return localVarFp.getMiscPhoneinfo(phone, options).then((request) => request(axios, basePath));
        },
        /**
         * 需要一个简单的随机数，还是需要一串不重复的、带小数的随机数？这个接口都能满足你！  ## 功能概述 这是一个强大的随机数生成器。你可以指定生成的范围（最大/最小值）、数量、是否允许重复、以及是否生成小数（并指定小数位数）。  ## 流程图 ```mermaid graph TD     A[开始] --> B{参数校验};     B --> |通过| C{是否允许小数?};     C --> |是| D[生成随机小数];     C --> |否| E[生成随机整数];     D --> F{是否允许重复?};     E --> F;     F --> |是| G[直接生成指定数量];     F --> |否| H[生成不重复的数字];     G --> I[返回结果];     H --> I;     B --> |失败| J[返回 400 错误]; ``` ## 使用须知 > [!WARNING] > **不重复生成的逻辑限制** > 当设置 `allow_repeat=false` 时，请确保取值范围 `(max - min + 1)` 大于或等于你请求的数量 `count`。否则，系统将无法生成足够的不重复数字，请求会失败并返回 400 错误。
         * @summary 生成高度可定制的随机数
         * @param {number} [min] 生成随机数的最小值（包含）。
         * @param {number} [max] 生成随机数的最大值（包含）。
         * @param {number} [count] 需要生成的随机数的数量。
         * @param {boolean} [allowRepeat] 是否允许生成的多个数字中出现重复值。
         * @param {boolean} [allowDecimal] 是否生成小（浮点）数。如果为 false，则只生成整数。
         * @param {number} [decimalPlaces] 如果 &#x60;allow_decimal&#x3D;true&#x60;，这里可以指定小数的位数。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscRandomnumber(min?: number, max?: number, count?: number, allowRepeat?: boolean, allowDecimal?: boolean, decimalPlaces?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetMiscRandomnumber200Response> {
            return localVarFp.getMiscRandomnumber(min, max, count, allowRepeat, allowDecimal, decimalPlaces, options).then((request) => request(axios, basePath));
        },
        /**
         * 这是一个用于将Unix时间戳转换为人类可读日期时间的旧版接口。  ## 功能概述 输入一个秒级或毫秒级的时间戳，返回其对应的本地时间和UTC时间。  > [!WARNING] > **接口已过时**：这个接口已被新的 `/convert/unixtime` 取代。新接口功能更强大，支持双向转换。我们建议你迁移到新接口。  [👉 前往新版接口文档](/docs/api-reference/get-convert-unixtime)
         * @summary 转换时间戳 (旧版，推荐使用/convert/unixtime)
         * @param {string} ts 需要转换的Unix时间戳，支持10位（秒）或13位（毫秒）。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscTimestamp(ts: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMiscTimestamp200Response> {
            return localVarFp.getMiscTimestamp(ts, options).then((request) => request(axios, basePath));
        },
        /**
         * 不确定系统支持哪些快递公司？这个接口返回完整的支持列表。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 获取系统当前支持的所有快递公司列表，包括每家公司的标准编码（code）和中文名称（name）。  ## 使用建议 - **推荐缓存**：这个列表基本不会频繁变动，建议在应用启动时调用一次并缓存到本地 - **应用场景**：适合用于构建快递公司选择器、下拉菜单等UI组件 - **缓存时长**：建议缓存24小时或更久
         * @summary 获取支持的快递公司列表
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscTrackingCarriers(options?: RawAxiosRequestConfig): AxiosPromise<GetMiscTrackingCarriers200Response> {
            return localVarFp.getMiscTrackingCarriers(options).then((request) => request(axios, basePath));
        },
        /**
         * 不确定手里的快递单号属于哪家快递公司？这个接口专门做识别，不查物流。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 输入快递单号，系统会根据单号规则快速识别出最可能的快递公司。如果存在多个可能的匹配结果，还会在 `alternatives` 字段中返回备选项，供你参考选择。  ## 使用须知 - **识别速度快**：只做规则匹配，不查询物流信息，响应速度通常在100ms内 - **准确率高**：基于各快递公司的单号规则进行智能识别，准确率超过95% - **备选方案**：当单号规则可能匹配多家快递公司时，会提供所有可能的选项
         * @summary 识别快递公司
         * @param {string} trackingNumber 需要识别的快递单号。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscTrackingDetect(trackingNumber: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMiscTrackingDetect200Response> {
            return localVarFp.getMiscTrackingDetect(trackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 买了东西想知道快递到哪儿了？这个接口帮你实时追踪物流状态。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 提供一个快递单号，系统会自动识别快递公司并返回完整的物流轨迹信息。支持中通、圆通、韵达、申通、极兔、顺丰、京东、EMS、德邦等60+国内外主流快递公司。  ## 使用须知 - **自动识别**：不知道是哪家快递？系统会根据单号规则自动识别快递公司（推荐使用） - **手动指定**：如果已知快递公司，可以传递 `carrier_code` 参数，查询速度会更快 - **查询时效**：物流信息实时查询，响应时间通常在1-2秒内
         * @summary 查询快递物流信息
         * @param {string} trackingNumber 快递单号，通常是一串10-20位的数字或字母数字组合。
         * @param {string} [carrierCode] 快递公司编码（可选）。不填写时系统会自动识别，填写后可加快查询速度。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscTrackingQuery(trackingNumber: string, carrierCode?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMiscTrackingQuery200Response> {
            return localVarFp.getMiscTrackingQuery(trackingNumber, carrierCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 出门前，查一下天气总是个好习惯。这个接口为你提供精准、实时的天气数据。  ## 功能概述 你可以通过城市名称或高德地图的Adcode来查询指定地区的实时天气状况，包括天气现象、温度、湿度、风向和风力等。  ## 使用须知 - **参数优先级**：当你同时提供了 `city` (城市名) 和 `adcode` (城市编码) 两个参数时，系统会 **优先使用 `adcode`** 进行查询，因为它更精确。 - **查询范围**：为了保证查询的准确性，我们的服务仅支持标准的“省”、“市”、“区/县”级别的行政区划名称查询，不保证能查询到乡镇或具体地点。  ## 错误处理指南 - **410 Gone**: 这个特殊的错误码意味着你查询的地区无效或不受我们支持。比如你输入了“火星”，或者某个我们无法识别的村庄名称。这个状态码告诉你，这个“资源”是永久性地不可用了。
         * @summary 查询实时天气信息
         * @param {string} [city] 标准的城市名称，如 \&#39;北京\&#39;, \&#39;上海市\&#39;, \&#39;福田区\&#39;。请使用官方的省、市、区县行政区划名称。
         * @param {string} [adcode] 高德地图的6位数字城市编码。例如，北京市的Adcode是 \&#39;110000\&#39;。使用Adcode查询更准确、更快速。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscWeather(city?: string, adcode?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMiscWeather200Response> {
            return localVarFp.getMiscWeather(city, adcode, options).then((request) => request(axios, basePath));
        },
        /**
         * 需要和国外的朋友开会，想知道他那边现在几点？用这个接口一查便知。  ## 功能概述 根据标准的时区名称（例如 \'Asia/Shanghai\' 或 \'Europe/London\'），获取该时区的当前准确时间、UTC偏移量、星期等信息。
         * @summary 查询全球任意时区的时间
         * @param {string} city 你需要查询的城市或地区，请使用标准的 IANA 时区数据库名称，例如 \&#39;Shanghai\&#39;, \&#39;Asia/Tokyo\&#39;, \&#39;America/New_York\&#39;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMiscWorldtime(city: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMiscWorldtime200Response> {
            return localVarFp.getMiscWorldtime(city, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiscApi - object-oriented interface
 */
export class MiscApi extends BaseAPI {
    /**
     * 想查看程序员历史上某个特定日期发生的大事件？指定月份和日期，我们就能告诉你！  ## 功能概述 通过指定月份和日期，获取该日发生的程序员相关历史事件。同样使用AI智能筛选，确保事件的相关性和重要性。
     * @summary 获取指定日期的程序员历史事件
     * @param {number} month 月份，1-12之间的整数。
     * @param {number} day 日期，1-31之间的整数。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getHistoryProgrammer(month: number, day: number, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).getHistoryProgrammer(month, day, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想知道程序员历史上的今天发生了什么大事吗？这个接口告诉你答案！  ## 功能概述 我们使用AI智能筛选从海量历史事件中挑选出与程序员、计算机科学相关的重要事件。每个事件都经过重要性评分和相关性评分，确保内容质量。
     * @summary 获取今天的程序员历史事件
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getHistoryProgrammerToday(options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).getHistoryProgrammerToday(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想快速跟上网络热点？这个接口让你一网打尽各大主流平台的实时热榜/热搜！  ## 功能概述 你只需要指定一个平台类型，就能获取到该平台当前的热榜数据列表。每个热榜条目都包含标题、热度值和原始链接。非常适合用于制作信息聚合类应用或看板。  ## 可选值 `type` 参数接受多种不同的值，每种值对应一个不同的热榜来源。以下是目前支持的所有值：  | 分类       | 支持的 type 值 | |------------|-----------------------------------------------------------------------------------------------------------------------------------| | 视频/社区  | bilibili（哔哩哔哩弹幕网）, acfun（A站弹幕视频网站）, weibo（新浪微博热搜）, zhihu（知乎热榜）, zhihu-daily（知乎日报热榜）, douyin（抖音热榜）, kuaishou（快手热榜）, douban-movie（豆瓣电影榜单）, douban-group（豆瓣小组话题）, tieba（百度贴吧热帖）, hupu（虎扑热帖）, miyoushe（米游社话题榜）, ngabbs（NGA游戏论坛热帖）, v2ex（V2EX技术社区热帖）, 52pojie（吾爱破解热帖）, hostloc（全球主机交流论坛）, coolapk（酷安热榜） | | 新闻/资讯  | baidu（百度热搜）, thepaper（澎湃新闻热榜）, toutiao（今日头条热榜）, qq-news（腾讯新闻热榜）, sina（新浪热搜）, sina-news（新浪新闻热榜）, netease-news（网易新闻热榜）, huxiu（虎嗅网热榜）, ifanr（爱范儿热榜） | | 技术/IT    | sspai（少数派热榜）, ithome（IT之家热榜）, ithome-xijiayi（IT之家·喜加一栏目）, juejin（掘金社区热榜）, jianshu（简书热榜）, guokr（果壳热榜）, 36kr（36氪热榜）, 51cto（51CTO热榜）, csdn（CSDN博客热榜）, nodeseek（NodeSeek 技术社区）, hellogithub（HelloGitHub 项目推荐） | | 游戏       | lol（英雄联盟热帖）, genshin（原神热榜）, honkai（崩坏3热榜）, starrail（星穹铁道热榜） | | 其他       | weread（微信读书热门书籍）, weatheralarm（天气预警信息）, earthquake（地震速报）, history（历史上的今天） | 
     * @summary 获取多平台实时热榜
     * @param {GetMiscHotboardTypeEnum} type 你想要查询的热榜平台。支持多种主流平台类型，详见下方[可选值](#可选值)表格。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMiscHotboard(type: GetMiscHotboardTypeEnum, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).getMiscHotboard(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想知道一个手机号码来自哪里？是移动、联通还是电信？这个接口可以告诉你答案。  ## 功能概述 提供一个国内的手机号码，我们会查询并返回它的归属地（省份和城市）以及所属的运营商信息。
     * @summary 查询手机号码归属地信息
     * @param {string} phone 需要查询的11位中国大陆手机号码。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMiscPhoneinfo(phone: string, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).getMiscPhoneinfo(phone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 需要一个简单的随机数，还是需要一串不重复的、带小数的随机数？这个接口都能满足你！  ## 功能概述 这是一个强大的随机数生成器。你可以指定生成的范围（最大/最小值）、数量、是否允许重复、以及是否生成小数（并指定小数位数）。  ## 流程图 ```mermaid graph TD     A[开始] --> B{参数校验};     B --> |通过| C{是否允许小数?};     C --> |是| D[生成随机小数];     C --> |否| E[生成随机整数];     D --> F{是否允许重复?};     E --> F;     F --> |是| G[直接生成指定数量];     F --> |否| H[生成不重复的数字];     G --> I[返回结果];     H --> I;     B --> |失败| J[返回 400 错误]; ``` ## 使用须知 > [!WARNING] > **不重复生成的逻辑限制** > 当设置 `allow_repeat=false` 时，请确保取值范围 `(max - min + 1)` 大于或等于你请求的数量 `count`。否则，系统将无法生成足够的不重复数字，请求会失败并返回 400 错误。
     * @summary 生成高度可定制的随机数
     * @param {number} [min] 生成随机数的最小值（包含）。
     * @param {number} [max] 生成随机数的最大值（包含）。
     * @param {number} [count] 需要生成的随机数的数量。
     * @param {boolean} [allowRepeat] 是否允许生成的多个数字中出现重复值。
     * @param {boolean} [allowDecimal] 是否生成小（浮点）数。如果为 false，则只生成整数。
     * @param {number} [decimalPlaces] 如果 &#x60;allow_decimal&#x3D;true&#x60;，这里可以指定小数的位数。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMiscRandomnumber(min?: number, max?: number, count?: number, allowRepeat?: boolean, allowDecimal?: boolean, decimalPlaces?: number, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).getMiscRandomnumber(min, max, count, allowRepeat, allowDecimal, decimalPlaces, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 这是一个用于将Unix时间戳转换为人类可读日期时间的旧版接口。  ## 功能概述 输入一个秒级或毫秒级的时间戳，返回其对应的本地时间和UTC时间。  > [!WARNING] > **接口已过时**：这个接口已被新的 `/convert/unixtime` 取代。新接口功能更强大，支持双向转换。我们建议你迁移到新接口。  [👉 前往新版接口文档](/docs/api-reference/get-convert-unixtime)
     * @summary 转换时间戳 (旧版，推荐使用/convert/unixtime)
     * @param {string} ts 需要转换的Unix时间戳，支持10位（秒）或13位（毫秒）。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMiscTimestamp(ts: string, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).getMiscTimestamp(ts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 不确定系统支持哪些快递公司？这个接口返回完整的支持列表。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 获取系统当前支持的所有快递公司列表，包括每家公司的标准编码（code）和中文名称（name）。  ## 使用建议 - **推荐缓存**：这个列表基本不会频繁变动，建议在应用启动时调用一次并缓存到本地 - **应用场景**：适合用于构建快递公司选择器、下拉菜单等UI组件 - **缓存时长**：建议缓存24小时或更久
     * @summary 获取支持的快递公司列表
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMiscTrackingCarriers(options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).getMiscTrackingCarriers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 不确定手里的快递单号属于哪家快递公司？这个接口专门做识别，不查物流。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 输入快递单号，系统会根据单号规则快速识别出最可能的快递公司。如果存在多个可能的匹配结果，还会在 `alternatives` 字段中返回备选项，供你参考选择。  ## 使用须知 - **识别速度快**：只做规则匹配，不查询物流信息，响应速度通常在100ms内 - **准确率高**：基于各快递公司的单号规则进行智能识别，准确率超过95% - **备选方案**：当单号规则可能匹配多家快递公司时，会提供所有可能的选项
     * @summary 识别快递公司
     * @param {string} trackingNumber 需要识别的快递单号。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMiscTrackingDetect(trackingNumber: string, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).getMiscTrackingDetect(trackingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 买了东西想知道快递到哪儿了？这个接口帮你实时追踪物流状态。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 提供一个快递单号，系统会自动识别快递公司并返回完整的物流轨迹信息。支持中通、圆通、韵达、申通、极兔、顺丰、京东、EMS、德邦等60+国内外主流快递公司。  ## 使用须知 - **自动识别**：不知道是哪家快递？系统会根据单号规则自动识别快递公司（推荐使用） - **手动指定**：如果已知快递公司，可以传递 `carrier_code` 参数，查询速度会更快 - **查询时效**：物流信息实时查询，响应时间通常在1-2秒内
     * @summary 查询快递物流信息
     * @param {string} trackingNumber 快递单号，通常是一串10-20位的数字或字母数字组合。
     * @param {string} [carrierCode] 快递公司编码（可选）。不填写时系统会自动识别，填写后可加快查询速度。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMiscTrackingQuery(trackingNumber: string, carrierCode?: string, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).getMiscTrackingQuery(trackingNumber, carrierCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 出门前，查一下天气总是个好习惯。这个接口为你提供精准、实时的天气数据。  ## 功能概述 你可以通过城市名称或高德地图的Adcode来查询指定地区的实时天气状况，包括天气现象、温度、湿度、风向和风力等。  ## 使用须知 - **参数优先级**：当你同时提供了 `city` (城市名) 和 `adcode` (城市编码) 两个参数时，系统会 **优先使用 `adcode`** 进行查询，因为它更精确。 - **查询范围**：为了保证查询的准确性，我们的服务仅支持标准的“省”、“市”、“区/县”级别的行政区划名称查询，不保证能查询到乡镇或具体地点。  ## 错误处理指南 - **410 Gone**: 这个特殊的错误码意味着你查询的地区无效或不受我们支持。比如你输入了“火星”，或者某个我们无法识别的村庄名称。这个状态码告诉你，这个“资源”是永久性地不可用了。
     * @summary 查询实时天气信息
     * @param {string} [city] 标准的城市名称，如 \&#39;北京\&#39;, \&#39;上海市\&#39;, \&#39;福田区\&#39;。请使用官方的省、市、区县行政区划名称。
     * @param {string} [adcode] 高德地图的6位数字城市编码。例如，北京市的Adcode是 \&#39;110000\&#39;。使用Adcode查询更准确、更快速。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMiscWeather(city?: string, adcode?: string, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).getMiscWeather(city, adcode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 需要和国外的朋友开会，想知道他那边现在几点？用这个接口一查便知。  ## 功能概述 根据标准的时区名称（例如 \'Asia/Shanghai\' 或 \'Europe/London\'），获取该时区的当前准确时间、UTC偏移量、星期等信息。
     * @summary 查询全球任意时区的时间
     * @param {string} city 你需要查询的城市或地区，请使用标准的 IANA 时区数据库名称，例如 \&#39;Shanghai\&#39;, \&#39;Asia/Tokyo\&#39;, \&#39;America/New_York\&#39;。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMiscWorldtime(city: string, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).getMiscWorldtime(city, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetMiscHotboardTypeEnum = {
    Bilibili: 'bilibili',
    Acfun: 'acfun',
    Weibo: 'weibo',
    Zhihu: 'zhihu',
    ZhihuDaily: 'zhihu-daily',
    Douyin: 'douyin',
    Kuaishou: 'kuaishou',
    DoubanMovie: 'douban-movie',
    DoubanGroup: 'douban-group',
    Tieba: 'tieba',
    Hupu: 'hupu',
    Miyoushe: 'miyoushe',
    Ngabbs: 'ngabbs',
    V2ex: 'v2ex',
    _52pojie: '52pojie',
    Hostloc: 'hostloc',
    Coolapk: 'coolapk',
    Baidu: 'baidu',
    Thepaper: 'thepaper',
    Toutiao: 'toutiao',
    QqNews: 'qq-news',
    Sina: 'sina',
    SinaNews: 'sina-news',
    NeteaseNews: 'netease-news',
    Huxiu: 'huxiu',
    Ifanr: 'ifanr',
    Sspai: 'sspai',
    Ithome: 'ithome',
    IthomeXijiayi: 'ithome-xijiayi',
    Juejin: 'juejin',
    Jianshu: 'jianshu',
    Guokr: 'guokr',
    _36kr: '36kr',
    _51cto: '51cto',
    Csdn: 'csdn',
    Nodeseek: 'nodeseek',
    Hellogithub: 'hellogithub',
    Lol: 'lol',
    Genshin: 'genshin',
    Honkai: 'honkai',
    Starrail: 'starrail',
    Weread: 'weread',
    Weatheralarm: 'weatheralarm',
    Earthquake: 'earthquake',
    History: 'history'
} as const;
export type GetMiscHotboardTypeEnum = typeof GetMiscHotboardTypeEnum[keyof typeof GetMiscHotboardTypeEnum];


/**
 * NetworkApi - axios parameter creator
 */
export const NetworkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 想知道一个域名指向了哪个IP？或者它的邮件服务器是谁？这个接口就像一个在线的 `dig` 或 `nslookup` 工具。  ## 功能概述 你可以查询指定域名的各种DNS记录，包括 `A` (IPv4), `AAAA` (IPv6), `CNAME` (别名), `MX` (邮件交换), `NS` (域名服务器) 和 `TXT` (文本记录)。
         * @summary 执行DNS解析查询
         * @param {string} domain 你需要查询的域名，例如 \&#39;cn.bing.com\&#39;。
         * @param {GetNetworkDnsTypeEnum} [type] 你想要查询的DNS记录类型。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkDns: async (domain: string, type?: GetNetworkDnsTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getNetworkDns', 'domain', domain)
            const localVarPath = `/network/dns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想知道一个网站的背后运营主体是谁吗？如果它是在中国大陆运营的，ICP备案信息可以告诉你答案。  ## 功能概述 提供一个域名，查询其在中国工信部的ICP（Internet Content Provider）备案信息。这对于商业合作前的背景调查、验证网站合法性等场景很有帮助。  > [!NOTE] > **查询范围** > 此查询仅对在中国大陆工信部进行过备案的域名有效。对于国外域名或未备案的域名，将查询不到结果。
         * @summary 查询域名ICP备案信息
         * @param {string} domain 需要查询的域名或URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkIcp: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getNetworkIcp', 'domain', domain)
            const localVarPath = `/network/icp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想知道一个IP地址或域名来自地球的哪个角落？这个接口可以帮你定位它。你可以选择使用默认的GeoIP数据库，也可以指定 `source=commercial` 参数来查询更详细的商业级IP归属信息。  ## 功能概述 提供一个公网IPv4、IPv6地址或域名，我们会利用GeoIP数据库查询并返回它的地理位置（国家、省份、城市）、经纬度、以及所属的运营商（ISP）和自治系统（ASN）信息。这在网络安全分析、访问来源统计等领域非常有用。  当使用 `source=commercial` 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
         * @summary 查询指定IP或域名的归属信息
         * @param {string} ip 你需要查询的公网IP地址或域名（支持IPv4和IPv6）。
         * @param {GetNetworkIpinfoSourceEnum} [source] 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkIpinfo: async (ip: string, source?: GetNetworkIpinfoSourceEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ip' is not null or undefined
            assertParamExists('getNetworkIpinfo', 'ip', ip)
            const localVarPath = `/network/ipinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想知道你自己的出口公网IP是多少吗？这个接口就是你的“网络身份证”。你可以选择使用默认的GeoIP数据库，也可以指定 `source=commercial` 参数来查询更详细的商业级IP归属信息。  ## 功能概述 调用此接口，它会返回你（即发起请求的客户端）的公网IP地址，并附带与 `/network/ipinfo` 接口相同的地理位置和网络归属信息。非常适合用于在网页上向用户展示他们自己的IP和地理位置。  当使用 `source=commercial` 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
         * @summary 获取你的公网IP及归属信息
         * @param {GetNetworkMyipSourceEnum} [source] 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkMyip: async (source?: GetNetworkMyipSourceEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/network/myip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想知道从我们的服务器到你的服务器网络延迟高不高？这个工具可以帮你测试网络连通性。  ## 功能概述 这个接口会从我们的服务器节点对你指定的主机（域名或IP地址）执行 ICMP Ping 操作。它会返回最小、最大、平均延迟以及丢包率等关键指标，是诊断网络问题的得力助手。
         * @summary 从服务器Ping指定主机
         * @param {string} host 你需要 Ping 的目标主机，可以是域名或IP地址。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkPing: async (host: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'host' is not null or undefined
            assertParamExists('getNetworkPing', 'host', host)
            const localVarPath = `/network/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 这是一个非常方便的快捷接口，想知道你的网络到我们服务器的回程延迟吗？点一下就行！  ## 功能概述 这个接口是 `/network/myip` 和 `/network/ping` 的结合体。它会自动获取你客户端的公网IP，然后从我们的服务器Ping这个IP，并返回延迟数据。这对于快速判断你本地网络到服务器的连接质量非常有用。
         * @summary 从服务器Ping你的客户端IP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkPingmyip: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/network/pingmyip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想检查一下你的服务器上某个端口（比如SSH的22端口或者Web的80端口）是否对外开放？这个工具可以帮你快速确认。  ## 功能概述 你可以指定一个主机和端口号，我们的服务器会尝试连接该端口，并告诉你它是开放的（open）、关闭的（closed）还是超时了（timeout）。这对于网络服务配置检查和基本的安全扫描很有用。
         * @summary 扫描远程主机的指定端口
         * @param {string} host 需要扫描的目标主机，可以是域名或IP地址。
         * @param {number} port 需要扫描的端口号，范围是 1 到 65535。
         * @param {GetNetworkPortscanProtocolEnum} [protocol] 扫描使用的协议，可以是 \&#39;tcp\&#39; 或 \&#39;udp\&#39;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkPortscan: async (host: string, port: number, protocol?: GetNetworkPortscanProtocolEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'host' is not null or undefined
            assertParamExists('getNetworkPortscan', 'host', host)
            // verify required parameter 'port' is not null or undefined
            assertParamExists('getNetworkPortscan', 'port', port)
            const localVarPath = `/network/portscan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (port !== undefined) {
                localVarQueryParameter['port'] = port;
            }

            if (protocol !== undefined) {
                localVarQueryParameter['protocol'] = protocol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 你的网站或API还好吗？用这个接口给它做个快速“体检”吧。  ## 功能概述 提供一个URL，我们会向它发起一个请求，并返回其HTTP响应状态码。这是一种简单而有效的服务可用性监控方法。  > [!TIP] > **性能优化**：为了提高效率并减少对目标服务器的负载，我们实际发送的是 `HEAD` 请求，而不是 `GET` 请求。`HEAD` 请求只会获取响应头，而不会下载整个页面内容，因此速度更快。
         * @summary 检查URL的可访问性状态
         * @param {string} url 你需要检查其可访问性状态的完整URL。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkUrlstatus: async (url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('getNetworkUrlstatus', 'url', url)
            const localVarPath = `/network/urlstatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想知道一个域名是什么时候注册的、注册商是谁、什么时候到期？WHOIS信息可以告诉你这一切。  ## 功能概述 这是一个在线的WHOIS查询工具。你可以通过如下两种方式获取WHOIS信息：  - **默认行为**（不带参数）：`GET /api/v1/network/whois?domain=google.com`   - 返回一个JSON对象，`whois` 字段为原始、未处理的WHOIS文本字符串。 - **JSON格式化**：`GET /api/v1/network/whois?domain=google.com&format=json`   - 返回一个JSON对象，`whois` 字段为解析后的JSON对象，包含WHOIS信息中的键值对。  这样你既可以获得最全的原始信息，也可以方便地处理结构化数据。
         * @summary 查询域名的WHOIS注册信息
         * @param {string} domain 你需要查询WHOIS信息的域名。
         * @param {GetNetworkWhoisFormatEnum} [format] 返回格式。留空或为 \&#39;text\&#39; 时返回原始WHOIS文本，设为 \&#39;json\&#39; 时返回结构化JSON。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkWhois: async (domain: string, format?: GetNetworkWhoisFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getNetworkWhois', 'domain', domain)
            const localVarPath = `/network/whois`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 准备在微信里推广你的网站？最好先检查一下域名是否被“拉黑”了。  ## 功能概述 这个接口可以帮你查询一个域名在微信内置浏览器中的访问状态，即是否被微信封禁。这对于做微信生态推广和营销的开发者来说至关重要。
         * @summary 检查域名在微信中的访问状态
         * @param {string} domain 需要查询的域名。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkWxdomain: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getNetworkWxdomain', 'domain', domain)
            const localVarPath = `/network/wxdomain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkApi - functional programming interface
 */
export const NetworkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkApiAxiosParamCreator(configuration)
    return {
        /**
         * 想知道一个域名指向了哪个IP？或者它的邮件服务器是谁？这个接口就像一个在线的 `dig` 或 `nslookup` 工具。  ## 功能概述 你可以查询指定域名的各种DNS记录，包括 `A` (IPv4), `AAAA` (IPv6), `CNAME` (别名), `MX` (邮件交换), `NS` (域名服务器) 和 `TXT` (文本记录)。
         * @summary 执行DNS解析查询
         * @param {string} domain 你需要查询的域名，例如 \&#39;cn.bing.com\&#39;。
         * @param {GetNetworkDnsTypeEnum} [type] 你想要查询的DNS记录类型。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkDns(domain: string, type?: GetNetworkDnsTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNetworkDns200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkDns(domain, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworkApi.getNetworkDns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想知道一个网站的背后运营主体是谁吗？如果它是在中国大陆运营的，ICP备案信息可以告诉你答案。  ## 功能概述 提供一个域名，查询其在中国工信部的ICP（Internet Content Provider）备案信息。这对于商业合作前的背景调查、验证网站合法性等场景很有帮助。  > [!NOTE] > **查询范围** > 此查询仅对在中国大陆工信部进行过备案的域名有效。对于国外域名或未备案的域名，将查询不到结果。
         * @summary 查询域名ICP备案信息
         * @param {string} domain 需要查询的域名或URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkIcp(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNetworkIcp200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkIcp(domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworkApi.getNetworkIcp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想知道一个IP地址或域名来自地球的哪个角落？这个接口可以帮你定位它。你可以选择使用默认的GeoIP数据库，也可以指定 `source=commercial` 参数来查询更详细的商业级IP归属信息。  ## 功能概述 提供一个公网IPv4、IPv6地址或域名，我们会利用GeoIP数据库查询并返回它的地理位置（国家、省份、城市）、经纬度、以及所属的运营商（ISP）和自治系统（ASN）信息。这在网络安全分析、访问来源统计等领域非常有用。  当使用 `source=commercial` 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
         * @summary 查询指定IP或域名的归属信息
         * @param {string} ip 你需要查询的公网IP地址或域名（支持IPv4和IPv6）。
         * @param {GetNetworkIpinfoSourceEnum} [source] 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkIpinfo(ip: string, source?: GetNetworkIpinfoSourceEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNetworkIpinfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkIpinfo(ip, source, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworkApi.getNetworkIpinfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想知道你自己的出口公网IP是多少吗？这个接口就是你的“网络身份证”。你可以选择使用默认的GeoIP数据库，也可以指定 `source=commercial` 参数来查询更详细的商业级IP归属信息。  ## 功能概述 调用此接口，它会返回你（即发起请求的客户端）的公网IP地址，并附带与 `/network/ipinfo` 接口相同的地理位置和网络归属信息。非常适合用于在网页上向用户展示他们自己的IP和地理位置。  当使用 `source=commercial` 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
         * @summary 获取你的公网IP及归属信息
         * @param {GetNetworkMyipSourceEnum} [source] 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkMyip(source?: GetNetworkMyipSourceEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNetworkIpinfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkMyip(source, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworkApi.getNetworkMyip']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想知道从我们的服务器到你的服务器网络延迟高不高？这个工具可以帮你测试网络连通性。  ## 功能概述 这个接口会从我们的服务器节点对你指定的主机（域名或IP地址）执行 ICMP Ping 操作。它会返回最小、最大、平均延迟以及丢包率等关键指标，是诊断网络问题的得力助手。
         * @summary 从服务器Ping指定主机
         * @param {string} host 你需要 Ping 的目标主机，可以是域名或IP地址。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkPing(host: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNetworkPing200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkPing(host, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworkApi.getNetworkPing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 这是一个非常方便的快捷接口，想知道你的网络到我们服务器的回程延迟吗？点一下就行！  ## 功能概述 这个接口是 `/network/myip` 和 `/network/ping` 的结合体。它会自动获取你客户端的公网IP，然后从我们的服务器Ping这个IP，并返回延迟数据。这对于快速判断你本地网络到服务器的连接质量非常有用。
         * @summary 从服务器Ping你的客户端IP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkPingmyip(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNetworkPingmyip200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkPingmyip(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworkApi.getNetworkPingmyip']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想检查一下你的服务器上某个端口（比如SSH的22端口或者Web的80端口）是否对外开放？这个工具可以帮你快速确认。  ## 功能概述 你可以指定一个主机和端口号，我们的服务器会尝试连接该端口，并告诉你它是开放的（open）、关闭的（closed）还是超时了（timeout）。这对于网络服务配置检查和基本的安全扫描很有用。
         * @summary 扫描远程主机的指定端口
         * @param {string} host 需要扫描的目标主机，可以是域名或IP地址。
         * @param {number} port 需要扫描的端口号，范围是 1 到 65535。
         * @param {GetNetworkPortscanProtocolEnum} [protocol] 扫描使用的协议，可以是 \&#39;tcp\&#39; 或 \&#39;udp\&#39;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkPortscan(host: string, port: number, protocol?: GetNetworkPortscanProtocolEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNetworkPortscan200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkPortscan(host, port, protocol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworkApi.getNetworkPortscan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 你的网站或API还好吗？用这个接口给它做个快速“体检”吧。  ## 功能概述 提供一个URL，我们会向它发起一个请求，并返回其HTTP响应状态码。这是一种简单而有效的服务可用性监控方法。  > [!TIP] > **性能优化**：为了提高效率并减少对目标服务器的负载，我们实际发送的是 `HEAD` 请求，而不是 `GET` 请求。`HEAD` 请求只会获取响应头，而不会下载整个页面内容，因此速度更快。
         * @summary 检查URL的可访问性状态
         * @param {string} url 你需要检查其可访问性状态的完整URL。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkUrlstatus(url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNetworkUrlstatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkUrlstatus(url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworkApi.getNetworkUrlstatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想知道一个域名是什么时候注册的、注册商是谁、什么时候到期？WHOIS信息可以告诉你这一切。  ## 功能概述 这是一个在线的WHOIS查询工具。你可以通过如下两种方式获取WHOIS信息：  - **默认行为**（不带参数）：`GET /api/v1/network/whois?domain=google.com`   - 返回一个JSON对象，`whois` 字段为原始、未处理的WHOIS文本字符串。 - **JSON格式化**：`GET /api/v1/network/whois?domain=google.com&format=json`   - 返回一个JSON对象，`whois` 字段为解析后的JSON对象，包含WHOIS信息中的键值对。  这样你既可以获得最全的原始信息，也可以方便地处理结构化数据。
         * @summary 查询域名的WHOIS注册信息
         * @param {string} domain 你需要查询WHOIS信息的域名。
         * @param {GetNetworkWhoisFormatEnum} [format] 返回格式。留空或为 \&#39;text\&#39; 时返回原始WHOIS文本，设为 \&#39;json\&#39; 时返回结构化JSON。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkWhois(domain: string, format?: GetNetworkWhoisFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNetworkWhois200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkWhois(domain, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworkApi.getNetworkWhois']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 准备在微信里推广你的网站？最好先检查一下域名是否被“拉黑”了。  ## 功能概述 这个接口可以帮你查询一个域名在微信内置浏览器中的访问状态，即是否被微信封禁。这对于做微信生态推广和营销的开发者来说至关重要。
         * @summary 检查域名在微信中的访问状态
         * @param {string} domain 需要查询的域名。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkWxdomain(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNetworkWxdomain200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkWxdomain(domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworkApi.getNetworkWxdomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NetworkApi - factory interface
 */
export const NetworkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkApiFp(configuration)
    return {
        /**
         * 想知道一个域名指向了哪个IP？或者它的邮件服务器是谁？这个接口就像一个在线的 `dig` 或 `nslookup` 工具。  ## 功能概述 你可以查询指定域名的各种DNS记录，包括 `A` (IPv4), `AAAA` (IPv6), `CNAME` (别名), `MX` (邮件交换), `NS` (域名服务器) 和 `TXT` (文本记录)。
         * @summary 执行DNS解析查询
         * @param {string} domain 你需要查询的域名，例如 \&#39;cn.bing.com\&#39;。
         * @param {GetNetworkDnsTypeEnum} [type] 你想要查询的DNS记录类型。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkDns(domain: string, type?: GetNetworkDnsTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetNetworkDns200Response> {
            return localVarFp.getNetworkDns(domain, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 想知道一个网站的背后运营主体是谁吗？如果它是在中国大陆运营的，ICP备案信息可以告诉你答案。  ## 功能概述 提供一个域名，查询其在中国工信部的ICP（Internet Content Provider）备案信息。这对于商业合作前的背景调查、验证网站合法性等场景很有帮助。  > [!NOTE] > **查询范围** > 此查询仅对在中国大陆工信部进行过备案的域名有效。对于国外域名或未备案的域名，将查询不到结果。
         * @summary 查询域名ICP备案信息
         * @param {string} domain 需要查询的域名或URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkIcp(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<GetNetworkIcp200Response> {
            return localVarFp.getNetworkIcp(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * 想知道一个IP地址或域名来自地球的哪个角落？这个接口可以帮你定位它。你可以选择使用默认的GeoIP数据库，也可以指定 `source=commercial` 参数来查询更详细的商业级IP归属信息。  ## 功能概述 提供一个公网IPv4、IPv6地址或域名，我们会利用GeoIP数据库查询并返回它的地理位置（国家、省份、城市）、经纬度、以及所属的运营商（ISP）和自治系统（ASN）信息。这在网络安全分析、访问来源统计等领域非常有用。  当使用 `source=commercial` 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
         * @summary 查询指定IP或域名的归属信息
         * @param {string} ip 你需要查询的公网IP地址或域名（支持IPv4和IPv6）。
         * @param {GetNetworkIpinfoSourceEnum} [source] 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkIpinfo(ip: string, source?: GetNetworkIpinfoSourceEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetNetworkIpinfo200Response> {
            return localVarFp.getNetworkIpinfo(ip, source, options).then((request) => request(axios, basePath));
        },
        /**
         * 想知道你自己的出口公网IP是多少吗？这个接口就是你的“网络身份证”。你可以选择使用默认的GeoIP数据库，也可以指定 `source=commercial` 参数来查询更详细的商业级IP归属信息。  ## 功能概述 调用此接口，它会返回你（即发起请求的客户端）的公网IP地址，并附带与 `/network/ipinfo` 接口相同的地理位置和网络归属信息。非常适合用于在网页上向用户展示他们自己的IP和地理位置。  当使用 `source=commercial` 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
         * @summary 获取你的公网IP及归属信息
         * @param {GetNetworkMyipSourceEnum} [source] 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkMyip(source?: GetNetworkMyipSourceEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetNetworkIpinfo200Response> {
            return localVarFp.getNetworkMyip(source, options).then((request) => request(axios, basePath));
        },
        /**
         * 想知道从我们的服务器到你的服务器网络延迟高不高？这个工具可以帮你测试网络连通性。  ## 功能概述 这个接口会从我们的服务器节点对你指定的主机（域名或IP地址）执行 ICMP Ping 操作。它会返回最小、最大、平均延迟以及丢包率等关键指标，是诊断网络问题的得力助手。
         * @summary 从服务器Ping指定主机
         * @param {string} host 你需要 Ping 的目标主机，可以是域名或IP地址。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkPing(host: string, options?: RawAxiosRequestConfig): AxiosPromise<GetNetworkPing200Response> {
            return localVarFp.getNetworkPing(host, options).then((request) => request(axios, basePath));
        },
        /**
         * 这是一个非常方便的快捷接口，想知道你的网络到我们服务器的回程延迟吗？点一下就行！  ## 功能概述 这个接口是 `/network/myip` 和 `/network/ping` 的结合体。它会自动获取你客户端的公网IP，然后从我们的服务器Ping这个IP，并返回延迟数据。这对于快速判断你本地网络到服务器的连接质量非常有用。
         * @summary 从服务器Ping你的客户端IP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkPingmyip(options?: RawAxiosRequestConfig): AxiosPromise<GetNetworkPingmyip200Response> {
            return localVarFp.getNetworkPingmyip(options).then((request) => request(axios, basePath));
        },
        /**
         * 想检查一下你的服务器上某个端口（比如SSH的22端口或者Web的80端口）是否对外开放？这个工具可以帮你快速确认。  ## 功能概述 你可以指定一个主机和端口号，我们的服务器会尝试连接该端口，并告诉你它是开放的（open）、关闭的（closed）还是超时了（timeout）。这对于网络服务配置检查和基本的安全扫描很有用。
         * @summary 扫描远程主机的指定端口
         * @param {string} host 需要扫描的目标主机，可以是域名或IP地址。
         * @param {number} port 需要扫描的端口号，范围是 1 到 65535。
         * @param {GetNetworkPortscanProtocolEnum} [protocol] 扫描使用的协议，可以是 \&#39;tcp\&#39; 或 \&#39;udp\&#39;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkPortscan(host: string, port: number, protocol?: GetNetworkPortscanProtocolEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetNetworkPortscan200Response> {
            return localVarFp.getNetworkPortscan(host, port, protocol, options).then((request) => request(axios, basePath));
        },
        /**
         * 你的网站或API还好吗？用这个接口给它做个快速“体检”吧。  ## 功能概述 提供一个URL，我们会向它发起一个请求，并返回其HTTP响应状态码。这是一种简单而有效的服务可用性监控方法。  > [!TIP] > **性能优化**：为了提高效率并减少对目标服务器的负载，我们实际发送的是 `HEAD` 请求，而不是 `GET` 请求。`HEAD` 请求只会获取响应头，而不会下载整个页面内容，因此速度更快。
         * @summary 检查URL的可访问性状态
         * @param {string} url 你需要检查其可访问性状态的完整URL。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkUrlstatus(url: string, options?: RawAxiosRequestConfig): AxiosPromise<GetNetworkUrlstatus200Response> {
            return localVarFp.getNetworkUrlstatus(url, options).then((request) => request(axios, basePath));
        },
        /**
         * 想知道一个域名是什么时候注册的、注册商是谁、什么时候到期？WHOIS信息可以告诉你这一切。  ## 功能概述 这是一个在线的WHOIS查询工具。你可以通过如下两种方式获取WHOIS信息：  - **默认行为**（不带参数）：`GET /api/v1/network/whois?domain=google.com`   - 返回一个JSON对象，`whois` 字段为原始、未处理的WHOIS文本字符串。 - **JSON格式化**：`GET /api/v1/network/whois?domain=google.com&format=json`   - 返回一个JSON对象，`whois` 字段为解析后的JSON对象，包含WHOIS信息中的键值对。  这样你既可以获得最全的原始信息，也可以方便地处理结构化数据。
         * @summary 查询域名的WHOIS注册信息
         * @param {string} domain 你需要查询WHOIS信息的域名。
         * @param {GetNetworkWhoisFormatEnum} [format] 返回格式。留空或为 \&#39;text\&#39; 时返回原始WHOIS文本，设为 \&#39;json\&#39; 时返回结构化JSON。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkWhois(domain: string, format?: GetNetworkWhoisFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetNetworkWhois200Response> {
            return localVarFp.getNetworkWhois(domain, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 准备在微信里推广你的网站？最好先检查一下域名是否被“拉黑”了。  ## 功能概述 这个接口可以帮你查询一个域名在微信内置浏览器中的访问状态，即是否被微信封禁。这对于做微信生态推广和营销的开发者来说至关重要。
         * @summary 检查域名在微信中的访问状态
         * @param {string} domain 需要查询的域名。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkWxdomain(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<GetNetworkWxdomain200Response> {
            return localVarFp.getNetworkWxdomain(domain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkApi - object-oriented interface
 */
export class NetworkApi extends BaseAPI {
    /**
     * 想知道一个域名指向了哪个IP？或者它的邮件服务器是谁？这个接口就像一个在线的 `dig` 或 `nslookup` 工具。  ## 功能概述 你可以查询指定域名的各种DNS记录，包括 `A` (IPv4), `AAAA` (IPv6), `CNAME` (别名), `MX` (邮件交换), `NS` (域名服务器) 和 `TXT` (文本记录)。
     * @summary 执行DNS解析查询
     * @param {string} domain 你需要查询的域名，例如 \&#39;cn.bing.com\&#39;。
     * @param {GetNetworkDnsTypeEnum} [type] 你想要查询的DNS记录类型。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNetworkDns(domain: string, type?: GetNetworkDnsTypeEnum, options?: RawAxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getNetworkDns(domain, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想知道一个网站的背后运营主体是谁吗？如果它是在中国大陆运营的，ICP备案信息可以告诉你答案。  ## 功能概述 提供一个域名，查询其在中国工信部的ICP（Internet Content Provider）备案信息。这对于商业合作前的背景调查、验证网站合法性等场景很有帮助。  > [!NOTE] > **查询范围** > 此查询仅对在中国大陆工信部进行过备案的域名有效。对于国外域名或未备案的域名，将查询不到结果。
     * @summary 查询域名ICP备案信息
     * @param {string} domain 需要查询的域名或URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNetworkIcp(domain: string, options?: RawAxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getNetworkIcp(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想知道一个IP地址或域名来自地球的哪个角落？这个接口可以帮你定位它。你可以选择使用默认的GeoIP数据库，也可以指定 `source=commercial` 参数来查询更详细的商业级IP归属信息。  ## 功能概述 提供一个公网IPv4、IPv6地址或域名，我们会利用GeoIP数据库查询并返回它的地理位置（国家、省份、城市）、经纬度、以及所属的运营商（ISP）和自治系统（ASN）信息。这在网络安全分析、访问来源统计等领域非常有用。  当使用 `source=commercial` 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
     * @summary 查询指定IP或域名的归属信息
     * @param {string} ip 你需要查询的公网IP地址或域名（支持IPv4和IPv6）。
     * @param {GetNetworkIpinfoSourceEnum} [source] 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNetworkIpinfo(ip: string, source?: GetNetworkIpinfoSourceEnum, options?: RawAxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getNetworkIpinfo(ip, source, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想知道你自己的出口公网IP是多少吗？这个接口就是你的“网络身份证”。你可以选择使用默认的GeoIP数据库，也可以指定 `source=commercial` 参数来查询更详细的商业级IP归属信息。  ## 功能概述 调用此接口，它会返回你（即发起请求的客户端）的公网IP地址，并附带与 `/network/ipinfo` 接口相同的地理位置和网络归属信息。非常适合用于在网页上向用户展示他们自己的IP和地理位置。  当使用 `source=commercial` 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
     * @summary 获取你的公网IP及归属信息
     * @param {GetNetworkMyipSourceEnum} [source] 查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNetworkMyip(source?: GetNetworkMyipSourceEnum, options?: RawAxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getNetworkMyip(source, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想知道从我们的服务器到你的服务器网络延迟高不高？这个工具可以帮你测试网络连通性。  ## 功能概述 这个接口会从我们的服务器节点对你指定的主机（域名或IP地址）执行 ICMP Ping 操作。它会返回最小、最大、平均延迟以及丢包率等关键指标，是诊断网络问题的得力助手。
     * @summary 从服务器Ping指定主机
     * @param {string} host 你需要 Ping 的目标主机，可以是域名或IP地址。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNetworkPing(host: string, options?: RawAxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getNetworkPing(host, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 这是一个非常方便的快捷接口，想知道你的网络到我们服务器的回程延迟吗？点一下就行！  ## 功能概述 这个接口是 `/network/myip` 和 `/network/ping` 的结合体。它会自动获取你客户端的公网IP，然后从我们的服务器Ping这个IP，并返回延迟数据。这对于快速判断你本地网络到服务器的连接质量非常有用。
     * @summary 从服务器Ping你的客户端IP
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNetworkPingmyip(options?: RawAxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getNetworkPingmyip(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想检查一下你的服务器上某个端口（比如SSH的22端口或者Web的80端口）是否对外开放？这个工具可以帮你快速确认。  ## 功能概述 你可以指定一个主机和端口号，我们的服务器会尝试连接该端口，并告诉你它是开放的（open）、关闭的（closed）还是超时了（timeout）。这对于网络服务配置检查和基本的安全扫描很有用。
     * @summary 扫描远程主机的指定端口
     * @param {string} host 需要扫描的目标主机，可以是域名或IP地址。
     * @param {number} port 需要扫描的端口号，范围是 1 到 65535。
     * @param {GetNetworkPortscanProtocolEnum} [protocol] 扫描使用的协议，可以是 \&#39;tcp\&#39; 或 \&#39;udp\&#39;。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNetworkPortscan(host: string, port: number, protocol?: GetNetworkPortscanProtocolEnum, options?: RawAxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getNetworkPortscan(host, port, protocol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 你的网站或API还好吗？用这个接口给它做个快速“体检”吧。  ## 功能概述 提供一个URL，我们会向它发起一个请求，并返回其HTTP响应状态码。这是一种简单而有效的服务可用性监控方法。  > [!TIP] > **性能优化**：为了提高效率并减少对目标服务器的负载，我们实际发送的是 `HEAD` 请求，而不是 `GET` 请求。`HEAD` 请求只会获取响应头，而不会下载整个页面内容，因此速度更快。
     * @summary 检查URL的可访问性状态
     * @param {string} url 你需要检查其可访问性状态的完整URL。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNetworkUrlstatus(url: string, options?: RawAxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getNetworkUrlstatus(url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想知道一个域名是什么时候注册的、注册商是谁、什么时候到期？WHOIS信息可以告诉你这一切。  ## 功能概述 这是一个在线的WHOIS查询工具。你可以通过如下两种方式获取WHOIS信息：  - **默认行为**（不带参数）：`GET /api/v1/network/whois?domain=google.com`   - 返回一个JSON对象，`whois` 字段为原始、未处理的WHOIS文本字符串。 - **JSON格式化**：`GET /api/v1/network/whois?domain=google.com&format=json`   - 返回一个JSON对象，`whois` 字段为解析后的JSON对象，包含WHOIS信息中的键值对。  这样你既可以获得最全的原始信息，也可以方便地处理结构化数据。
     * @summary 查询域名的WHOIS注册信息
     * @param {string} domain 你需要查询WHOIS信息的域名。
     * @param {GetNetworkWhoisFormatEnum} [format] 返回格式。留空或为 \&#39;text\&#39; 时返回原始WHOIS文本，设为 \&#39;json\&#39; 时返回结构化JSON。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNetworkWhois(domain: string, format?: GetNetworkWhoisFormatEnum, options?: RawAxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getNetworkWhois(domain, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 准备在微信里推广你的网站？最好先检查一下域名是否被“拉黑”了。  ## 功能概述 这个接口可以帮你查询一个域名在微信内置浏览器中的访问状态，即是否被微信封禁。这对于做微信生态推广和营销的开发者来说至关重要。
     * @summary 检查域名在微信中的访问状态
     * @param {string} domain 需要查询的域名。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNetworkWxdomain(domain: string, options?: RawAxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getNetworkWxdomain(domain, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetNetworkDnsTypeEnum = {
    A: 'A',
    Aaaa: 'AAAA',
    Cname: 'CNAME',
    Mx: 'MX',
    Ns: 'NS',
    Txt: 'TXT'
} as const;
export type GetNetworkDnsTypeEnum = typeof GetNetworkDnsTypeEnum[keyof typeof GetNetworkDnsTypeEnum];
export const GetNetworkIpinfoSourceEnum = {
    Commercial: 'commercial'
} as const;
export type GetNetworkIpinfoSourceEnum = typeof GetNetworkIpinfoSourceEnum[keyof typeof GetNetworkIpinfoSourceEnum];
export const GetNetworkMyipSourceEnum = {
    Commercial: 'commercial'
} as const;
export type GetNetworkMyipSourceEnum = typeof GetNetworkMyipSourceEnum[keyof typeof GetNetworkMyipSourceEnum];
export const GetNetworkPortscanProtocolEnum = {
    Tcp: 'tcp',
    Udp: 'udp'
} as const;
export type GetNetworkPortscanProtocolEnum = typeof GetNetworkPortscanProtocolEnum[keyof typeof GetNetworkPortscanProtocolEnum];
export const GetNetworkWhoisFormatEnum = {
    Text: 'text',
    Json: 'json'
} as const;
export type GetNetworkWhoisFormatEnum = typeof GetNetworkWhoisFormatEnum[keyof typeof GetNetworkWhoisFormatEnum];


/**
 * PoemApi - axios parameter creator
 */
export const PoemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 想在你的应用里每天展示一句不一样的话，给用户一点小小的惊喜吗？这个“一言”接口就是为此而生。  ## 功能概述 每次调用，它都会从我们精心收集的、包含数千条诗词、动漫台词、名人名言的语料库中，随机返回一条。你可以用它来做网站首页的Slogan、应用的启动语，或者任何需要灵感点缀的地方。
         * @summary 随机获取一句诗词或名言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSaying: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saying`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoemApi - functional programming interface
 */
export const PoemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoemApiAxiosParamCreator(configuration)
    return {
        /**
         * 想在你的应用里每天展示一句不一样的话，给用户一点小小的惊喜吗？这个“一言”接口就是为此而生。  ## 功能概述 每次调用，它都会从我们精心收集的、包含数千条诗词、动漫台词、名人名言的语料库中，随机返回一条。你可以用它来做网站首页的Slogan、应用的启动语，或者任何需要灵感点缀的地方。
         * @summary 随机获取一句诗词或名言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSaying(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSaying200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSaying(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoemApi.getSaying']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PoemApi - factory interface
 */
export const PoemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoemApiFp(configuration)
    return {
        /**
         * 想在你的应用里每天展示一句不一样的话，给用户一点小小的惊喜吗？这个“一言”接口就是为此而生。  ## 功能概述 每次调用，它都会从我们精心收集的、包含数千条诗词、动漫台词、名人名言的语料库中，随机返回一条。你可以用它来做网站首页的Slogan、应用的启动语，或者任何需要灵感点缀的地方。
         * @summary 随机获取一句诗词或名言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSaying(options?: RawAxiosRequestConfig): AxiosPromise<GetSaying200Response> {
            return localVarFp.getSaying(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoemApi - object-oriented interface
 */
export class PoemApi extends BaseAPI {
    /**
     * 想在你的应用里每天展示一句不一样的话，给用户一点小小的惊喜吗？这个“一言”接口就是为此而生。  ## 功能概述 每次调用，它都会从我们精心收集的、包含数千条诗词、动漫台词、名人名言的语料库中，随机返回一条。你可以用它来做网站首页的Slogan、应用的启动语，或者任何需要灵感点缀的地方。
     * @summary 随机获取一句诗词或名言
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSaying(options?: RawAxiosRequestConfig) {
        return PoemApiFp(this.configuration).getSaying(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RandomApi - axios parameter creator
 */
export const RandomApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 想要获得人生问题的神秘答案吗？答案之书API提供了一个神奇8球风格的问答服务，你可以提问并获得随机的神秘答案。  ## 功能概述 通过向答案之书提问，你将获得一个充满智慧（或许）的随机答案。这个API支持通过查询参数或POST请求体两种方式提问。  ## 使用须知  > [!TIP] > **提问技巧** > - 提出明确的问题会获得更好的体验 > - 问题不能为空 > - 支持中文问题 > - 答案具有随机性，仅供娱乐参考
         * @summary 获取答案之书的神秘答案 (GET)
         * @param {string} question 你想要提问的问题。问题不能为空。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnswerbookAsk: async (question: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'question' is not null or undefined
            assertParamExists('getAnswerbookAsk', 'question', question)
            const localVarPath = `/answerbook/ask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (question !== undefined) {
                localVarQueryParameter['question'] = question;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 需要一张随机图片作为占位符或者背景吗？这个接口是你的不二之选。  ## 功能概述 这是一个非常简单的接口，它会从我们庞大的图库和精选外部图床中随机挑选一张图片，然后通过 302 重定向让你直接访问到它。这使得它可以非常方便地直接用在 HTML 的 `<img>` 标签中。  你可以通过 `/api/v1/random/image?category=acg&type=4k` 这样的请求获取由UapiPro服务器提供的图片，也可以通过 `/api/v1/random/image?category=ai_drawing` 获取由外部图床精选的图片。  如果你不提供任何 category 参数，程序会从所有图片（包括本地的和URL的）中随机抽取一张（**全局随机图片不包含ikun和AI绘画**）。  > [!TIP] > 如果你需要更精确地控制图片类型，请使用 `/image/random/{category}/{type}` 接口。  ### 支持的主类别与子类别 - **UapiPro服务器图片**   - **furry**（福瑞）     - z4k     - szs8k     - s4k     - 4k   - **bq**（表情包/趣图）     - youshou     - xiongmao     - waiguoren     - maomao     - ikun     - eciyuan   - **acg**（二次元动漫）     - pc     - mb - **外部图床精选图片**   - **ai_drawing**: AI绘画。   - **general_anime**: 动漫图。   - **landscape**: 风景图。   - **mobile_wallpaper**: 手机壁纸。   - **pc_wallpaper**: 电脑壁纸。 - **混合动漫**   - **anime**: 混合了UapiPro服务器的acg和外部图床的general_anime分类下的图片。  > [!NOTE] > 默认全局随机（未指定category参数）时，不会包含ikun和AI绘画（ai_drawing）类别的图片。 
         * @summary 随机二次元、风景、动漫图片壁纸
         * @param {GetRandomImageCategoryEnum} [category] （可选）指定图片主类别。  **支持的主类别：** - &#x60;furry&#x60;（福瑞，UapiPro服务器） - &#x60;bq&#x60;（表情包/趣图，UapiPro服务器） - &#x60;acg&#x60;（二次元动漫，UapiPro服务器） - &#x60;ai_drawing&#x60;（AI绘画，外部图床） - &#x60;general_anime&#x60;（动漫图，外部图床） - &#x60;landscape&#x60;（风景图，外部图床） - &#x60;mobile_wallpaper&#x60;（手机壁纸，外部图床） - &#x60;pc_wallpaper&#x60;（电脑壁纸，外部图床） - &#x60;anime&#x60;（混合动漫，UapiPro服务器acg + 外部图床general_anime）  &gt; [!TIP] &gt; 如果不指定，将从所有图片中随机抽取（不包含 &#x60;ikun&#x60; 和 &#x60;ai_drawing&#x60;）。 
         * @param {GetRandomImageTypeEnum} [type] （可选，仅UapiPro服务器图片支持）指定图片子类别。  - **furry**: &#x60;z4k&#x60;, &#x60;szs8k&#x60;, &#x60;s4k&#x60;, &#x60;4k&#x60; - **bq**: &#x60;youshou&#x60;, &#x60;xiongmao&#x60;, &#x60;waiguoren&#x60;, &#x60;maomao&#x60;, &#x60;ikun&#x60;, &#x60;eciyuan&#x60; - **acg**: &#x60;pc&#x60;, &#x60;mb&#x60;  &gt; [!TIP] &gt; 外部图床类别和 &#x60;anime&#x60; 混合类别不支持 &#x60;type&#x60; 参数。 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomImage: async (category?: GetRandomImageCategoryEnum, type?: GetRandomImageTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/random/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 无论是需要生成一个安全的随机密码、一个唯一的Token，还是一个简单的随机ID，这个接口都能满足你。  ## 功能概述 你可以精确地控制生成字符串的长度和字符集类型，非常灵活。  ## 使用须知  > [!TIP] > **字符集类型 `type` 详解** > 你可以通过 `type` 参数精确控制生成的字符集： > - **`numeric`**: 纯数字 (0-9) > - **`lower`**: 纯小写字母 (a-z) > - **`upper`**: 纯大写字母 (A-Z) > - **`alpha`**: 大小写字母 (a-zA-Z) > - **`alphanumeric`** (默认): 数字和大小写字母 (0-9a-zA-Z) > - **`hex`**: 十六进制字符 (0-9a-f)
         * @summary 生成高度可定制的随机字符串
         * @param {number} [length] 你希望生成的字符串的长度。有效范围是 1 到 1024。
         * @param {GetRandomStringTypeEnum} [type] 指定构成字符串的字符类型。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomString: async (length?: number, type?: GetRandomStringTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/random/string`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 通过POST请求向答案之书提问并获得神秘答案。  ## 功能概述 与GET方式相同，但通过JSON请求体发送问题，适合在需要发送较长问题或希望避免URL编码问题的场景中使用。  ## 请求体格式 请求体必须是有效的JSON格式，包含question字段。
         * @summary 获取答案之书的神秘答案 (POST)
         * @param {PostAnswerbookAskRequest} postAnswerbookAskRequest 包含问题的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAnswerbookAsk: async (postAnswerbookAskRequest: PostAnswerbookAskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postAnswerbookAskRequest' is not null or undefined
            assertParamExists('postAnswerbookAsk', 'postAnswerbookAskRequest', postAnswerbookAskRequest)
            const localVarPath = `/answerbook/ask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAnswerbookAskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RandomApi - functional programming interface
 */
export const RandomApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RandomApiAxiosParamCreator(configuration)
    return {
        /**
         * 想要获得人生问题的神秘答案吗？答案之书API提供了一个神奇8球风格的问答服务，你可以提问并获得随机的神秘答案。  ## 功能概述 通过向答案之书提问，你将获得一个充满智慧（或许）的随机答案。这个API支持通过查询参数或POST请求体两种方式提问。  ## 使用须知  > [!TIP] > **提问技巧** > - 提出明确的问题会获得更好的体验 > - 问题不能为空 > - 支持中文问题 > - 答案具有随机性，仅供娱乐参考
         * @summary 获取答案之书的神秘答案 (GET)
         * @param {string} question 你想要提问的问题。问题不能为空。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnswerbookAsk(question: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAnswerbookAsk200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnswerbookAsk(question, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RandomApi.getAnswerbookAsk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 需要一张随机图片作为占位符或者背景吗？这个接口是你的不二之选。  ## 功能概述 这是一个非常简单的接口，它会从我们庞大的图库和精选外部图床中随机挑选一张图片，然后通过 302 重定向让你直接访问到它。这使得它可以非常方便地直接用在 HTML 的 `<img>` 标签中。  你可以通过 `/api/v1/random/image?category=acg&type=4k` 这样的请求获取由UapiPro服务器提供的图片，也可以通过 `/api/v1/random/image?category=ai_drawing` 获取由外部图床精选的图片。  如果你不提供任何 category 参数，程序会从所有图片（包括本地的和URL的）中随机抽取一张（**全局随机图片不包含ikun和AI绘画**）。  > [!TIP] > 如果你需要更精确地控制图片类型，请使用 `/image/random/{category}/{type}` 接口。  ### 支持的主类别与子类别 - **UapiPro服务器图片**   - **furry**（福瑞）     - z4k     - szs8k     - s4k     - 4k   - **bq**（表情包/趣图）     - youshou     - xiongmao     - waiguoren     - maomao     - ikun     - eciyuan   - **acg**（二次元动漫）     - pc     - mb - **外部图床精选图片**   - **ai_drawing**: AI绘画。   - **general_anime**: 动漫图。   - **landscape**: 风景图。   - **mobile_wallpaper**: 手机壁纸。   - **pc_wallpaper**: 电脑壁纸。 - **混合动漫**   - **anime**: 混合了UapiPro服务器的acg和外部图床的general_anime分类下的图片。  > [!NOTE] > 默认全局随机（未指定category参数）时，不会包含ikun和AI绘画（ai_drawing）类别的图片。 
         * @summary 随机二次元、风景、动漫图片壁纸
         * @param {GetRandomImageCategoryEnum} [category] （可选）指定图片主类别。  **支持的主类别：** - &#x60;furry&#x60;（福瑞，UapiPro服务器） - &#x60;bq&#x60;（表情包/趣图，UapiPro服务器） - &#x60;acg&#x60;（二次元动漫，UapiPro服务器） - &#x60;ai_drawing&#x60;（AI绘画，外部图床） - &#x60;general_anime&#x60;（动漫图，外部图床） - &#x60;landscape&#x60;（风景图，外部图床） - &#x60;mobile_wallpaper&#x60;（手机壁纸，外部图床） - &#x60;pc_wallpaper&#x60;（电脑壁纸，外部图床） - &#x60;anime&#x60;（混合动漫，UapiPro服务器acg + 外部图床general_anime）  &gt; [!TIP] &gt; 如果不指定，将从所有图片中随机抽取（不包含 &#x60;ikun&#x60; 和 &#x60;ai_drawing&#x60;）。 
         * @param {GetRandomImageTypeEnum} [type] （可选，仅UapiPro服务器图片支持）指定图片子类别。  - **furry**: &#x60;z4k&#x60;, &#x60;szs8k&#x60;, &#x60;s4k&#x60;, &#x60;4k&#x60; - **bq**: &#x60;youshou&#x60;, &#x60;xiongmao&#x60;, &#x60;waiguoren&#x60;, &#x60;maomao&#x60;, &#x60;ikun&#x60;, &#x60;eciyuan&#x60; - **acg**: &#x60;pc&#x60;, &#x60;mb&#x60;  &gt; [!TIP] &gt; 外部图床类别和 &#x60;anime&#x60; 混合类别不支持 &#x60;type&#x60; 参数。 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandomImage(category?: GetRandomImageCategoryEnum, type?: GetRandomImageTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandomImage(category, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RandomApi.getRandomImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 无论是需要生成一个安全的随机密码、一个唯一的Token，还是一个简单的随机ID，这个接口都能满足你。  ## 功能概述 你可以精确地控制生成字符串的长度和字符集类型，非常灵活。  ## 使用须知  > [!TIP] > **字符集类型 `type` 详解** > 你可以通过 `type` 参数精确控制生成的字符集： > - **`numeric`**: 纯数字 (0-9) > - **`lower`**: 纯小写字母 (a-z) > - **`upper`**: 纯大写字母 (A-Z) > - **`alpha`**: 大小写字母 (a-zA-Z) > - **`alphanumeric`** (默认): 数字和大小写字母 (0-9a-zA-Z) > - **`hex`**: 十六进制字符 (0-9a-f)
         * @summary 生成高度可定制的随机字符串
         * @param {number} [length] 你希望生成的字符串的长度。有效范围是 1 到 1024。
         * @param {GetRandomStringTypeEnum} [type] 指定构成字符串的字符类型。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandomString(length?: number, type?: GetRandomStringTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRandomString200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandomString(length, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RandomApi.getRandomString']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 通过POST请求向答案之书提问并获得神秘答案。  ## 功能概述 与GET方式相同，但通过JSON请求体发送问题，适合在需要发送较长问题或希望避免URL编码问题的场景中使用。  ## 请求体格式 请求体必须是有效的JSON格式，包含question字段。
         * @summary 获取答案之书的神秘答案 (POST)
         * @param {PostAnswerbookAskRequest} postAnswerbookAskRequest 包含问题的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAnswerbookAsk(postAnswerbookAskRequest: PostAnswerbookAskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostAnswerbookAsk200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAnswerbookAsk(postAnswerbookAskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RandomApi.postAnswerbookAsk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RandomApi - factory interface
 */
export const RandomApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RandomApiFp(configuration)
    return {
        /**
         * 想要获得人生问题的神秘答案吗？答案之书API提供了一个神奇8球风格的问答服务，你可以提问并获得随机的神秘答案。  ## 功能概述 通过向答案之书提问，你将获得一个充满智慧（或许）的随机答案。这个API支持通过查询参数或POST请求体两种方式提问。  ## 使用须知  > [!TIP] > **提问技巧** > - 提出明确的问题会获得更好的体验 > - 问题不能为空 > - 支持中文问题 > - 答案具有随机性，仅供娱乐参考
         * @summary 获取答案之书的神秘答案 (GET)
         * @param {string} question 你想要提问的问题。问题不能为空。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnswerbookAsk(question: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAnswerbookAsk200Response> {
            return localVarFp.getAnswerbookAsk(question, options).then((request) => request(axios, basePath));
        },
        /**
         * 需要一张随机图片作为占位符或者背景吗？这个接口是你的不二之选。  ## 功能概述 这是一个非常简单的接口，它会从我们庞大的图库和精选外部图床中随机挑选一张图片，然后通过 302 重定向让你直接访问到它。这使得它可以非常方便地直接用在 HTML 的 `<img>` 标签中。  你可以通过 `/api/v1/random/image?category=acg&type=4k` 这样的请求获取由UapiPro服务器提供的图片，也可以通过 `/api/v1/random/image?category=ai_drawing` 获取由外部图床精选的图片。  如果你不提供任何 category 参数，程序会从所有图片（包括本地的和URL的）中随机抽取一张（**全局随机图片不包含ikun和AI绘画**）。  > [!TIP] > 如果你需要更精确地控制图片类型，请使用 `/image/random/{category}/{type}` 接口。  ### 支持的主类别与子类别 - **UapiPro服务器图片**   - **furry**（福瑞）     - z4k     - szs8k     - s4k     - 4k   - **bq**（表情包/趣图）     - youshou     - xiongmao     - waiguoren     - maomao     - ikun     - eciyuan   - **acg**（二次元动漫）     - pc     - mb - **外部图床精选图片**   - **ai_drawing**: AI绘画。   - **general_anime**: 动漫图。   - **landscape**: 风景图。   - **mobile_wallpaper**: 手机壁纸。   - **pc_wallpaper**: 电脑壁纸。 - **混合动漫**   - **anime**: 混合了UapiPro服务器的acg和外部图床的general_anime分类下的图片。  > [!NOTE] > 默认全局随机（未指定category参数）时，不会包含ikun和AI绘画（ai_drawing）类别的图片。 
         * @summary 随机二次元、风景、动漫图片壁纸
         * @param {GetRandomImageCategoryEnum} [category] （可选）指定图片主类别。  **支持的主类别：** - &#x60;furry&#x60;（福瑞，UapiPro服务器） - &#x60;bq&#x60;（表情包/趣图，UapiPro服务器） - &#x60;acg&#x60;（二次元动漫，UapiPro服务器） - &#x60;ai_drawing&#x60;（AI绘画，外部图床） - &#x60;general_anime&#x60;（动漫图，外部图床） - &#x60;landscape&#x60;（风景图，外部图床） - &#x60;mobile_wallpaper&#x60;（手机壁纸，外部图床） - &#x60;pc_wallpaper&#x60;（电脑壁纸，外部图床） - &#x60;anime&#x60;（混合动漫，UapiPro服务器acg + 外部图床general_anime）  &gt; [!TIP] &gt; 如果不指定，将从所有图片中随机抽取（不包含 &#x60;ikun&#x60; 和 &#x60;ai_drawing&#x60;）。 
         * @param {GetRandomImageTypeEnum} [type] （可选，仅UapiPro服务器图片支持）指定图片子类别。  - **furry**: &#x60;z4k&#x60;, &#x60;szs8k&#x60;, &#x60;s4k&#x60;, &#x60;4k&#x60; - **bq**: &#x60;youshou&#x60;, &#x60;xiongmao&#x60;, &#x60;waiguoren&#x60;, &#x60;maomao&#x60;, &#x60;ikun&#x60;, &#x60;eciyuan&#x60; - **acg**: &#x60;pc&#x60;, &#x60;mb&#x60;  &gt; [!TIP] &gt; 外部图床类别和 &#x60;anime&#x60; 混合类别不支持 &#x60;type&#x60; 参数。 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomImage(category?: GetRandomImageCategoryEnum, type?: GetRandomImageTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getRandomImage(category, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 无论是需要生成一个安全的随机密码、一个唯一的Token，还是一个简单的随机ID，这个接口都能满足你。  ## 功能概述 你可以精确地控制生成字符串的长度和字符集类型，非常灵活。  ## 使用须知  > [!TIP] > **字符集类型 `type` 详解** > 你可以通过 `type` 参数精确控制生成的字符集： > - **`numeric`**: 纯数字 (0-9) > - **`lower`**: 纯小写字母 (a-z) > - **`upper`**: 纯大写字母 (A-Z) > - **`alpha`**: 大小写字母 (a-zA-Z) > - **`alphanumeric`** (默认): 数字和大小写字母 (0-9a-zA-Z) > - **`hex`**: 十六进制字符 (0-9a-f)
         * @summary 生成高度可定制的随机字符串
         * @param {number} [length] 你希望生成的字符串的长度。有效范围是 1 到 1024。
         * @param {GetRandomStringTypeEnum} [type] 指定构成字符串的字符类型。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomString(length?: number, type?: GetRandomStringTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetRandomString200Response> {
            return localVarFp.getRandomString(length, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 通过POST请求向答案之书提问并获得神秘答案。  ## 功能概述 与GET方式相同，但通过JSON请求体发送问题，适合在需要发送较长问题或希望避免URL编码问题的场景中使用。  ## 请求体格式 请求体必须是有效的JSON格式，包含question字段。
         * @summary 获取答案之书的神秘答案 (POST)
         * @param {PostAnswerbookAskRequest} postAnswerbookAskRequest 包含问题的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAnswerbookAsk(postAnswerbookAskRequest: PostAnswerbookAskRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostAnswerbookAsk200Response> {
            return localVarFp.postAnswerbookAsk(postAnswerbookAskRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RandomApi - object-oriented interface
 */
export class RandomApi extends BaseAPI {
    /**
     * 想要获得人生问题的神秘答案吗？答案之书API提供了一个神奇8球风格的问答服务，你可以提问并获得随机的神秘答案。  ## 功能概述 通过向答案之书提问，你将获得一个充满智慧（或许）的随机答案。这个API支持通过查询参数或POST请求体两种方式提问。  ## 使用须知  > [!TIP] > **提问技巧** > - 提出明确的问题会获得更好的体验 > - 问题不能为空 > - 支持中文问题 > - 答案具有随机性，仅供娱乐参考
     * @summary 获取答案之书的神秘答案 (GET)
     * @param {string} question 你想要提问的问题。问题不能为空。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAnswerbookAsk(question: string, options?: RawAxiosRequestConfig) {
        return RandomApiFp(this.configuration).getAnswerbookAsk(question, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 需要一张随机图片作为占位符或者背景吗？这个接口是你的不二之选。  ## 功能概述 这是一个非常简单的接口，它会从我们庞大的图库和精选外部图床中随机挑选一张图片，然后通过 302 重定向让你直接访问到它。这使得它可以非常方便地直接用在 HTML 的 `<img>` 标签中。  你可以通过 `/api/v1/random/image?category=acg&type=4k` 这样的请求获取由UapiPro服务器提供的图片，也可以通过 `/api/v1/random/image?category=ai_drawing` 获取由外部图床精选的图片。  如果你不提供任何 category 参数，程序会从所有图片（包括本地的和URL的）中随机抽取一张（**全局随机图片不包含ikun和AI绘画**）。  > [!TIP] > 如果你需要更精确地控制图片类型，请使用 `/image/random/{category}/{type}` 接口。  ### 支持的主类别与子类别 - **UapiPro服务器图片**   - **furry**（福瑞）     - z4k     - szs8k     - s4k     - 4k   - **bq**（表情包/趣图）     - youshou     - xiongmao     - waiguoren     - maomao     - ikun     - eciyuan   - **acg**（二次元动漫）     - pc     - mb - **外部图床精选图片**   - **ai_drawing**: AI绘画。   - **general_anime**: 动漫图。   - **landscape**: 风景图。   - **mobile_wallpaper**: 手机壁纸。   - **pc_wallpaper**: 电脑壁纸。 - **混合动漫**   - **anime**: 混合了UapiPro服务器的acg和外部图床的general_anime分类下的图片。  > [!NOTE] > 默认全局随机（未指定category参数）时，不会包含ikun和AI绘画（ai_drawing）类别的图片。 
     * @summary 随机二次元、风景、动漫图片壁纸
     * @param {GetRandomImageCategoryEnum} [category] （可选）指定图片主类别。  **支持的主类别：** - &#x60;furry&#x60;（福瑞，UapiPro服务器） - &#x60;bq&#x60;（表情包/趣图，UapiPro服务器） - &#x60;acg&#x60;（二次元动漫，UapiPro服务器） - &#x60;ai_drawing&#x60;（AI绘画，外部图床） - &#x60;general_anime&#x60;（动漫图，外部图床） - &#x60;landscape&#x60;（风景图，外部图床） - &#x60;mobile_wallpaper&#x60;（手机壁纸，外部图床） - &#x60;pc_wallpaper&#x60;（电脑壁纸，外部图床） - &#x60;anime&#x60;（混合动漫，UapiPro服务器acg + 外部图床general_anime）  &gt; [!TIP] &gt; 如果不指定，将从所有图片中随机抽取（不包含 &#x60;ikun&#x60; 和 &#x60;ai_drawing&#x60;）。 
     * @param {GetRandomImageTypeEnum} [type] （可选，仅UapiPro服务器图片支持）指定图片子类别。  - **furry**: &#x60;z4k&#x60;, &#x60;szs8k&#x60;, &#x60;s4k&#x60;, &#x60;4k&#x60; - **bq**: &#x60;youshou&#x60;, &#x60;xiongmao&#x60;, &#x60;waiguoren&#x60;, &#x60;maomao&#x60;, &#x60;ikun&#x60;, &#x60;eciyuan&#x60; - **acg**: &#x60;pc&#x60;, &#x60;mb&#x60;  &gt; [!TIP] &gt; 外部图床类别和 &#x60;anime&#x60; 混合类别不支持 &#x60;type&#x60; 参数。 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRandomImage(category?: GetRandomImageCategoryEnum, type?: GetRandomImageTypeEnum, options?: RawAxiosRequestConfig) {
        return RandomApiFp(this.configuration).getRandomImage(category, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 无论是需要生成一个安全的随机密码、一个唯一的Token，还是一个简单的随机ID，这个接口都能满足你。  ## 功能概述 你可以精确地控制生成字符串的长度和字符集类型，非常灵活。  ## 使用须知  > [!TIP] > **字符集类型 `type` 详解** > 你可以通过 `type` 参数精确控制生成的字符集： > - **`numeric`**: 纯数字 (0-9) > - **`lower`**: 纯小写字母 (a-z) > - **`upper`**: 纯大写字母 (A-Z) > - **`alpha`**: 大小写字母 (a-zA-Z) > - **`alphanumeric`** (默认): 数字和大小写字母 (0-9a-zA-Z) > - **`hex`**: 十六进制字符 (0-9a-f)
     * @summary 生成高度可定制的随机字符串
     * @param {number} [length] 你希望生成的字符串的长度。有效范围是 1 到 1024。
     * @param {GetRandomStringTypeEnum} [type] 指定构成字符串的字符类型。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRandomString(length?: number, type?: GetRandomStringTypeEnum, options?: RawAxiosRequestConfig) {
        return RandomApiFp(this.configuration).getRandomString(length, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 通过POST请求向答案之书提问并获得神秘答案。  ## 功能概述 与GET方式相同，但通过JSON请求体发送问题，适合在需要发送较长问题或希望避免URL编码问题的场景中使用。  ## 请求体格式 请求体必须是有效的JSON格式，包含question字段。
     * @summary 获取答案之书的神秘答案 (POST)
     * @param {PostAnswerbookAskRequest} postAnswerbookAskRequest 包含问题的JSON对象
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postAnswerbookAsk(postAnswerbookAskRequest: PostAnswerbookAskRequest, options?: RawAxiosRequestConfig) {
        return RandomApiFp(this.configuration).postAnswerbookAsk(postAnswerbookAskRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetRandomImageCategoryEnum = {
    Furry: 'furry',
    Bq: 'bq',
    Acg: 'acg',
    AiDrawing: 'ai_drawing',
    GeneralAnime: 'general_anime',
    Landscape: 'landscape',
    MobileWallpaper: 'mobile_wallpaper',
    PcWallpaper: 'pc_wallpaper',
    Anime: 'anime'
} as const;
export type GetRandomImageCategoryEnum = typeof GetRandomImageCategoryEnum[keyof typeof GetRandomImageCategoryEnum];
export const GetRandomImageTypeEnum = {
    Z4k: 'z4k',
    Szs8k: 'szs8k',
    S4k: 's4k',
    _4k: '4k',
    Youshou: 'youshou',
    Xiongmao: 'xiongmao',
    Waiguoren: 'waiguoren',
    Maomao: 'maomao',
    Ikun: 'ikun',
    Eciyuan: 'eciyuan',
    Pc: 'pc',
    Mb: 'mb'
} as const;
export type GetRandomImageTypeEnum = typeof GetRandomImageTypeEnum[keyof typeof GetRandomImageTypeEnum];
export const GetRandomStringTypeEnum = {
    Numeric: 'numeric',
    Lower: 'lower',
    Upper: 'upper',
    Alpha: 'alpha',
    Alphanumeric: 'alphanumeric',
    Hex: 'hex'
} as const;
export type GetRandomStringTypeEnum = typeof GetRandomStringTypeEnum[keyof typeof GetRandomStringTypeEnum];


/**
 * SocialApi - axios parameter creator
 */
export const SocialApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 需要快速获取一个GitHub仓库的核心信息？这个接口为你聚合了最有价值的数据，避免了多次调用GitHub官方API的麻烦，并且内置了缓存优化，速度更快、更稳定。  ### 聚合高价值数据 一次请求，即可获得以下信息： - **核心指标**: `star`, `fork`, `open_issues` 等关键统计数据。 - **项目详情**: 描述、主页、分支、语言、话题标签、开源协议。 - **参与者信息**: 获取协作者(`collaborators`)和推断的维护者(`maintainers`)列表，包括他们的公开邮箱（如果可用）。  > [!NOTE] > `collaborators` 字段在私有仓库或权限受限时可能为空。`maintainers` 是根据最新提交记录推断的，仅供参考。  ### 性能与稳定性 我们内置了多级缓存，有效避免触发GitHub的API速率限制。对于需要更高请求额度的用户，可以联系我们定制接口。
         * @summary 获取GitHub仓库信息
         * @param {string} repo 目标仓库的标识，格式为 &#x60;owner/repo&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGithubRepo: async (repo: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getGithubRepo', 'repo', repo)
            const localVarPath = `/github/repo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (repo !== undefined) {
                localVarQueryParameter['repo'] = repo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想要获取UP主的所有投稿视频？或者想在你的应用里展示创作者的作品集？这个接口能帮你轻松实现。  ## 功能概述 通过用户的 `mid`（用户ID），你可以获取该UP主的投稿视频列表。接口支持关键词搜索、分页加载和多种排序方式，让你能够灵活地展示和分析创作者的内容。  ## 参数说明 - **`mid` (用户ID)**: B站用户的mid，必填参数。 - **`keywords` (搜索关键词)**: 可选，用于在该UP主的投稿中搜索特定关键词。 - **`orderby` (排序方式)**:    - `pubdate`: 按最新发布排序（默认）   - `views`: 按最多播放排序 - **`ps` (每页条数)**: 默认20条。 - **`pn` (页码)**: 默认1，用于分页。  ## 响应体字段说明 - **`total` (总稿件数)**: UP主的投稿总数。 - **`page` (当前页码)**: 当前返回的页码。 - **`size` (每页数量)**: 每页返回的视频数量。 - **`videos` (视频列表)**: 包含当前页的所有视频信息：   - `aid`: 视频的AV号   - `bvid`: 视频的BV号   - `title`: 视频标题   - `cover`: 封面URL   - `duration`: 时长（秒）   - `play_count`: 播放量   - `publish_time`: 发布时间戳   - `create_time`: 创建时间戳   - `state`: 视频状态   - `is_ugc_pay`: 是否付费视频（0=免费，1=付费）   - `is_interactive`: 是否为互动视频
         * @summary 获取Bilibili用户投稿列表
         * @param {string} mid B站用户的mid（用户ID）
         * @param {string} [keywords] 搜索关键词，可为空
         * @param {string} [orderby] 排序方式。&#x60;pubdate&#x60;&#x3D;最新发布，&#x60;views&#x60;&#x3D;最多播放
         * @param {string} [ps] 每页条数，默认20
         * @param {string} [pn] 页码，默认1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialBilibiliArchives: async (mid: string, keywords?: string, orderby?: string, ps?: string, pn?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mid' is not null or undefined
            assertParamExists('getSocialBilibiliArchives', 'mid', mid)
            const localVarPath = `/social/bilibili/archives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mid !== undefined) {
                localVarQueryParameter['mid'] = mid;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            if (ps !== undefined) {
                localVarQueryParameter['ps'] = ps;
            }

            if (pn !== undefined) {
                localVarQueryParameter['pn'] = pn;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想知道你喜欢的主播开播了吗？或者想在你的应用里集成B站直播间状态？这个接口能满足你。  ## 功能概述 这是一个智能接口，你可以用主播的 `mid` (用户ID) 或者直播间的 `room_id` (长号或短号)来查询。它会返回直播间的详细信息，包括是否在直播、标题、封面、人气、分区等。  ## 响应体字段说明 - **`live_status` (直播状态)**: `0` 代表未开播，`1` 代表直播中，`2` 代表轮播中。
         * @summary 获取Bilibili直播间信息
         * @param {string} [mid] 主播的用户ID (&#x60;mid&#x60;)。与 &#x60;room_id&#x60; 任选其一。
         * @param {string} [roomId] 直播间ID，可以是长号（真实ID）或短号（靓号）。与 &#x60;mid&#x60; 任选其一。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialBilibiliLiveroom: async (mid?: string, roomId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/social/bilibili/liveroom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mid !== undefined) {
                localVarQueryParameter['mid'] = mid;
            }

            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想要分析B站视频的评论区？这个接口可以帮你轻松获取评论数据，包括热门评论和最新评论，还支持分页加载。  ## 功能概述 通过视频的 `oid`（通常就是视频的`aid`），你可以分页获取该视频的评论区内容。你可以指定排序方式和分页参数，来精确地获取你需要的数据。  ## 参数说明 - **`sort` (排序方式)**: `0`=按时间排序, `1`=按点赞数排序, `2`=按回复数排序。默认为按时间排序。  ## 响应体字段说明 - **`hots` (热门评论)**: 仅在请求第一页时，可能会返回热门评论列表。其结构与 `replies` 中的对象一致。 - **`replies` (评论列表)**: 这是一个数组，包含了当前页的评论。其中：   - `root`: 指向根评论的ID。如果评论本身就是根评论，则为 `0`。   - `parent`: 指向该条回复所回复的上一级评论ID。如果评论是根评论，则为 `0`。
         * @summary 获取Bilibili视频评论
         * @param {string} oid 目标评论区的ID。对于视频，这通常就是它的 &#x60;aid&#x60;。
         * @param {string} [sort] 排序方式。&#x60;0&#x60;&#x3D;按时间, &#x60;1&#x60;&#x3D;按点赞, &#x60;2&#x60;&#x3D;按回复。默认为 &#x60;0&#x60;。
         * @param {string} [ps] 每页获取的评论数量，范围是1到20。默认为 &#x60;20&#x60;。
         * @param {string} [pn] 要获取的页码，从1开始。默认为 &#x60;1&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialBilibiliReplies: async (oid: string, sort?: string, ps?: string, pn?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('getSocialBilibiliReplies', 'oid', oid)
            const localVarPath = `/social/bilibili/replies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (oid !== undefined) {
                localVarQueryParameter['oid'] = oid;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (ps !== undefined) {
                localVarQueryParameter['ps'] = ps;
            }

            if (pn !== undefined) {
                localVarQueryParameter['pn'] = pn;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想在你的应用里集成B站用户资料展示？这个接口可以轻松获取用户的公开信息。  ## 功能概述 通过一个用户的UID（那一串纯数字ID），你可以查询到该用户的昵称、性别、头像、等级、签名等一系列公开的基本信息。
         * @summary 查询Bilibili用户信息
         * @param {string} uid Bilibili用户的UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialBilibiliUserinfo: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSocialBilibiliUserinfo', 'uid', uid)
            const localVarPath = `/social/bilibili/userinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想在你的应用里展示B站视频的详细信息吗？无论是封面、标题，还是播放量、UP主信息，这个接口都能一网打尽。  ## 功能概述 通过提供视频的 `aid` 或 `bvid`，你可以获取到该视频的完整元数据，包括多P信息、UP主资料、数据统计等。  ## 响应体字段说明 - **`copyright` (视频类型)**: `1` 代表原创，`2` 代表转载。 - **`owner` (UP主信息)**: 包含 `mid`, `name`, `face` 等UP主的基本资料。 - **`stat` (数据统计)**: 包含了播放、弹幕、评论、点赞、投币、收藏、分享等核心数据。 - **`pages` (分P列表)**: 这是一个数组，包含了视频的每一个分P的信息，即使是单P视频也会有一个元素。
         * @summary 获取Bilibili视频详细信息
         * @param {string} [aid] 视频的AV号 (aid)，纯数字格式。&#x60;aid&#x60;和&#x60;bvid&#x60;任选其一即可。
         * @param {string} [bvid] 视频的BV号 (bvid)，例如 &#x60;BV117411r7R1&#x60;。&#x60;aid&#x60;和&#x60;bvid&#x60;任选其一即可。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialBilibiliVideoinfo: async (aid?: string, bvid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/social/bilibili/videoinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (aid !== undefined) {
                localVarQueryParameter['aid'] = aid;
            }

            if (bvid !== undefined) {
                localVarQueryParameter['bvid'] = bvid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想在你的应用里展示QQ群信息？这个接口让你轻松获取群名称、群头像、群简介等公开信息。它能帮你快速构建社群导航站、群聊推荐系统，或是为你的数据分析工具提供可靠的数据源。无论是展示群聊卡片、生成加群链接，还是进行社群数据统计，这个接口都能满足你的需求。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 你只需要提供一个QQ群号（5-12位纯数字），接口就会返回该群的完整公开信息。我们会先验证群号的有效性，确保返回的数据准确可靠。接口的响应速度快，数据结构清晰，非常适合集成到各类应用场景中。  ## 返回数据说明 接口会返回以下QQ群的关键信息： - **群基础信息**: 包括群号、群名称，让你能够准确识别和展示群聊。 - **视觉素材**: 提供群头像URL（标准100x100尺寸），可直接用于在你的界面中展示群聊图标。 - **群介绍资料**: 包含群描述/简介和群标签，帮助用户了解群聊的主题和特色。 - **便捷入口**: 返回加群链接（二维码URL），方便用户一键加入感兴趣的群聊。 - **数据时效**: 提供最后更新时间戳，让你了解数据的新鲜度。  所有返回的数据都遵循标准的JSON格式，字段命名清晰，便于解析和使用。无论你是在做网页端、移动端还是后端服务，都能轻松集成。
         * @summary 获取QQ群名称、头像、简介
         * @param {string} groupId QQ群号，长度5-12位
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialQqGroupinfo: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getSocialQqGroupinfo', 'groupId', groupId)
            const localVarPath = `/social/qq/groupinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 这是一个功能丰富的QQ用户信息查询接口，能够获取QQ用户的详细公开信息。  > [!VIP] > 我们在近日优化了此接口，速度应该会更加快了。   ## 功能概述 通过QQ号查询用户的详细信息，包括基础资料、等级信息、VIP状态等。返回的信息丰富全面，适合用于用户画像分析、社交应用集成等场景。  ## 数据字段说明 - **基础信息**: 昵称、个性签名、头像、年龄、性别 - **联系信息**: QQ邮箱、个性域名(QID) - **等级信息**: QQ等级、VIP状态和等级 - **时间信息**: 注册时间、最后更新时间
         * @summary 独家获取QQ号头像、昵称
         * @param {string} qq 需要查询的QQ号
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialQqUserinfo: async (qq: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qq' is not null or undefined
            assertParamExists('getSocialQqUserinfo', 'qq', qq)
            const localVarPath = `/social/qq/userinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (qq !== undefined) {
                localVarQueryParameter['qq'] = qq;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SocialApi - functional programming interface
 */
export const SocialApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SocialApiAxiosParamCreator(configuration)
    return {
        /**
         * 需要快速获取一个GitHub仓库的核心信息？这个接口为你聚合了最有价值的数据，避免了多次调用GitHub官方API的麻烦，并且内置了缓存优化，速度更快、更稳定。  ### 聚合高价值数据 一次请求，即可获得以下信息： - **核心指标**: `star`, `fork`, `open_issues` 等关键统计数据。 - **项目详情**: 描述、主页、分支、语言、话题标签、开源协议。 - **参与者信息**: 获取协作者(`collaborators`)和推断的维护者(`maintainers`)列表，包括他们的公开邮箱（如果可用）。  > [!NOTE] > `collaborators` 字段在私有仓库或权限受限时可能为空。`maintainers` 是根据最新提交记录推断的，仅供参考。  ### 性能与稳定性 我们内置了多级缓存，有效避免触发GitHub的API速率限制。对于需要更高请求额度的用户，可以联系我们定制接口。
         * @summary 获取GitHub仓库信息
         * @param {string} repo 目标仓库的标识，格式为 &#x60;owner/repo&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGithubRepo(repo: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGithubRepo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGithubRepo(repo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SocialApi.getGithubRepo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想要获取UP主的所有投稿视频？或者想在你的应用里展示创作者的作品集？这个接口能帮你轻松实现。  ## 功能概述 通过用户的 `mid`（用户ID），你可以获取该UP主的投稿视频列表。接口支持关键词搜索、分页加载和多种排序方式，让你能够灵活地展示和分析创作者的内容。  ## 参数说明 - **`mid` (用户ID)**: B站用户的mid，必填参数。 - **`keywords` (搜索关键词)**: 可选，用于在该UP主的投稿中搜索特定关键词。 - **`orderby` (排序方式)**:    - `pubdate`: 按最新发布排序（默认）   - `views`: 按最多播放排序 - **`ps` (每页条数)**: 默认20条。 - **`pn` (页码)**: 默认1，用于分页。  ## 响应体字段说明 - **`total` (总稿件数)**: UP主的投稿总数。 - **`page` (当前页码)**: 当前返回的页码。 - **`size` (每页数量)**: 每页返回的视频数量。 - **`videos` (视频列表)**: 包含当前页的所有视频信息：   - `aid`: 视频的AV号   - `bvid`: 视频的BV号   - `title`: 视频标题   - `cover`: 封面URL   - `duration`: 时长（秒）   - `play_count`: 播放量   - `publish_time`: 发布时间戳   - `create_time`: 创建时间戳   - `state`: 视频状态   - `is_ugc_pay`: 是否付费视频（0=免费，1=付费）   - `is_interactive`: 是否为互动视频
         * @summary 获取Bilibili用户投稿列表
         * @param {string} mid B站用户的mid（用户ID）
         * @param {string} [keywords] 搜索关键词，可为空
         * @param {string} [orderby] 排序方式。&#x60;pubdate&#x60;&#x3D;最新发布，&#x60;views&#x60;&#x3D;最多播放
         * @param {string} [ps] 每页条数，默认20
         * @param {string} [pn] 页码，默认1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSocialBilibiliArchives(mid: string, keywords?: string, orderby?: string, ps?: string, pn?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSocialBilibiliArchives200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSocialBilibiliArchives(mid, keywords, orderby, ps, pn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SocialApi.getSocialBilibiliArchives']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想知道你喜欢的主播开播了吗？或者想在你的应用里集成B站直播间状态？这个接口能满足你。  ## 功能概述 这是一个智能接口，你可以用主播的 `mid` (用户ID) 或者直播间的 `room_id` (长号或短号)来查询。它会返回直播间的详细信息，包括是否在直播、标题、封面、人气、分区等。  ## 响应体字段说明 - **`live_status` (直播状态)**: `0` 代表未开播，`1` 代表直播中，`2` 代表轮播中。
         * @summary 获取Bilibili直播间信息
         * @param {string} [mid] 主播的用户ID (&#x60;mid&#x60;)。与 &#x60;room_id&#x60; 任选其一。
         * @param {string} [roomId] 直播间ID，可以是长号（真实ID）或短号（靓号）。与 &#x60;mid&#x60; 任选其一。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSocialBilibiliLiveroom(mid?: string, roomId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSocialBilibiliLiveroom200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSocialBilibiliLiveroom(mid, roomId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SocialApi.getSocialBilibiliLiveroom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想要分析B站视频的评论区？这个接口可以帮你轻松获取评论数据，包括热门评论和最新评论，还支持分页加载。  ## 功能概述 通过视频的 `oid`（通常就是视频的`aid`），你可以分页获取该视频的评论区内容。你可以指定排序方式和分页参数，来精确地获取你需要的数据。  ## 参数说明 - **`sort` (排序方式)**: `0`=按时间排序, `1`=按点赞数排序, `2`=按回复数排序。默认为按时间排序。  ## 响应体字段说明 - **`hots` (热门评论)**: 仅在请求第一页时，可能会返回热门评论列表。其结构与 `replies` 中的对象一致。 - **`replies` (评论列表)**: 这是一个数组，包含了当前页的评论。其中：   - `root`: 指向根评论的ID。如果评论本身就是根评论，则为 `0`。   - `parent`: 指向该条回复所回复的上一级评论ID。如果评论是根评论，则为 `0`。
         * @summary 获取Bilibili视频评论
         * @param {string} oid 目标评论区的ID。对于视频，这通常就是它的 &#x60;aid&#x60;。
         * @param {string} [sort] 排序方式。&#x60;0&#x60;&#x3D;按时间, &#x60;1&#x60;&#x3D;按点赞, &#x60;2&#x60;&#x3D;按回复。默认为 &#x60;0&#x60;。
         * @param {string} [ps] 每页获取的评论数量，范围是1到20。默认为 &#x60;20&#x60;。
         * @param {string} [pn] 要获取的页码，从1开始。默认为 &#x60;1&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSocialBilibiliReplies(oid: string, sort?: string, ps?: string, pn?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSocialBilibiliReplies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSocialBilibiliReplies(oid, sort, ps, pn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SocialApi.getSocialBilibiliReplies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想在你的应用里集成B站用户资料展示？这个接口可以轻松获取用户的公开信息。  ## 功能概述 通过一个用户的UID（那一串纯数字ID），你可以查询到该用户的昵称、性别、头像、等级、签名等一系列公开的基本信息。
         * @summary 查询Bilibili用户信息
         * @param {string} uid Bilibili用户的UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSocialBilibiliUserinfo(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSocialBilibiliUserinfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSocialBilibiliUserinfo(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SocialApi.getSocialBilibiliUserinfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想在你的应用里展示B站视频的详细信息吗？无论是封面、标题，还是播放量、UP主信息，这个接口都能一网打尽。  ## 功能概述 通过提供视频的 `aid` 或 `bvid`，你可以获取到该视频的完整元数据，包括多P信息、UP主资料、数据统计等。  ## 响应体字段说明 - **`copyright` (视频类型)**: `1` 代表原创，`2` 代表转载。 - **`owner` (UP主信息)**: 包含 `mid`, `name`, `face` 等UP主的基本资料。 - **`stat` (数据统计)**: 包含了播放、弹幕、评论、点赞、投币、收藏、分享等核心数据。 - **`pages` (分P列表)**: 这是一个数组，包含了视频的每一个分P的信息，即使是单P视频也会有一个元素。
         * @summary 获取Bilibili视频详细信息
         * @param {string} [aid] 视频的AV号 (aid)，纯数字格式。&#x60;aid&#x60;和&#x60;bvid&#x60;任选其一即可。
         * @param {string} [bvid] 视频的BV号 (bvid)，例如 &#x60;BV117411r7R1&#x60;。&#x60;aid&#x60;和&#x60;bvid&#x60;任选其一即可。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSocialBilibiliVideoinfo(aid?: string, bvid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSocialBilibiliVideoinfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSocialBilibiliVideoinfo(aid, bvid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SocialApi.getSocialBilibiliVideoinfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想在你的应用里展示QQ群信息？这个接口让你轻松获取群名称、群头像、群简介等公开信息。它能帮你快速构建社群导航站、群聊推荐系统，或是为你的数据分析工具提供可靠的数据源。无论是展示群聊卡片、生成加群链接，还是进行社群数据统计，这个接口都能满足你的需求。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 你只需要提供一个QQ群号（5-12位纯数字），接口就会返回该群的完整公开信息。我们会先验证群号的有效性，确保返回的数据准确可靠。接口的响应速度快，数据结构清晰，非常适合集成到各类应用场景中。  ## 返回数据说明 接口会返回以下QQ群的关键信息： - **群基础信息**: 包括群号、群名称，让你能够准确识别和展示群聊。 - **视觉素材**: 提供群头像URL（标准100x100尺寸），可直接用于在你的界面中展示群聊图标。 - **群介绍资料**: 包含群描述/简介和群标签，帮助用户了解群聊的主题和特色。 - **便捷入口**: 返回加群链接（二维码URL），方便用户一键加入感兴趣的群聊。 - **数据时效**: 提供最后更新时间戳，让你了解数据的新鲜度。  所有返回的数据都遵循标准的JSON格式，字段命名清晰，便于解析和使用。无论你是在做网页端、移动端还是后端服务，都能轻松集成。
         * @summary 获取QQ群名称、头像、简介
         * @param {string} groupId QQ群号，长度5-12位
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSocialQqGroupinfo(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSocialQqGroupinfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSocialQqGroupinfo(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SocialApi.getSocialQqGroupinfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 这是一个功能丰富的QQ用户信息查询接口，能够获取QQ用户的详细公开信息。  > [!VIP] > 我们在近日优化了此接口，速度应该会更加快了。   ## 功能概述 通过QQ号查询用户的详细信息，包括基础资料、等级信息、VIP状态等。返回的信息丰富全面，适合用于用户画像分析、社交应用集成等场景。  ## 数据字段说明 - **基础信息**: 昵称、个性签名、头像、年龄、性别 - **联系信息**: QQ邮箱、个性域名(QID) - **等级信息**: QQ等级、VIP状态和等级 - **时间信息**: 注册时间、最后更新时间
         * @summary 独家获取QQ号头像、昵称
         * @param {string} qq 需要查询的QQ号
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSocialQqUserinfo(qq: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSocialQqUserinfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSocialQqUserinfo(qq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SocialApi.getSocialQqUserinfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SocialApi - factory interface
 */
export const SocialApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SocialApiFp(configuration)
    return {
        /**
         * 需要快速获取一个GitHub仓库的核心信息？这个接口为你聚合了最有价值的数据，避免了多次调用GitHub官方API的麻烦，并且内置了缓存优化，速度更快、更稳定。  ### 聚合高价值数据 一次请求，即可获得以下信息： - **核心指标**: `star`, `fork`, `open_issues` 等关键统计数据。 - **项目详情**: 描述、主页、分支、语言、话题标签、开源协议。 - **参与者信息**: 获取协作者(`collaborators`)和推断的维护者(`maintainers`)列表，包括他们的公开邮箱（如果可用）。  > [!NOTE] > `collaborators` 字段在私有仓库或权限受限时可能为空。`maintainers` 是根据最新提交记录推断的，仅供参考。  ### 性能与稳定性 我们内置了多级缓存，有效避免触发GitHub的API速率限制。对于需要更高请求额度的用户，可以联系我们定制接口。
         * @summary 获取GitHub仓库信息
         * @param {string} repo 目标仓库的标识，格式为 &#x60;owner/repo&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGithubRepo(repo: string, options?: RawAxiosRequestConfig): AxiosPromise<GetGithubRepo200Response> {
            return localVarFp.getGithubRepo(repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 想要获取UP主的所有投稿视频？或者想在你的应用里展示创作者的作品集？这个接口能帮你轻松实现。  ## 功能概述 通过用户的 `mid`（用户ID），你可以获取该UP主的投稿视频列表。接口支持关键词搜索、分页加载和多种排序方式，让你能够灵活地展示和分析创作者的内容。  ## 参数说明 - **`mid` (用户ID)**: B站用户的mid，必填参数。 - **`keywords` (搜索关键词)**: 可选，用于在该UP主的投稿中搜索特定关键词。 - **`orderby` (排序方式)**:    - `pubdate`: 按最新发布排序（默认）   - `views`: 按最多播放排序 - **`ps` (每页条数)**: 默认20条。 - **`pn` (页码)**: 默认1，用于分页。  ## 响应体字段说明 - **`total` (总稿件数)**: UP主的投稿总数。 - **`page` (当前页码)**: 当前返回的页码。 - **`size` (每页数量)**: 每页返回的视频数量。 - **`videos` (视频列表)**: 包含当前页的所有视频信息：   - `aid`: 视频的AV号   - `bvid`: 视频的BV号   - `title`: 视频标题   - `cover`: 封面URL   - `duration`: 时长（秒）   - `play_count`: 播放量   - `publish_time`: 发布时间戳   - `create_time`: 创建时间戳   - `state`: 视频状态   - `is_ugc_pay`: 是否付费视频（0=免费，1=付费）   - `is_interactive`: 是否为互动视频
         * @summary 获取Bilibili用户投稿列表
         * @param {string} mid B站用户的mid（用户ID）
         * @param {string} [keywords] 搜索关键词，可为空
         * @param {string} [orderby] 排序方式。&#x60;pubdate&#x60;&#x3D;最新发布，&#x60;views&#x60;&#x3D;最多播放
         * @param {string} [ps] 每页条数，默认20
         * @param {string} [pn] 页码，默认1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialBilibiliArchives(mid: string, keywords?: string, orderby?: string, ps?: string, pn?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetSocialBilibiliArchives200Response> {
            return localVarFp.getSocialBilibiliArchives(mid, keywords, orderby, ps, pn, options).then((request) => request(axios, basePath));
        },
        /**
         * 想知道你喜欢的主播开播了吗？或者想在你的应用里集成B站直播间状态？这个接口能满足你。  ## 功能概述 这是一个智能接口，你可以用主播的 `mid` (用户ID) 或者直播间的 `room_id` (长号或短号)来查询。它会返回直播间的详细信息，包括是否在直播、标题、封面、人气、分区等。  ## 响应体字段说明 - **`live_status` (直播状态)**: `0` 代表未开播，`1` 代表直播中，`2` 代表轮播中。
         * @summary 获取Bilibili直播间信息
         * @param {string} [mid] 主播的用户ID (&#x60;mid&#x60;)。与 &#x60;room_id&#x60; 任选其一。
         * @param {string} [roomId] 直播间ID，可以是长号（真实ID）或短号（靓号）。与 &#x60;mid&#x60; 任选其一。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialBilibiliLiveroom(mid?: string, roomId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetSocialBilibiliLiveroom200Response> {
            return localVarFp.getSocialBilibiliLiveroom(mid, roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 想要分析B站视频的评论区？这个接口可以帮你轻松获取评论数据，包括热门评论和最新评论，还支持分页加载。  ## 功能概述 通过视频的 `oid`（通常就是视频的`aid`），你可以分页获取该视频的评论区内容。你可以指定排序方式和分页参数，来精确地获取你需要的数据。  ## 参数说明 - **`sort` (排序方式)**: `0`=按时间排序, `1`=按点赞数排序, `2`=按回复数排序。默认为按时间排序。  ## 响应体字段说明 - **`hots` (热门评论)**: 仅在请求第一页时，可能会返回热门评论列表。其结构与 `replies` 中的对象一致。 - **`replies` (评论列表)**: 这是一个数组，包含了当前页的评论。其中：   - `root`: 指向根评论的ID。如果评论本身就是根评论，则为 `0`。   - `parent`: 指向该条回复所回复的上一级评论ID。如果评论是根评论，则为 `0`。
         * @summary 获取Bilibili视频评论
         * @param {string} oid 目标评论区的ID。对于视频，这通常就是它的 &#x60;aid&#x60;。
         * @param {string} [sort] 排序方式。&#x60;0&#x60;&#x3D;按时间, &#x60;1&#x60;&#x3D;按点赞, &#x60;2&#x60;&#x3D;按回复。默认为 &#x60;0&#x60;。
         * @param {string} [ps] 每页获取的评论数量，范围是1到20。默认为 &#x60;20&#x60;。
         * @param {string} [pn] 要获取的页码，从1开始。默认为 &#x60;1&#x60;。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialBilibiliReplies(oid: string, sort?: string, ps?: string, pn?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetSocialBilibiliReplies200Response> {
            return localVarFp.getSocialBilibiliReplies(oid, sort, ps, pn, options).then((request) => request(axios, basePath));
        },
        /**
         * 想在你的应用里集成B站用户资料展示？这个接口可以轻松获取用户的公开信息。  ## 功能概述 通过一个用户的UID（那一串纯数字ID），你可以查询到该用户的昵称、性别、头像、等级、签名等一系列公开的基本信息。
         * @summary 查询Bilibili用户信息
         * @param {string} uid Bilibili用户的UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialBilibiliUserinfo(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<GetSocialBilibiliUserinfo200Response> {
            return localVarFp.getSocialBilibiliUserinfo(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 想在你的应用里展示B站视频的详细信息吗？无论是封面、标题，还是播放量、UP主信息，这个接口都能一网打尽。  ## 功能概述 通过提供视频的 `aid` 或 `bvid`，你可以获取到该视频的完整元数据，包括多P信息、UP主资料、数据统计等。  ## 响应体字段说明 - **`copyright` (视频类型)**: `1` 代表原创，`2` 代表转载。 - **`owner` (UP主信息)**: 包含 `mid`, `name`, `face` 等UP主的基本资料。 - **`stat` (数据统计)**: 包含了播放、弹幕、评论、点赞、投币、收藏、分享等核心数据。 - **`pages` (分P列表)**: 这是一个数组，包含了视频的每一个分P的信息，即使是单P视频也会有一个元素。
         * @summary 获取Bilibili视频详细信息
         * @param {string} [aid] 视频的AV号 (aid)，纯数字格式。&#x60;aid&#x60;和&#x60;bvid&#x60;任选其一即可。
         * @param {string} [bvid] 视频的BV号 (bvid)，例如 &#x60;BV117411r7R1&#x60;。&#x60;aid&#x60;和&#x60;bvid&#x60;任选其一即可。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialBilibiliVideoinfo(aid?: string, bvid?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetSocialBilibiliVideoinfo200Response> {
            return localVarFp.getSocialBilibiliVideoinfo(aid, bvid, options).then((request) => request(axios, basePath));
        },
        /**
         * 想在你的应用里展示QQ群信息？这个接口让你轻松获取群名称、群头像、群简介等公开信息。它能帮你快速构建社群导航站、群聊推荐系统，或是为你的数据分析工具提供可靠的数据源。无论是展示群聊卡片、生成加群链接，还是进行社群数据统计，这个接口都能满足你的需求。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 你只需要提供一个QQ群号（5-12位纯数字），接口就会返回该群的完整公开信息。我们会先验证群号的有效性，确保返回的数据准确可靠。接口的响应速度快，数据结构清晰，非常适合集成到各类应用场景中。  ## 返回数据说明 接口会返回以下QQ群的关键信息： - **群基础信息**: 包括群号、群名称，让你能够准确识别和展示群聊。 - **视觉素材**: 提供群头像URL（标准100x100尺寸），可直接用于在你的界面中展示群聊图标。 - **群介绍资料**: 包含群描述/简介和群标签，帮助用户了解群聊的主题和特色。 - **便捷入口**: 返回加群链接（二维码URL），方便用户一键加入感兴趣的群聊。 - **数据时效**: 提供最后更新时间戳，让你了解数据的新鲜度。  所有返回的数据都遵循标准的JSON格式，字段命名清晰，便于解析和使用。无论你是在做网页端、移动端还是后端服务，都能轻松集成。
         * @summary 获取QQ群名称、头像、简介
         * @param {string} groupId QQ群号，长度5-12位
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialQqGroupinfo(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetSocialQqGroupinfo200Response> {
            return localVarFp.getSocialQqGroupinfo(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 这是一个功能丰富的QQ用户信息查询接口，能够获取QQ用户的详细公开信息。  > [!VIP] > 我们在近日优化了此接口，速度应该会更加快了。   ## 功能概述 通过QQ号查询用户的详细信息，包括基础资料、等级信息、VIP状态等。返回的信息丰富全面，适合用于用户画像分析、社交应用集成等场景。  ## 数据字段说明 - **基础信息**: 昵称、个性签名、头像、年龄、性别 - **联系信息**: QQ邮箱、个性域名(QID) - **等级信息**: QQ等级、VIP状态和等级 - **时间信息**: 注册时间、最后更新时间
         * @summary 独家获取QQ号头像、昵称
         * @param {string} qq 需要查询的QQ号
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialQqUserinfo(qq: string, options?: RawAxiosRequestConfig): AxiosPromise<GetSocialQqUserinfo200Response> {
            return localVarFp.getSocialQqUserinfo(qq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SocialApi - object-oriented interface
 */
export class SocialApi extends BaseAPI {
    /**
     * 需要快速获取一个GitHub仓库的核心信息？这个接口为你聚合了最有价值的数据，避免了多次调用GitHub官方API的麻烦，并且内置了缓存优化，速度更快、更稳定。  ### 聚合高价值数据 一次请求，即可获得以下信息： - **核心指标**: `star`, `fork`, `open_issues` 等关键统计数据。 - **项目详情**: 描述、主页、分支、语言、话题标签、开源协议。 - **参与者信息**: 获取协作者(`collaborators`)和推断的维护者(`maintainers`)列表，包括他们的公开邮箱（如果可用）。  > [!NOTE] > `collaborators` 字段在私有仓库或权限受限时可能为空。`maintainers` 是根据最新提交记录推断的，仅供参考。  ### 性能与稳定性 我们内置了多级缓存，有效避免触发GitHub的API速率限制。对于需要更高请求额度的用户，可以联系我们定制接口。
     * @summary 获取GitHub仓库信息
     * @param {string} repo 目标仓库的标识，格式为 &#x60;owner/repo&#x60;。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGithubRepo(repo: string, options?: RawAxiosRequestConfig) {
        return SocialApiFp(this.configuration).getGithubRepo(repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想要获取UP主的所有投稿视频？或者想在你的应用里展示创作者的作品集？这个接口能帮你轻松实现。  ## 功能概述 通过用户的 `mid`（用户ID），你可以获取该UP主的投稿视频列表。接口支持关键词搜索、分页加载和多种排序方式，让你能够灵活地展示和分析创作者的内容。  ## 参数说明 - **`mid` (用户ID)**: B站用户的mid，必填参数。 - **`keywords` (搜索关键词)**: 可选，用于在该UP主的投稿中搜索特定关键词。 - **`orderby` (排序方式)**:    - `pubdate`: 按最新发布排序（默认）   - `views`: 按最多播放排序 - **`ps` (每页条数)**: 默认20条。 - **`pn` (页码)**: 默认1，用于分页。  ## 响应体字段说明 - **`total` (总稿件数)**: UP主的投稿总数。 - **`page` (当前页码)**: 当前返回的页码。 - **`size` (每页数量)**: 每页返回的视频数量。 - **`videos` (视频列表)**: 包含当前页的所有视频信息：   - `aid`: 视频的AV号   - `bvid`: 视频的BV号   - `title`: 视频标题   - `cover`: 封面URL   - `duration`: 时长（秒）   - `play_count`: 播放量   - `publish_time`: 发布时间戳   - `create_time`: 创建时间戳   - `state`: 视频状态   - `is_ugc_pay`: 是否付费视频（0=免费，1=付费）   - `is_interactive`: 是否为互动视频
     * @summary 获取Bilibili用户投稿列表
     * @param {string} mid B站用户的mid（用户ID）
     * @param {string} [keywords] 搜索关键词，可为空
     * @param {string} [orderby] 排序方式。&#x60;pubdate&#x60;&#x3D;最新发布，&#x60;views&#x60;&#x3D;最多播放
     * @param {string} [ps] 每页条数，默认20
     * @param {string} [pn] 页码，默认1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSocialBilibiliArchives(mid: string, keywords?: string, orderby?: string, ps?: string, pn?: string, options?: RawAxiosRequestConfig) {
        return SocialApiFp(this.configuration).getSocialBilibiliArchives(mid, keywords, orderby, ps, pn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想知道你喜欢的主播开播了吗？或者想在你的应用里集成B站直播间状态？这个接口能满足你。  ## 功能概述 这是一个智能接口，你可以用主播的 `mid` (用户ID) 或者直播间的 `room_id` (长号或短号)来查询。它会返回直播间的详细信息，包括是否在直播、标题、封面、人气、分区等。  ## 响应体字段说明 - **`live_status` (直播状态)**: `0` 代表未开播，`1` 代表直播中，`2` 代表轮播中。
     * @summary 获取Bilibili直播间信息
     * @param {string} [mid] 主播的用户ID (&#x60;mid&#x60;)。与 &#x60;room_id&#x60; 任选其一。
     * @param {string} [roomId] 直播间ID，可以是长号（真实ID）或短号（靓号）。与 &#x60;mid&#x60; 任选其一。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSocialBilibiliLiveroom(mid?: string, roomId?: string, options?: RawAxiosRequestConfig) {
        return SocialApiFp(this.configuration).getSocialBilibiliLiveroom(mid, roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想要分析B站视频的评论区？这个接口可以帮你轻松获取评论数据，包括热门评论和最新评论，还支持分页加载。  ## 功能概述 通过视频的 `oid`（通常就是视频的`aid`），你可以分页获取该视频的评论区内容。你可以指定排序方式和分页参数，来精确地获取你需要的数据。  ## 参数说明 - **`sort` (排序方式)**: `0`=按时间排序, `1`=按点赞数排序, `2`=按回复数排序。默认为按时间排序。  ## 响应体字段说明 - **`hots` (热门评论)**: 仅在请求第一页时，可能会返回热门评论列表。其结构与 `replies` 中的对象一致。 - **`replies` (评论列表)**: 这是一个数组，包含了当前页的评论。其中：   - `root`: 指向根评论的ID。如果评论本身就是根评论，则为 `0`。   - `parent`: 指向该条回复所回复的上一级评论ID。如果评论是根评论，则为 `0`。
     * @summary 获取Bilibili视频评论
     * @param {string} oid 目标评论区的ID。对于视频，这通常就是它的 &#x60;aid&#x60;。
     * @param {string} [sort] 排序方式。&#x60;0&#x60;&#x3D;按时间, &#x60;1&#x60;&#x3D;按点赞, &#x60;2&#x60;&#x3D;按回复。默认为 &#x60;0&#x60;。
     * @param {string} [ps] 每页获取的评论数量，范围是1到20。默认为 &#x60;20&#x60;。
     * @param {string} [pn] 要获取的页码，从1开始。默认为 &#x60;1&#x60;。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSocialBilibiliReplies(oid: string, sort?: string, ps?: string, pn?: string, options?: RawAxiosRequestConfig) {
        return SocialApiFp(this.configuration).getSocialBilibiliReplies(oid, sort, ps, pn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想在你的应用里集成B站用户资料展示？这个接口可以轻松获取用户的公开信息。  ## 功能概述 通过一个用户的UID（那一串纯数字ID），你可以查询到该用户的昵称、性别、头像、等级、签名等一系列公开的基本信息。
     * @summary 查询Bilibili用户信息
     * @param {string} uid Bilibili用户的UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSocialBilibiliUserinfo(uid: string, options?: RawAxiosRequestConfig) {
        return SocialApiFp(this.configuration).getSocialBilibiliUserinfo(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想在你的应用里展示B站视频的详细信息吗？无论是封面、标题，还是播放量、UP主信息，这个接口都能一网打尽。  ## 功能概述 通过提供视频的 `aid` 或 `bvid`，你可以获取到该视频的完整元数据，包括多P信息、UP主资料、数据统计等。  ## 响应体字段说明 - **`copyright` (视频类型)**: `1` 代表原创，`2` 代表转载。 - **`owner` (UP主信息)**: 包含 `mid`, `name`, `face` 等UP主的基本资料。 - **`stat` (数据统计)**: 包含了播放、弹幕、评论、点赞、投币、收藏、分享等核心数据。 - **`pages` (分P列表)**: 这是一个数组，包含了视频的每一个分P的信息，即使是单P视频也会有一个元素。
     * @summary 获取Bilibili视频详细信息
     * @param {string} [aid] 视频的AV号 (aid)，纯数字格式。&#x60;aid&#x60;和&#x60;bvid&#x60;任选其一即可。
     * @param {string} [bvid] 视频的BV号 (bvid)，例如 &#x60;BV117411r7R1&#x60;。&#x60;aid&#x60;和&#x60;bvid&#x60;任选其一即可。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSocialBilibiliVideoinfo(aid?: string, bvid?: string, options?: RawAxiosRequestConfig) {
        return SocialApiFp(this.configuration).getSocialBilibiliVideoinfo(aid, bvid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想在你的应用里展示QQ群信息？这个接口让你轻松获取群名称、群头像、群简介等公开信息。它能帮你快速构建社群导航站、群聊推荐系统，或是为你的数据分析工具提供可靠的数据源。无论是展示群聊卡片、生成加群链接，还是进行社群数据统计，这个接口都能满足你的需求。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  ## 功能概述 你只需要提供一个QQ群号（5-12位纯数字），接口就会返回该群的完整公开信息。我们会先验证群号的有效性，确保返回的数据准确可靠。接口的响应速度快，数据结构清晰，非常适合集成到各类应用场景中。  ## 返回数据说明 接口会返回以下QQ群的关键信息： - **群基础信息**: 包括群号、群名称，让你能够准确识别和展示群聊。 - **视觉素材**: 提供群头像URL（标准100x100尺寸），可直接用于在你的界面中展示群聊图标。 - **群介绍资料**: 包含群描述/简介和群标签，帮助用户了解群聊的主题和特色。 - **便捷入口**: 返回加群链接（二维码URL），方便用户一键加入感兴趣的群聊。 - **数据时效**: 提供最后更新时间戳，让你了解数据的新鲜度。  所有返回的数据都遵循标准的JSON格式，字段命名清晰，便于解析和使用。无论你是在做网页端、移动端还是后端服务，都能轻松集成。
     * @summary 获取QQ群名称、头像、简介
     * @param {string} groupId QQ群号，长度5-12位
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSocialQqGroupinfo(groupId: string, options?: RawAxiosRequestConfig) {
        return SocialApiFp(this.configuration).getSocialQqGroupinfo(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 这是一个功能丰富的QQ用户信息查询接口，能够获取QQ用户的详细公开信息。  > [!VIP] > 我们在近日优化了此接口，速度应该会更加快了。   ## 功能概述 通过QQ号查询用户的详细信息，包括基础资料、等级信息、VIP状态等。返回的信息丰富全面，适合用于用户画像分析、社交应用集成等场景。  ## 数据字段说明 - **基础信息**: 昵称、个性签名、头像、年龄、性别 - **联系信息**: QQ邮箱、个性域名(QID) - **等级信息**: QQ等级、VIP状态和等级 - **时间信息**: 注册时间、最后更新时间
     * @summary 独家获取QQ号头像、昵称
     * @param {string} qq 需要查询的QQ号
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSocialQqUserinfo(qq: string, options?: RawAxiosRequestConfig) {
        return SocialApiFp(this.configuration).getSocialQqUserinfo(qq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusApi - axios parameter creator
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 想了解我们API的当前负载情况吗？这个接口为你提供了服务的“心电图”。  ## 功能概述 此接口返回我们后端自适应限流器的实时状态。你可以看到当前并发请求数、并发上限、系统负载、请求接受/拒绝数等核心指标。这对于监控API健康状况和性能表现至关重要。  > [!IMPORTANT] > 此接口为管理接口，需要提供有效的管理员级别API密钥才能访问。  ### 认证方式 请在请求头中添加 `Authorization: Bearer <你的API密钥>`。
         * @summary 获取API限流器实时状态
         * @param {string} authorization Bearer类型的API密钥认证头。例如：&#x60;Bearer sk-xxx&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusRatelimit: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getStatusRatelimit', 'authorization', authorization)
            const localVarPath = `/status/ratelimit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想知道哪个API接口最受欢迎吗？这个接口提供了详细的“账单”。  ## 功能概述 此接口用于获取每个API端点（Endpoint）的使用情况统计。你可以查询所有端点的列表，也可以通过 `path` 参数指定查询某一个特定端点。返回信息包括调用次数和平均处理时长
         * @summary 获取API端点使用统计
         * @param {string} [path] （可选）如果你想查询某个特定的端点，请提供它的路径，例如 \&#39;/api/v1/image/motou\&#39;。如果留空，则返回所有端点的统计列表。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusUsage: async (path?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 想了解我们API的当前负载情况吗？这个接口为你提供了服务的“心电图”。  ## 功能概述 此接口返回我们后端自适应限流器的实时状态。你可以看到当前并发请求数、并发上限、系统负载、请求接受/拒绝数等核心指标。这对于监控API健康状况和性能表现至关重要。  > [!IMPORTANT] > 此接口为管理接口，需要提供有效的管理员级别API密钥才能访问。  ### 认证方式 请在请求头中添加 `Authorization: Bearer <你的API密钥>`。
         * @summary 获取API限流器实时状态
         * @param {string} authorization Bearer类型的API密钥认证头。例如：&#x60;Bearer sk-xxx&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusRatelimit(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusRatelimit200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusRatelimit(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.getStatusRatelimit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想知道哪个API接口最受欢迎吗？这个接口提供了详细的“账单”。  ## 功能概述 此接口用于获取每个API端点（Endpoint）的使用情况统计。你可以查询所有端点的列表，也可以通过 `path` 参数指定查询某一个特定端点。返回信息包括调用次数和平均处理时长
         * @summary 获取API端点使用统计
         * @param {string} [path] （可选）如果你想查询某个特定的端点，请提供它的路径，例如 \&#39;/api/v1/image/motou\&#39;。如果留空，则返回所有端点的统计列表。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusUsage(path?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusUsage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusUsage(path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.getStatusUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusApi - factory interface
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * 想了解我们API的当前负载情况吗？这个接口为你提供了服务的“心电图”。  ## 功能概述 此接口返回我们后端自适应限流器的实时状态。你可以看到当前并发请求数、并发上限、系统负载、请求接受/拒绝数等核心指标。这对于监控API健康状况和性能表现至关重要。  > [!IMPORTANT] > 此接口为管理接口，需要提供有效的管理员级别API密钥才能访问。  ### 认证方式 请在请求头中添加 `Authorization: Bearer <你的API密钥>`。
         * @summary 获取API限流器实时状态
         * @param {string} authorization Bearer类型的API密钥认证头。例如：&#x60;Bearer sk-xxx&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusRatelimit(authorization: string, options?: RawAxiosRequestConfig): AxiosPromise<GetStatusRatelimit200Response> {
            return localVarFp.getStatusRatelimit(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 想知道哪个API接口最受欢迎吗？这个接口提供了详细的“账单”。  ## 功能概述 此接口用于获取每个API端点（Endpoint）的使用情况统计。你可以查询所有端点的列表，也可以通过 `path` 参数指定查询某一个特定端点。返回信息包括调用次数和平均处理时长
         * @summary 获取API端点使用统计
         * @param {string} [path] （可选）如果你想查询某个特定的端点，请提供它的路径，例如 \&#39;/api/v1/image/motou\&#39;。如果留空，则返回所有端点的统计列表。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusUsage(path?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetStatusUsage200Response> {
            return localVarFp.getStatusUsage(path, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 */
export class StatusApi extends BaseAPI {
    /**
     * 想了解我们API的当前负载情况吗？这个接口为你提供了服务的“心电图”。  ## 功能概述 此接口返回我们后端自适应限流器的实时状态。你可以看到当前并发请求数、并发上限、系统负载、请求接受/拒绝数等核心指标。这对于监控API健康状况和性能表现至关重要。  > [!IMPORTANT] > 此接口为管理接口，需要提供有效的管理员级别API密钥才能访问。  ### 认证方式 请在请求头中添加 `Authorization: Bearer <你的API密钥>`。
     * @summary 获取API限流器实时状态
     * @param {string} authorization Bearer类型的API密钥认证头。例如：&#x60;Bearer sk-xxx&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStatusRatelimit(authorization: string, options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).getStatusRatelimit(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想知道哪个API接口最受欢迎吗？这个接口提供了详细的“账单”。  ## 功能概述 此接口用于获取每个API端点（Endpoint）的使用情况统计。你可以查询所有端点的列表，也可以通过 `path` 参数指定查询某一个特定端点。返回信息包括调用次数和平均处理时长
     * @summary 获取API端点使用统计
     * @param {string} [path] （可选）如果你想查询某个特定的端点，请提供它的路径，例如 \&#39;/api/v1/image/motou\&#39;。如果留空，则返回所有端点的统计列表。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStatusUsage(path?: string, options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).getStatusUsage(path, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TextApi - axios parameter creator
 */
export const TextApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 一个快速计算文本 MD5 哈希值的工具，适用于短文本且不关心参数暴露的场景。  ## 功能概述 通过GET请求的查询参数传入文本，返回其32位小写的MD5哈希值。  > [!NOTE] > 对于较长或敏感的文本，我们推荐使用本接口的 POST 版本，以避免URL长度限制和参数暴露问题。
         * @summary 计算文本的MD5哈希值(GET)
         * @param {string} text 需要计算哈希值的文本
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTextMd5: async (text: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'text' is not null or undefined
            assertParamExists('getTextMd5', 'text', text)
            const localVarPath = `/text/md5`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 收到了用AES加密的密文？把它、密钥和随机数（nonce）交给我们，就能还原出原始内容。  ## 功能概述 这是一个标准的AES解密接口。你需要提供经过Base64编码的密文、加密时使用的密钥和nonce（随机数，通常为16字节字符串）。  > [!IMPORTANT] > **关于密钥 `key`** > 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 `key` 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。 >  > **关于随机数 `nonce`** > 通常为16字节字符串，需与加密时一致。
         * @summary 使用AES算法解密文本
         * @param {PostTextAesDecryptRequest} postTextAesDecryptRequest 包含待解密文本 \&#39;text\&#39;、密钥 \&#39;key\&#39; 和随机数 \&#39;nonce\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTextAesDecrypt: async (postTextAesDecryptRequest: PostTextAesDecryptRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postTextAesDecryptRequest' is not null or undefined
            assertParamExists('postTextAesDecrypt', 'postTextAesDecryptRequest', postTextAesDecryptRequest)
            const localVarPath = `/text/aes/decrypt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTextAesDecryptRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 需要安全地传输或存储一些文本信息？AES加密是一个可靠的选择。  ## 功能概述 这是一个标准的AES加密接口。你提供需要加密的明文和密钥，我们返回经过Base64编码的密文。  > [!IMPORTANT] > **关于密钥 `key`** > 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 `key` 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。
         * @summary 使用AES算法加密文本
         * @param {PostTextAesEncryptRequest} postTextAesEncryptRequest 包含待加密文本 \&#39;text\&#39; 和密钥 \&#39;key\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTextAesEncrypt: async (postTextAesEncryptRequest: PostTextAesEncryptRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postTextAesEncryptRequest' is not null or undefined
            assertParamExists('postTextAesEncrypt', 'postTextAesEncryptRequest', postTextAesEncryptRequest)
            const localVarPath = `/text/aes/encrypt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTextAesEncryptRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想知道一篇文章有多少字、多少个词、或者多少行？这个接口可以帮你快速统计。  ## 功能概述 你提供一段文本，我们会从多个维度进行分析，并返回其字符数、词数、句子数、段落数和行数。这对于文本编辑、内容管理等场景非常有用。
         * @summary 多维度分析文本内容
         * @param {PostTextAnalyzeRequest} postTextAnalyzeRequest 包含待分析文本 \&#39;text\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTextAnalyze: async (postTextAnalyzeRequest: PostTextAnalyzeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postTextAnalyzeRequest' is not null or undefined
            assertParamExists('postTextAnalyze', 'postTextAnalyzeRequest', postTextAnalyzeRequest)
            const localVarPath = `/text/analyze`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTextAnalyzeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 这是一个简单实用的 Base64 解码工具。  ## 功能概述 你提供一个 Base64 编码的字符串，我们帮你解码成原始的 UTF-8 文本。
         * @summary 解码Base64编码的文本
         * @param {PostTextBase64DecodeRequest} postTextBase64DecodeRequest 包含待解码文本 \&#39;text\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTextBase64Decode: async (postTextBase64DecodeRequest: PostTextBase64DecodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postTextBase64DecodeRequest' is not null or undefined
            assertParamExists('postTextBase64Decode', 'postTextBase64DecodeRequest', postTextBase64DecodeRequest)
            const localVarPath = `/text/base64/decode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTextBase64DecodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 这是一个简单实用的 Base64 编码工具。  ## 功能概述 你提供一段原始文本，我们帮你转换成 Base64 编码的字符串。
         * @summary 将文本进行Base64编码
         * @param {PostTextBase64EncodeRequest} postTextBase64EncodeRequest 包含待编码文本 \&#39;text\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTextBase64Encode: async (postTextBase64EncodeRequest: PostTextBase64EncodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postTextBase64EncodeRequest' is not null or undefined
            assertParamExists('postTextBase64Encode', 'postTextBase64EncodeRequest', postTextBase64EncodeRequest)
            const localVarPath = `/text/base64/encode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTextBase64EncodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 一个用于计算文本 MD5 哈希值的标准工具，推荐使用此版本。  ## 功能概述 通过POST请求的表单体传入文本，返回其32位小写的MD5哈希值。相比GET版本，此方法更适合处理较长或包含敏感信息的文本。
         * @summary 计算文本的MD5哈希值 (POST)
         * @param {PostTextMd5Request} postTextMd5Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTextMd5: async (postTextMd5Request: PostTextMd5Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postTextMd5Request' is not null or undefined
            assertParamExists('postTextMd5', 'postTextMd5Request', postTextMd5Request)
            const localVarPath = `/text/md5`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTextMd5Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 下载了一个文件，想确认它在传输过程中有没有损坏？校验MD5值是最常用的方法。  ## 功能概述 你提供原始文本和一个MD5哈希值，我们帮你计算文本的哈希，并与你提供的哈希进行比对，告诉你它们是否匹配。这在文件完整性校验等场景下非常有用。
         * @summary 校验MD5哈希值
         * @param {PostTextMd5VerifyRequest} postTextMd5VerifyRequest 包含待校验文本 \&#39;text\&#39; 和哈希值 \&#39;hash\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTextMd5Verify: async (postTextMd5VerifyRequest: PostTextMd5VerifyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postTextMd5VerifyRequest' is not null or undefined
            assertParamExists('postTextMd5Verify', 'postTextMd5VerifyRequest', postTextMd5VerifyRequest)
            const localVarPath = `/text/md5/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTextMd5VerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextApi - functional programming interface
 */
export const TextApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextApiAxiosParamCreator(configuration)
    return {
        /**
         * 一个快速计算文本 MD5 哈希值的工具，适用于短文本且不关心参数暴露的场景。  ## 功能概述 通过GET请求的查询参数传入文本，返回其32位小写的MD5哈希值。  > [!NOTE] > 对于较长或敏感的文本，我们推荐使用本接口的 POST 版本，以避免URL长度限制和参数暴露问题。
         * @summary 计算文本的MD5哈希值(GET)
         * @param {string} text 需要计算哈希值的文本
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTextMd5(text: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTextMd5200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTextMd5(text, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextApi.getTextMd5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 收到了用AES加密的密文？把它、密钥和随机数（nonce）交给我们，就能还原出原始内容。  ## 功能概述 这是一个标准的AES解密接口。你需要提供经过Base64编码的密文、加密时使用的密钥和nonce（随机数，通常为16字节字符串）。  > [!IMPORTANT] > **关于密钥 `key`** > 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 `key` 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。 >  > **关于随机数 `nonce`** > 通常为16字节字符串，需与加密时一致。
         * @summary 使用AES算法解密文本
         * @param {PostTextAesDecryptRequest} postTextAesDecryptRequest 包含待解密文本 \&#39;text\&#39;、密钥 \&#39;key\&#39; 和随机数 \&#39;nonce\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTextAesDecrypt(postTextAesDecryptRequest: PostTextAesDecryptRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostTextAesDecrypt200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTextAesDecrypt(postTextAesDecryptRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextApi.postTextAesDecrypt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 需要安全地传输或存储一些文本信息？AES加密是一个可靠的选择。  ## 功能概述 这是一个标准的AES加密接口。你提供需要加密的明文和密钥，我们返回经过Base64编码的密文。  > [!IMPORTANT] > **关于密钥 `key`** > 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 `key` 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。
         * @summary 使用AES算法加密文本
         * @param {PostTextAesEncryptRequest} postTextAesEncryptRequest 包含待加密文本 \&#39;text\&#39; 和密钥 \&#39;key\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTextAesEncrypt(postTextAesEncryptRequest: PostTextAesEncryptRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostTextAesEncrypt200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTextAesEncrypt(postTextAesEncryptRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextApi.postTextAesEncrypt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想知道一篇文章有多少字、多少个词、或者多少行？这个接口可以帮你快速统计。  ## 功能概述 你提供一段文本，我们会从多个维度进行分析，并返回其字符数、词数、句子数、段落数和行数。这对于文本编辑、内容管理等场景非常有用。
         * @summary 多维度分析文本内容
         * @param {PostTextAnalyzeRequest} postTextAnalyzeRequest 包含待分析文本 \&#39;text\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTextAnalyze(postTextAnalyzeRequest: PostTextAnalyzeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostTextAnalyze200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTextAnalyze(postTextAnalyzeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextApi.postTextAnalyze']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 这是一个简单实用的 Base64 解码工具。  ## 功能概述 你提供一个 Base64 编码的字符串，我们帮你解码成原始的 UTF-8 文本。
         * @summary 解码Base64编码的文本
         * @param {PostTextBase64DecodeRequest} postTextBase64DecodeRequest 包含待解码文本 \&#39;text\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTextBase64Decode(postTextBase64DecodeRequest: PostTextBase64DecodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostTextBase64Decode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTextBase64Decode(postTextBase64DecodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextApi.postTextBase64Decode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 这是一个简单实用的 Base64 编码工具。  ## 功能概述 你提供一段原始文本，我们帮你转换成 Base64 编码的字符串。
         * @summary 将文本进行Base64编码
         * @param {PostTextBase64EncodeRequest} postTextBase64EncodeRequest 包含待编码文本 \&#39;text\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTextBase64Encode(postTextBase64EncodeRequest: PostTextBase64EncodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostTextBase64Encode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTextBase64Encode(postTextBase64EncodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextApi.postTextBase64Encode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 一个用于计算文本 MD5 哈希值的标准工具，推荐使用此版本。  ## 功能概述 通过POST请求的表单体传入文本，返回其32位小写的MD5哈希值。相比GET版本，此方法更适合处理较长或包含敏感信息的文本。
         * @summary 计算文本的MD5哈希值 (POST)
         * @param {PostTextMd5Request} postTextMd5Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTextMd5(postTextMd5Request: PostTextMd5Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTextMd5200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTextMd5(postTextMd5Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextApi.postTextMd5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 下载了一个文件，想确认它在传输过程中有没有损坏？校验MD5值是最常用的方法。  ## 功能概述 你提供原始文本和一个MD5哈希值，我们帮你计算文本的哈希，并与你提供的哈希进行比对，告诉你它们是否匹配。这在文件完整性校验等场景下非常有用。
         * @summary 校验MD5哈希值
         * @param {PostTextMd5VerifyRequest} postTextMd5VerifyRequest 包含待校验文本 \&#39;text\&#39; 和哈希值 \&#39;hash\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTextMd5Verify(postTextMd5VerifyRequest: PostTextMd5VerifyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostTextMd5Verify200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTextMd5Verify(postTextMd5VerifyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextApi.postTextMd5Verify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TextApi - factory interface
 */
export const TextApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextApiFp(configuration)
    return {
        /**
         * 一个快速计算文本 MD5 哈希值的工具，适用于短文本且不关心参数暴露的场景。  ## 功能概述 通过GET请求的查询参数传入文本，返回其32位小写的MD5哈希值。  > [!NOTE] > 对于较长或敏感的文本，我们推荐使用本接口的 POST 版本，以避免URL长度限制和参数暴露问题。
         * @summary 计算文本的MD5哈希值(GET)
         * @param {string} text 需要计算哈希值的文本
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTextMd5(text: string, options?: RawAxiosRequestConfig): AxiosPromise<GetTextMd5200Response> {
            return localVarFp.getTextMd5(text, options).then((request) => request(axios, basePath));
        },
        /**
         * 收到了用AES加密的密文？把它、密钥和随机数（nonce）交给我们，就能还原出原始内容。  ## 功能概述 这是一个标准的AES解密接口。你需要提供经过Base64编码的密文、加密时使用的密钥和nonce（随机数，通常为16字节字符串）。  > [!IMPORTANT] > **关于密钥 `key`** > 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 `key` 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。 >  > **关于随机数 `nonce`** > 通常为16字节字符串，需与加密时一致。
         * @summary 使用AES算法解密文本
         * @param {PostTextAesDecryptRequest} postTextAesDecryptRequest 包含待解密文本 \&#39;text\&#39;、密钥 \&#39;key\&#39; 和随机数 \&#39;nonce\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTextAesDecrypt(postTextAesDecryptRequest: PostTextAesDecryptRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostTextAesDecrypt200Response> {
            return localVarFp.postTextAesDecrypt(postTextAesDecryptRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 需要安全地传输或存储一些文本信息？AES加密是一个可靠的选择。  ## 功能概述 这是一个标准的AES加密接口。你提供需要加密的明文和密钥，我们返回经过Base64编码的密文。  > [!IMPORTANT] > **关于密钥 `key`** > 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 `key` 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。
         * @summary 使用AES算法加密文本
         * @param {PostTextAesEncryptRequest} postTextAesEncryptRequest 包含待加密文本 \&#39;text\&#39; 和密钥 \&#39;key\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTextAesEncrypt(postTextAesEncryptRequest: PostTextAesEncryptRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostTextAesEncrypt200Response> {
            return localVarFp.postTextAesEncrypt(postTextAesEncryptRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 想知道一篇文章有多少字、多少个词、或者多少行？这个接口可以帮你快速统计。  ## 功能概述 你提供一段文本，我们会从多个维度进行分析，并返回其字符数、词数、句子数、段落数和行数。这对于文本编辑、内容管理等场景非常有用。
         * @summary 多维度分析文本内容
         * @param {PostTextAnalyzeRequest} postTextAnalyzeRequest 包含待分析文本 \&#39;text\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTextAnalyze(postTextAnalyzeRequest: PostTextAnalyzeRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostTextAnalyze200Response> {
            return localVarFp.postTextAnalyze(postTextAnalyzeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 这是一个简单实用的 Base64 解码工具。  ## 功能概述 你提供一个 Base64 编码的字符串，我们帮你解码成原始的 UTF-8 文本。
         * @summary 解码Base64编码的文本
         * @param {PostTextBase64DecodeRequest} postTextBase64DecodeRequest 包含待解码文本 \&#39;text\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTextBase64Decode(postTextBase64DecodeRequest: PostTextBase64DecodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostTextBase64Decode200Response> {
            return localVarFp.postTextBase64Decode(postTextBase64DecodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 这是一个简单实用的 Base64 编码工具。  ## 功能概述 你提供一段原始文本，我们帮你转换成 Base64 编码的字符串。
         * @summary 将文本进行Base64编码
         * @param {PostTextBase64EncodeRequest} postTextBase64EncodeRequest 包含待编码文本 \&#39;text\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTextBase64Encode(postTextBase64EncodeRequest: PostTextBase64EncodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostTextBase64Encode200Response> {
            return localVarFp.postTextBase64Encode(postTextBase64EncodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 一个用于计算文本 MD5 哈希值的标准工具，推荐使用此版本。  ## 功能概述 通过POST请求的表单体传入文本，返回其32位小写的MD5哈希值。相比GET版本，此方法更适合处理较长或包含敏感信息的文本。
         * @summary 计算文本的MD5哈希值 (POST)
         * @param {PostTextMd5Request} postTextMd5Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTextMd5(postTextMd5Request: PostTextMd5Request, options?: RawAxiosRequestConfig): AxiosPromise<GetTextMd5200Response> {
            return localVarFp.postTextMd5(postTextMd5Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 下载了一个文件，想确认它在传输过程中有没有损坏？校验MD5值是最常用的方法。  ## 功能概述 你提供原始文本和一个MD5哈希值，我们帮你计算文本的哈希，并与你提供的哈希进行比对，告诉你它们是否匹配。这在文件完整性校验等场景下非常有用。
         * @summary 校验MD5哈希值
         * @param {PostTextMd5VerifyRequest} postTextMd5VerifyRequest 包含待校验文本 \&#39;text\&#39; 和哈希值 \&#39;hash\&#39; 的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTextMd5Verify(postTextMd5VerifyRequest: PostTextMd5VerifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostTextMd5Verify200Response> {
            return localVarFp.postTextMd5Verify(postTextMd5VerifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TextApi - object-oriented interface
 */
export class TextApi extends BaseAPI {
    /**
     * 一个快速计算文本 MD5 哈希值的工具，适用于短文本且不关心参数暴露的场景。  ## 功能概述 通过GET请求的查询参数传入文本，返回其32位小写的MD5哈希值。  > [!NOTE] > 对于较长或敏感的文本，我们推荐使用本接口的 POST 版本，以避免URL长度限制和参数暴露问题。
     * @summary 计算文本的MD5哈希值(GET)
     * @param {string} text 需要计算哈希值的文本
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTextMd5(text: string, options?: RawAxiosRequestConfig) {
        return TextApiFp(this.configuration).getTextMd5(text, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 收到了用AES加密的密文？把它、密钥和随机数（nonce）交给我们，就能还原出原始内容。  ## 功能概述 这是一个标准的AES解密接口。你需要提供经过Base64编码的密文、加密时使用的密钥和nonce（随机数，通常为16字节字符串）。  > [!IMPORTANT] > **关于密钥 `key`** > 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 `key` 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。 >  > **关于随机数 `nonce`** > 通常为16字节字符串，需与加密时一致。
     * @summary 使用AES算法解密文本
     * @param {PostTextAesDecryptRequest} postTextAesDecryptRequest 包含待解密文本 \&#39;text\&#39;、密钥 \&#39;key\&#39; 和随机数 \&#39;nonce\&#39; 的JSON对象
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTextAesDecrypt(postTextAesDecryptRequest: PostTextAesDecryptRequest, options?: RawAxiosRequestConfig) {
        return TextApiFp(this.configuration).postTextAesDecrypt(postTextAesDecryptRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 需要安全地传输或存储一些文本信息？AES加密是一个可靠的选择。  ## 功能概述 这是一个标准的AES加密接口。你提供需要加密的明文和密钥，我们返回经过Base64编码的密文。  > [!IMPORTANT] > **关于密钥 `key`** > 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 `key` 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。
     * @summary 使用AES算法加密文本
     * @param {PostTextAesEncryptRequest} postTextAesEncryptRequest 包含待加密文本 \&#39;text\&#39; 和密钥 \&#39;key\&#39; 的JSON对象
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTextAesEncrypt(postTextAesEncryptRequest: PostTextAesEncryptRequest, options?: RawAxiosRequestConfig) {
        return TextApiFp(this.configuration).postTextAesEncrypt(postTextAesEncryptRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想知道一篇文章有多少字、多少个词、或者多少行？这个接口可以帮你快速统计。  ## 功能概述 你提供一段文本，我们会从多个维度进行分析，并返回其字符数、词数、句子数、段落数和行数。这对于文本编辑、内容管理等场景非常有用。
     * @summary 多维度分析文本内容
     * @param {PostTextAnalyzeRequest} postTextAnalyzeRequest 包含待分析文本 \&#39;text\&#39; 的JSON对象
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTextAnalyze(postTextAnalyzeRequest: PostTextAnalyzeRequest, options?: RawAxiosRequestConfig) {
        return TextApiFp(this.configuration).postTextAnalyze(postTextAnalyzeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 这是一个简单实用的 Base64 解码工具。  ## 功能概述 你提供一个 Base64 编码的字符串，我们帮你解码成原始的 UTF-8 文本。
     * @summary 解码Base64编码的文本
     * @param {PostTextBase64DecodeRequest} postTextBase64DecodeRequest 包含待解码文本 \&#39;text\&#39; 的JSON对象
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTextBase64Decode(postTextBase64DecodeRequest: PostTextBase64DecodeRequest, options?: RawAxiosRequestConfig) {
        return TextApiFp(this.configuration).postTextBase64Decode(postTextBase64DecodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 这是一个简单实用的 Base64 编码工具。  ## 功能概述 你提供一段原始文本，我们帮你转换成 Base64 编码的字符串。
     * @summary 将文本进行Base64编码
     * @param {PostTextBase64EncodeRequest} postTextBase64EncodeRequest 包含待编码文本 \&#39;text\&#39; 的JSON对象
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTextBase64Encode(postTextBase64EncodeRequest: PostTextBase64EncodeRequest, options?: RawAxiosRequestConfig) {
        return TextApiFp(this.configuration).postTextBase64Encode(postTextBase64EncodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 一个用于计算文本 MD5 哈希值的标准工具，推荐使用此版本。  ## 功能概述 通过POST请求的表单体传入文本，返回其32位小写的MD5哈希值。相比GET版本，此方法更适合处理较长或包含敏感信息的文本。
     * @summary 计算文本的MD5哈希值 (POST)
     * @param {PostTextMd5Request} postTextMd5Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTextMd5(postTextMd5Request: PostTextMd5Request, options?: RawAxiosRequestConfig) {
        return TextApiFp(this.configuration).postTextMd5(postTextMd5Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 下载了一个文件，想确认它在传输过程中有没有损坏？校验MD5值是最常用的方法。  ## 功能概述 你提供原始文本和一个MD5哈希值，我们帮你计算文本的哈希，并与你提供的哈希进行比对，告诉你它们是否匹配。这在文件完整性校验等场景下非常有用。
     * @summary 校验MD5哈希值
     * @param {PostTextMd5VerifyRequest} postTextMd5VerifyRequest 包含待校验文本 \&#39;text\&#39; 和哈希值 \&#39;hash\&#39; 的JSON对象
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTextMd5Verify(postTextMd5VerifyRequest: PostTextMd5VerifyRequest, options?: RawAxiosRequestConfig) {
        return TextApiFp(this.configuration).postTextMd5Verify(postTextMd5VerifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TranslateApi - axios parameter creator
 */
export const TranslateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 获取AI智能翻译服务支持的完整语言列表、翻译风格选项、上下文场景选项以及性能指标信息。这个接口对于需要在前端动态展示翻译配置选项的应用非常有用，它会返回当前AI翻译服务所支持的所有语言代码、原生名称、翻译风格说明、上下文场景描述，以及服务的性能特征和限制信息。通过此接口，开发者可以构建用户友好的翻译界面，让用户选择合适的翻译参数。
         * @summary 获取AI翻译支持的语言和配置
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAiTranslateLanguages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ai/translate/languages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 这是一个商业级的AI智能翻译服务，采用最新的神经网络翻译技术和大语言模型，提供远超传统机器翻译的质量。它不仅能够智能处理单个文本翻译，还支持高效的批量文本翻译，并且具备上下文感知、风格适配、格式保留等高级功能。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者深度集成和测试。未来，它将转为付费API，为用户提供更稳定、更智能的翻译服务。  ## 功能概述  - **智能双模式**: 支持单个文本翻译和批量文本翻译的统一接口设计，自动识别请求类型并提供相应的翻译服务。系统会根据输入自动判断是处理单条文本还是批量文本，无需使用不同的接口。 - **多风格适配**: 提供随意口语化、专业商务、学术正式、文学艺术四种翻译风格，能够根据不同场景需求调整翻译的语言风格和表达方式。 - **上下文感知**: 支持通用、商务、技术、医疗、法律、市场营销、娱乐、教育、新闻等九种专业领域的上下文翻译，确保术语准确性和表达地道性。 - **高质量保证**: 内置质量评估系统，对每次翻译结果进行流畅度、准确度、完整性评分，并提供置信度分数和替代翻译建议。 - **智能解释**: 提供关键词组翻译注释、文化背景说明和语法结构分析，帮助用户理解翻译逻辑和文化差异。 - **高效批量**: 批量翻译支持最多50条文本，总计10万字符，配备智能并发控制（1-10并发）和失败重试机制。 - **快速模式**: 提供快速模式选项，在保证95%+准确率的前提下，响应时间缩短至800ms内，适合实时翻译和聊天应用。 - **格式保留**: 智能识别并保持原文的格式结构，包括换行、缩进、特殊符号等，确保翻译后的文本保持良好的可读性。
         * @summary AI智能翻译
         * @param {PostAiTranslateTargetLangEnum} targetLang 目标语言代码。请从支持的语言列表中选择一个语言代码。
         * @param {PostAiTranslateRequest} postAiTranslateRequest 包含翻译参数的JSON对象，支持单个文本或批量文本翻译
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAiTranslate: async (targetLang: PostAiTranslateTargetLangEnum, postAiTranslateRequest: PostAiTranslateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'targetLang' is not null or undefined
            assertParamExists('postAiTranslate', 'targetLang', targetLang)
            // verify required parameter 'postAiTranslateRequest' is not null or undefined
            assertParamExists('postAiTranslate', 'postAiTranslateRequest', postAiTranslateRequest)
            const localVarPath = `/ai/translate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (targetLang !== undefined) {
                localVarQueryParameter['target_lang'] = targetLang;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAiTranslateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 需要跨越语言的鸿沟进行交流？这个翻译接口是你可靠的\'同声传译\'。  ## 功能概述 你可以将一段源语言文本（我们能自动检测源语言）翻译成你指定的任何目标语言。无论是中译英、日译法，都不在话下。  ## 支持的语言 我们支持超过100种语言的互译，包括但不限于：中文（简体/繁体）、英语、日语、韩语、法语、德语、西班牙语、俄语、阿拉伯语等主流语言，以及各种小语种。详见下方参数列表。
         * @summary 多语言文本翻译
         * @param {PostTranslateTextToLangEnum} toLang 目标语言代码。请从支持的语言列表中选择一个语言代码。
         * @param {PostTranslateTextRequest} postTranslateTextRequest 包含待翻译文本的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTranslateText: async (toLang: PostTranslateTextToLangEnum, postTranslateTextRequest: PostTranslateTextRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toLang' is not null or undefined
            assertParamExists('postTranslateText', 'toLang', toLang)
            // verify required parameter 'postTranslateTextRequest' is not null or undefined
            assertParamExists('postTranslateText', 'postTranslateTextRequest', postTranslateTextRequest)
            const localVarPath = `/translate/text`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (toLang !== undefined) {
                localVarQueryParameter['to_lang'] = toLang;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTranslateTextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TranslateApi - functional programming interface
 */
export const TranslateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TranslateApiAxiosParamCreator(configuration)
    return {
        /**
         * 获取AI智能翻译服务支持的完整语言列表、翻译风格选项、上下文场景选项以及性能指标信息。这个接口对于需要在前端动态展示翻译配置选项的应用非常有用，它会返回当前AI翻译服务所支持的所有语言代码、原生名称、翻译风格说明、上下文场景描述，以及服务的性能特征和限制信息。通过此接口，开发者可以构建用户友好的翻译界面，让用户选择合适的翻译参数。
         * @summary 获取AI翻译支持的语言和配置
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAiTranslateLanguages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAiTranslateLanguages200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAiTranslateLanguages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranslateApi.getAiTranslateLanguages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 这是一个商业级的AI智能翻译服务，采用最新的神经网络翻译技术和大语言模型，提供远超传统机器翻译的质量。它不仅能够智能处理单个文本翻译，还支持高效的批量文本翻译，并且具备上下文感知、风格适配、格式保留等高级功能。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者深度集成和测试。未来，它将转为付费API，为用户提供更稳定、更智能的翻译服务。  ## 功能概述  - **智能双模式**: 支持单个文本翻译和批量文本翻译的统一接口设计，自动识别请求类型并提供相应的翻译服务。系统会根据输入自动判断是处理单条文本还是批量文本，无需使用不同的接口。 - **多风格适配**: 提供随意口语化、专业商务、学术正式、文学艺术四种翻译风格，能够根据不同场景需求调整翻译的语言风格和表达方式。 - **上下文感知**: 支持通用、商务、技术、医疗、法律、市场营销、娱乐、教育、新闻等九种专业领域的上下文翻译，确保术语准确性和表达地道性。 - **高质量保证**: 内置质量评估系统，对每次翻译结果进行流畅度、准确度、完整性评分，并提供置信度分数和替代翻译建议。 - **智能解释**: 提供关键词组翻译注释、文化背景说明和语法结构分析，帮助用户理解翻译逻辑和文化差异。 - **高效批量**: 批量翻译支持最多50条文本，总计10万字符，配备智能并发控制（1-10并发）和失败重试机制。 - **快速模式**: 提供快速模式选项，在保证95%+准确率的前提下，响应时间缩短至800ms内，适合实时翻译和聊天应用。 - **格式保留**: 智能识别并保持原文的格式结构，包括换行、缩进、特殊符号等，确保翻译后的文本保持良好的可读性。
         * @summary AI智能翻译
         * @param {PostAiTranslateTargetLangEnum} targetLang 目标语言代码。请从支持的语言列表中选择一个语言代码。
         * @param {PostAiTranslateRequest} postAiTranslateRequest 包含翻译参数的JSON对象，支持单个文本或批量文本翻译
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAiTranslate(targetLang: PostAiTranslateTargetLangEnum, postAiTranslateRequest: PostAiTranslateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostAiTranslate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAiTranslate(targetLang, postAiTranslateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranslateApi.postAiTranslate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 需要跨越语言的鸿沟进行交流？这个翻译接口是你可靠的\'同声传译\'。  ## 功能概述 你可以将一段源语言文本（我们能自动检测源语言）翻译成你指定的任何目标语言。无论是中译英、日译法，都不在话下。  ## 支持的语言 我们支持超过100种语言的互译，包括但不限于：中文（简体/繁体）、英语、日语、韩语、法语、德语、西班牙语、俄语、阿拉伯语等主流语言，以及各种小语种。详见下方参数列表。
         * @summary 多语言文本翻译
         * @param {PostTranslateTextToLangEnum} toLang 目标语言代码。请从支持的语言列表中选择一个语言代码。
         * @param {PostTranslateTextRequest} postTranslateTextRequest 包含待翻译文本的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTranslateText(toLang: PostTranslateTextToLangEnum, postTranslateTextRequest: PostTranslateTextRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostTranslateText200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTranslateText(toLang, postTranslateTextRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranslateApi.postTranslateText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TranslateApi - factory interface
 */
export const TranslateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TranslateApiFp(configuration)
    return {
        /**
         * 获取AI智能翻译服务支持的完整语言列表、翻译风格选项、上下文场景选项以及性能指标信息。这个接口对于需要在前端动态展示翻译配置选项的应用非常有用，它会返回当前AI翻译服务所支持的所有语言代码、原生名称、翻译风格说明、上下文场景描述，以及服务的性能特征和限制信息。通过此接口，开发者可以构建用户友好的翻译界面，让用户选择合适的翻译参数。
         * @summary 获取AI翻译支持的语言和配置
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAiTranslateLanguages(options?: RawAxiosRequestConfig): AxiosPromise<GetAiTranslateLanguages200Response> {
            return localVarFp.getAiTranslateLanguages(options).then((request) => request(axios, basePath));
        },
        /**
         * 这是一个商业级的AI智能翻译服务，采用最新的神经网络翻译技术和大语言模型，提供远超传统机器翻译的质量。它不仅能够智能处理单个文本翻译，还支持高效的批量文本翻译，并且具备上下文感知、风格适配、格式保留等高级功能。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者深度集成和测试。未来，它将转为付费API，为用户提供更稳定、更智能的翻译服务。  ## 功能概述  - **智能双模式**: 支持单个文本翻译和批量文本翻译的统一接口设计，自动识别请求类型并提供相应的翻译服务。系统会根据输入自动判断是处理单条文本还是批量文本，无需使用不同的接口。 - **多风格适配**: 提供随意口语化、专业商务、学术正式、文学艺术四种翻译风格，能够根据不同场景需求调整翻译的语言风格和表达方式。 - **上下文感知**: 支持通用、商务、技术、医疗、法律、市场营销、娱乐、教育、新闻等九种专业领域的上下文翻译，确保术语准确性和表达地道性。 - **高质量保证**: 内置质量评估系统，对每次翻译结果进行流畅度、准确度、完整性评分，并提供置信度分数和替代翻译建议。 - **智能解释**: 提供关键词组翻译注释、文化背景说明和语法结构分析，帮助用户理解翻译逻辑和文化差异。 - **高效批量**: 批量翻译支持最多50条文本，总计10万字符，配备智能并发控制（1-10并发）和失败重试机制。 - **快速模式**: 提供快速模式选项，在保证95%+准确率的前提下，响应时间缩短至800ms内，适合实时翻译和聊天应用。 - **格式保留**: 智能识别并保持原文的格式结构，包括换行、缩进、特殊符号等，确保翻译后的文本保持良好的可读性。
         * @summary AI智能翻译
         * @param {PostAiTranslateTargetLangEnum} targetLang 目标语言代码。请从支持的语言列表中选择一个语言代码。
         * @param {PostAiTranslateRequest} postAiTranslateRequest 包含翻译参数的JSON对象，支持单个文本或批量文本翻译
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAiTranslate(targetLang: PostAiTranslateTargetLangEnum, postAiTranslateRequest: PostAiTranslateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostAiTranslate200Response> {
            return localVarFp.postAiTranslate(targetLang, postAiTranslateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 需要跨越语言的鸿沟进行交流？这个翻译接口是你可靠的\'同声传译\'。  ## 功能概述 你可以将一段源语言文本（我们能自动检测源语言）翻译成你指定的任何目标语言。无论是中译英、日译法，都不在话下。  ## 支持的语言 我们支持超过100种语言的互译，包括但不限于：中文（简体/繁体）、英语、日语、韩语、法语、德语、西班牙语、俄语、阿拉伯语等主流语言，以及各种小语种。详见下方参数列表。
         * @summary 多语言文本翻译
         * @param {PostTranslateTextToLangEnum} toLang 目标语言代码。请从支持的语言列表中选择一个语言代码。
         * @param {PostTranslateTextRequest} postTranslateTextRequest 包含待翻译文本的JSON对象
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTranslateText(toLang: PostTranslateTextToLangEnum, postTranslateTextRequest: PostTranslateTextRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostTranslateText200Response> {
            return localVarFp.postTranslateText(toLang, postTranslateTextRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TranslateApi - object-oriented interface
 */
export class TranslateApi extends BaseAPI {
    /**
     * 获取AI智能翻译服务支持的完整语言列表、翻译风格选项、上下文场景选项以及性能指标信息。这个接口对于需要在前端动态展示翻译配置选项的应用非常有用，它会返回当前AI翻译服务所支持的所有语言代码、原生名称、翻译风格说明、上下文场景描述，以及服务的性能特征和限制信息。通过此接口，开发者可以构建用户友好的翻译界面，让用户选择合适的翻译参数。
     * @summary 获取AI翻译支持的语言和配置
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAiTranslateLanguages(options?: RawAxiosRequestConfig) {
        return TranslateApiFp(this.configuration).getAiTranslateLanguages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 这是一个商业级的AI智能翻译服务，采用最新的神经网络翻译技术和大语言模型，提供远超传统机器翻译的质量。它不仅能够智能处理单个文本翻译，还支持高效的批量文本翻译，并且具备上下文感知、风格适配、格式保留等高级功能。  > [!VIP] > 本API目前处于**限时免费**阶段，我们鼓励开发者深度集成和测试。未来，它将转为付费API，为用户提供更稳定、更智能的翻译服务。  ## 功能概述  - **智能双模式**: 支持单个文本翻译和批量文本翻译的统一接口设计，自动识别请求类型并提供相应的翻译服务。系统会根据输入自动判断是处理单条文本还是批量文本，无需使用不同的接口。 - **多风格适配**: 提供随意口语化、专业商务、学术正式、文学艺术四种翻译风格，能够根据不同场景需求调整翻译的语言风格和表达方式。 - **上下文感知**: 支持通用、商务、技术、医疗、法律、市场营销、娱乐、教育、新闻等九种专业领域的上下文翻译，确保术语准确性和表达地道性。 - **高质量保证**: 内置质量评估系统，对每次翻译结果进行流畅度、准确度、完整性评分，并提供置信度分数和替代翻译建议。 - **智能解释**: 提供关键词组翻译注释、文化背景说明和语法结构分析，帮助用户理解翻译逻辑和文化差异。 - **高效批量**: 批量翻译支持最多50条文本，总计10万字符，配备智能并发控制（1-10并发）和失败重试机制。 - **快速模式**: 提供快速模式选项，在保证95%+准确率的前提下，响应时间缩短至800ms内，适合实时翻译和聊天应用。 - **格式保留**: 智能识别并保持原文的格式结构，包括换行、缩进、特殊符号等，确保翻译后的文本保持良好的可读性。
     * @summary AI智能翻译
     * @param {PostAiTranslateTargetLangEnum} targetLang 目标语言代码。请从支持的语言列表中选择一个语言代码。
     * @param {PostAiTranslateRequest} postAiTranslateRequest 包含翻译参数的JSON对象，支持单个文本或批量文本翻译
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postAiTranslate(targetLang: PostAiTranslateTargetLangEnum, postAiTranslateRequest: PostAiTranslateRequest, options?: RawAxiosRequestConfig) {
        return TranslateApiFp(this.configuration).postAiTranslate(targetLang, postAiTranslateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 需要跨越语言的鸿沟进行交流？这个翻译接口是你可靠的\'同声传译\'。  ## 功能概述 你可以将一段源语言文本（我们能自动检测源语言）翻译成你指定的任何目标语言。无论是中译英、日译法，都不在话下。  ## 支持的语言 我们支持超过100种语言的互译，包括但不限于：中文（简体/繁体）、英语、日语、韩语、法语、德语、西班牙语、俄语、阿拉伯语等主流语言，以及各种小语种。详见下方参数列表。
     * @summary 多语言文本翻译
     * @param {PostTranslateTextToLangEnum} toLang 目标语言代码。请从支持的语言列表中选择一个语言代码。
     * @param {PostTranslateTextRequest} postTranslateTextRequest 包含待翻译文本的JSON对象
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTranslateText(toLang: PostTranslateTextToLangEnum, postTranslateTextRequest: PostTranslateTextRequest, options?: RawAxiosRequestConfig) {
        return TranslateApiFp(this.configuration).postTranslateText(toLang, postTranslateTextRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const PostAiTranslateTargetLangEnum = {
    Sq: 'sq',
    Ga: 'ga',
    Et: 'et',
    Ar: 'ar',
    Am: 'am',
    Az: 'az',
    Be: 'be',
    Bg: 'bg',
    Eu: 'eu',
    Is: 'is',
    Pl: 'pl',
    BsLatn: 'bs-Latn',
    Fa: 'fa',
    Da: 'da',
    De: 'de',
    Ru: 'ru',
    Fr: 'fr',
    Tl: 'tl',
    Fi: 'fi',
    Fy: 'fy',
    Km: 'km',
    Ka: 'ka',
    Gu: 'gu',
    Ht: 'ht',
    Ko: 'ko',
    Ha: 'ha',
    Kk: 'kk',
    Nl: 'nl',
    Gl: 'gl',
    Ca: 'ca',
    Cs: 'cs',
    Ky: 'ky',
    Kn: 'kn',
    Tlh: 'tlh',
    Hr: 'hr',
    Otq: 'otq',
    Co: 'co',
    Ku: 'ku',
    La: 'la',
    Lo: 'lo',
    Lv: 'lv',
    Lt: 'lt',
    Ro: 'ro',
    Lb: 'lb',
    Mg: 'mg',
    Mt: 'mt',
    Mr: 'mr',
    Ms: 'ms',
    Ml: 'ml',
    Mi: 'mi',
    Mk: 'mk',
    Mn: 'mn',
    Bn: 'bn',
    My: 'my',
    Mww: 'mww',
    Hmn: 'hmn',
    Xh: 'xh',
    Zu: 'zu',
    Ne: 'ne',
    False: 'false',
    Pa: 'pa',
    Ps: 'ps',
    Pt: 'pt',
    Ny: 'ny',
    Ja: 'ja',
    Sv: 'sv',
    SrLatn: 'sr-Latn',
    SrCyrl: 'sr-Cyrl',
    St: 'st',
    Sm: 'sm',
    Si: 'si',
    Eo: 'eo',
    Sk: 'sk',
    Sl: 'sl',
    Sw: 'sw',
    Gd: 'gd',
    So: 'so',
    Ceb: 'ceb',
    Te: 'te',
    Ta: 'ta',
    Th: 'th',
    Tg: 'tg',
    Tr: 'tr',
    Cy: 'cy',
    ZhLzh: 'zh-lzh',
    Ur: 'ur',
    Uk: 'uk',
    Uz: 'uz',
    Haw: 'haw',
    Es: 'es',
    He: 'he',
    El: 'el',
    Sd: 'sd',
    Hu: 'hu',
    Sn: 'sn',
    Hy: 'hy',
    Ig: 'ig',
    It: 'it',
    Yi: 'yi',
    Hi: 'hi',
    Id: 'id',
    En: 'en',
    Su: 'su',
    Jw: 'jw',
    Yua: 'yua',
    Yo: 'yo',
    Vi: 'vi',
    ZhChs: 'zh-CHS',
    ZhCht: 'zh-CHT'
} as const;
export type PostAiTranslateTargetLangEnum = typeof PostAiTranslateTargetLangEnum[keyof typeof PostAiTranslateTargetLangEnum];
export const PostTranslateTextToLangEnum = {
    Sq: 'sq',
    Ga: 'ga',
    Et: 'et',
    Ar: 'ar',
    Am: 'am',
    Az: 'az',
    Be: 'be',
    Bg: 'bg',
    Eu: 'eu',
    Is: 'is',
    Pl: 'pl',
    BsLatn: 'bs-Latn',
    Fa: 'fa',
    Da: 'da',
    De: 'de',
    Ru: 'ru',
    Fr: 'fr',
    Tl: 'tl',
    Fi: 'fi',
    Fy: 'fy',
    Km: 'km',
    Ka: 'ka',
    Gu: 'gu',
    Ht: 'ht',
    Ko: 'ko',
    Ha: 'ha',
    Kk: 'kk',
    Nl: 'nl',
    Gl: 'gl',
    Ca: 'ca',
    Cs: 'cs',
    Ky: 'ky',
    Kn: 'kn',
    Tlh: 'tlh',
    Hr: 'hr',
    Otq: 'otq',
    Co: 'co',
    Ku: 'ku',
    La: 'la',
    Lo: 'lo',
    Lv: 'lv',
    Lt: 'lt',
    Ro: 'ro',
    Lb: 'lb',
    Mg: 'mg',
    Mt: 'mt',
    Mr: 'mr',
    Ms: 'ms',
    Ml: 'ml',
    Mi: 'mi',
    Mk: 'mk',
    Mn: 'mn',
    Bn: 'bn',
    My: 'my',
    Mww: 'mww',
    Hmn: 'hmn',
    Xh: 'xh',
    Zu: 'zu',
    Ne: 'ne',
    False: 'false',
    Pa: 'pa',
    Ps: 'ps',
    Pt: 'pt',
    Ny: 'ny',
    Ja: 'ja',
    Sv: 'sv',
    SrLatn: 'sr-Latn',
    SrCyrl: 'sr-Cyrl',
    St: 'st',
    Sm: 'sm',
    Si: 'si',
    Eo: 'eo',
    Sk: 'sk',
    Sl: 'sl',
    Sw: 'sw',
    Gd: 'gd',
    So: 'so',
    Ceb: 'ceb',
    Te: 'te',
    Ta: 'ta',
    Th: 'th',
    Tg: 'tg',
    Tr: 'tr',
    Cy: 'cy',
    ZhLzh: 'zh-lzh',
    Ur: 'ur',
    Uk: 'uk',
    Uz: 'uz',
    Haw: 'haw',
    Es: 'es',
    He: 'he',
    El: 'el',
    Sd: 'sd',
    Hu: 'hu',
    Sn: 'sn',
    Hy: 'hy',
    Ig: 'ig',
    It: 'it',
    Yi: 'yi',
    Hi: 'hi',
    Id: 'id',
    En: 'en',
    Su: 'su',
    Jw: 'jw',
    Yua: 'yua',
    Yo: 'yo',
    Vi: 'vi',
    ZhChs: 'zh-CHS',
    ZhCht: 'zh-CHT'
} as const;
export type PostTranslateTextToLangEnum = typeof PostTranslateTextToLangEnum[keyof typeof PostTranslateTextToLangEnum];


/**
 * WebParseApi - axios parameter creator
 */
export const WebParseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 提交了URL转Markdown任务后，想知道处理进度和结果？这个接口可以帮你实时追踪。  ## 功能概述  通过之前提交任务时获得的任务ID，你可以查询该任务的当前状态、处理进度以及最终结果。任务结果会在缓存中保存30分钟，期间可以重复查询，非常方便。  任务有五种状态：等待处理（pending）时进度为0%；处理中（processing）时进度在10-90%之间；已完成（completed）时进度为100%并返回Markdown内容；失败（failed）时会返回错误信息；超时（timeout）表示任务处理时间超过60秒已被取消。建议采用指数退避策略进行轮询，初始延迟1秒，每次延迟增加20%，最大延迟5秒。当状态为已完成、失败或超时时停止轮询。  系统会自动管理任务生命周期，单个任务最长处理时间为60秒，任务结果保存30分钟后自动清理，每5分钟清理一次过期任务。  ## 任务状态说明  | 状态 | 说明 | 进度 | 轮询建议 | |------|------|------|----------| | `pending` | 等待处理 | 0% | 立即开始轮询 | | `processing` | 处理中 | 10-90% | 每2-5秒轮询一次 | | `completed` | 已完成 | 100% | 停止轮询，获取结果 | | `failed` | 失败 | 100% | 停止轮询，查看错误信息 | | `timeout` | 超时 | 100% | 停止轮询，任务已取消 |
         * @summary 查询网页转换任务状态和结果
         * @param {string} taskId 任务ID（由提交接口返回）
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebTomarkdownAsyncStatus: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getWebTomarkdownAsyncStatus', 'taskId', taskId)
            const localVarPath = `/web/tomarkdown/async/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想一次性“打包”一个网页上的所有图片吗？这个接口可以帮你实现。  ## 功能概述 你提供一个网页的URL，我们会访问该页面，解析其HTML内容，并提取出所有 `<img>` 标签中的图片链接，然后将这些链接列表返回给你。非常适合用于制作图片采集器或素材下载工具。
         * @summary 提取网页中的所有图片
         * @param {string} url 需要提取图片的网页URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebparseExtractimages: async (url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('getWebparseExtractimages', 'url', url)
            const localVarPath = `/webparse/extractimages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 当你在应用中需要展示一个链接的预览时（就像微信或Telegram里那样），这个接口能帮你轻松获取所需信息。  ## 功能概述 你提供一个网页的URL，我们会抓取并解析它的 `<head>` 部分，提取出关键的元数据（Metadata），如页面标题（Title）、描述（Description）、关键词（Keywords）以及网站图标（Favicon）等。
         * @summary 抓取并解析网页的元数据
         * @param {string} url 需要提取元数据的网页URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebparseMetadata: async (url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('getWebparseMetadata', 'url', url)
            const localVarPath = `/webparse/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 想要将复杂的网页转换为结构清晰的Markdown？这个接口采用异步处理模式，特别适合处理大型网页、复杂网站或需要长时间处理的转换任务。  ## 功能概述  > [!VIP] >本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  UAPI Pro平台推出的异步网页转Markdown API能够将任意网页URL转换为结构清晰、格式优美的Markdown文本。提交任务后立即返回任务ID，不会阻塞客户端等待。您可以通过任务ID实时查询转换进度和处理状态，支持长达60秒的处理时间，轻松应对大型网站、需要JS渲染的单页应用等复杂页面。任务结果会缓存30分钟，期间可重复查询，过期任务自动清理无需手动管理。  此API采用先进算法，自动识别并抓取网页主体内容，精准剔除广告、导航栏、页眉页脚等无关元素。完美保留原文的格式，包括标题、列表、代码块、表格、引用、图片等，并输出为兼容性强的GitHub Flavored Markdown (GFM) 格式。同时会自动解析并提取文章标题、作者、发布日期、站点名称等关键元数据，并将其格式化为标准的YAML Front Matter，方便后续处理和CMS集成。  ## 使用流程  调用本接口提交URL转换任务后，会立即获得一个唯一的任务ID。随后使用任务ID调用查询接口，获取任务状态和进度。任务完成后，从查询接口的响应中获取Markdown内容。
         * @summary 深度抓取网页转Markdown
         * @param {string} url 需要转换的网页URL。URL必须经过编码。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebTomarkdownAsync: async (url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('postWebTomarkdownAsync', 'url', url)
            const localVarPath = `/web/tomarkdown/async`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebParseApi - functional programming interface
 */
export const WebParseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebParseApiAxiosParamCreator(configuration)
    return {
        /**
         * 提交了URL转Markdown任务后，想知道处理进度和结果？这个接口可以帮你实时追踪。  ## 功能概述  通过之前提交任务时获得的任务ID，你可以查询该任务的当前状态、处理进度以及最终结果。任务结果会在缓存中保存30分钟，期间可以重复查询，非常方便。  任务有五种状态：等待处理（pending）时进度为0%；处理中（processing）时进度在10-90%之间；已完成（completed）时进度为100%并返回Markdown内容；失败（failed）时会返回错误信息；超时（timeout）表示任务处理时间超过60秒已被取消。建议采用指数退避策略进行轮询，初始延迟1秒，每次延迟增加20%，最大延迟5秒。当状态为已完成、失败或超时时停止轮询。  系统会自动管理任务生命周期，单个任务最长处理时间为60秒，任务结果保存30分钟后自动清理，每5分钟清理一次过期任务。  ## 任务状态说明  | 状态 | 说明 | 进度 | 轮询建议 | |------|------|------|----------| | `pending` | 等待处理 | 0% | 立即开始轮询 | | `processing` | 处理中 | 10-90% | 每2-5秒轮询一次 | | `completed` | 已完成 | 100% | 停止轮询，获取结果 | | `failed` | 失败 | 100% | 停止轮询，查看错误信息 | | `timeout` | 超时 | 100% | 停止轮询，任务已取消 |
         * @summary 查询网页转换任务状态和结果
         * @param {string} taskId 任务ID（由提交接口返回）
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebTomarkdownAsyncStatus(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWebTomarkdownAsyncStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebTomarkdownAsyncStatus(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebParseApi.getWebTomarkdownAsyncStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想一次性“打包”一个网页上的所有图片吗？这个接口可以帮你实现。  ## 功能概述 你提供一个网页的URL，我们会访问该页面，解析其HTML内容，并提取出所有 `<img>` 标签中的图片链接，然后将这些链接列表返回给你。非常适合用于制作图片采集器或素材下载工具。
         * @summary 提取网页中的所有图片
         * @param {string} url 需要提取图片的网页URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebparseExtractimages(url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWebparseExtractimages200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebparseExtractimages(url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebParseApi.getWebparseExtractimages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 当你在应用中需要展示一个链接的预览时（就像微信或Telegram里那样），这个接口能帮你轻松获取所需信息。  ## 功能概述 你提供一个网页的URL，我们会抓取并解析它的 `<head>` 部分，提取出关键的元数据（Metadata），如页面标题（Title）、描述（Description）、关键词（Keywords）以及网站图标（Favicon）等。
         * @summary 抓取并解析网页的元数据
         * @param {string} url 需要提取元数据的网页URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebparseMetadata(url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWebparseMetadata200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebparseMetadata(url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebParseApi.getWebparseMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 想要将复杂的网页转换为结构清晰的Markdown？这个接口采用异步处理模式，特别适合处理大型网页、复杂网站或需要长时间处理的转换任务。  ## 功能概述  > [!VIP] >本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  UAPI Pro平台推出的异步网页转Markdown API能够将任意网页URL转换为结构清晰、格式优美的Markdown文本。提交任务后立即返回任务ID，不会阻塞客户端等待。您可以通过任务ID实时查询转换进度和处理状态，支持长达60秒的处理时间，轻松应对大型网站、需要JS渲染的单页应用等复杂页面。任务结果会缓存30分钟，期间可重复查询，过期任务自动清理无需手动管理。  此API采用先进算法，自动识别并抓取网页主体内容，精准剔除广告、导航栏、页眉页脚等无关元素。完美保留原文的格式，包括标题、列表、代码块、表格、引用、图片等，并输出为兼容性强的GitHub Flavored Markdown (GFM) 格式。同时会自动解析并提取文章标题、作者、发布日期、站点名称等关键元数据，并将其格式化为标准的YAML Front Matter，方便后续处理和CMS集成。  ## 使用流程  调用本接口提交URL转换任务后，会立即获得一个唯一的任务ID。随后使用任务ID调用查询接口，获取任务状态和进度。任务完成后，从查询接口的响应中获取Markdown内容。
         * @summary 深度抓取网页转Markdown
         * @param {string} url 需要转换的网页URL。URL必须经过编码。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebTomarkdownAsync(url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostWebTomarkdownAsync202Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWebTomarkdownAsync(url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebParseApi.postWebTomarkdownAsync']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebParseApi - factory interface
 */
export const WebParseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebParseApiFp(configuration)
    return {
        /**
         * 提交了URL转Markdown任务后，想知道处理进度和结果？这个接口可以帮你实时追踪。  ## 功能概述  通过之前提交任务时获得的任务ID，你可以查询该任务的当前状态、处理进度以及最终结果。任务结果会在缓存中保存30分钟，期间可以重复查询，非常方便。  任务有五种状态：等待处理（pending）时进度为0%；处理中（processing）时进度在10-90%之间；已完成（completed）时进度为100%并返回Markdown内容；失败（failed）时会返回错误信息；超时（timeout）表示任务处理时间超过60秒已被取消。建议采用指数退避策略进行轮询，初始延迟1秒，每次延迟增加20%，最大延迟5秒。当状态为已完成、失败或超时时停止轮询。  系统会自动管理任务生命周期，单个任务最长处理时间为60秒，任务结果保存30分钟后自动清理，每5分钟清理一次过期任务。  ## 任务状态说明  | 状态 | 说明 | 进度 | 轮询建议 | |------|------|------|----------| | `pending` | 等待处理 | 0% | 立即开始轮询 | | `processing` | 处理中 | 10-90% | 每2-5秒轮询一次 | | `completed` | 已完成 | 100% | 停止轮询，获取结果 | | `failed` | 失败 | 100% | 停止轮询，查看错误信息 | | `timeout` | 超时 | 100% | 停止轮询，任务已取消 |
         * @summary 查询网页转换任务状态和结果
         * @param {string} taskId 任务ID（由提交接口返回）
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebTomarkdownAsyncStatus(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetWebTomarkdownAsyncStatus200Response> {
            return localVarFp.getWebTomarkdownAsyncStatus(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 想一次性“打包”一个网页上的所有图片吗？这个接口可以帮你实现。  ## 功能概述 你提供一个网页的URL，我们会访问该页面，解析其HTML内容，并提取出所有 `<img>` 标签中的图片链接，然后将这些链接列表返回给你。非常适合用于制作图片采集器或素材下载工具。
         * @summary 提取网页中的所有图片
         * @param {string} url 需要提取图片的网页URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebparseExtractimages(url: string, options?: RawAxiosRequestConfig): AxiosPromise<GetWebparseExtractimages200Response> {
            return localVarFp.getWebparseExtractimages(url, options).then((request) => request(axios, basePath));
        },
        /**
         * 当你在应用中需要展示一个链接的预览时（就像微信或Telegram里那样），这个接口能帮你轻松获取所需信息。  ## 功能概述 你提供一个网页的URL，我们会抓取并解析它的 `<head>` 部分，提取出关键的元数据（Metadata），如页面标题（Title）、描述（Description）、关键词（Keywords）以及网站图标（Favicon）等。
         * @summary 抓取并解析网页的元数据
         * @param {string} url 需要提取元数据的网页URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebparseMetadata(url: string, options?: RawAxiosRequestConfig): AxiosPromise<GetWebparseMetadata200Response> {
            return localVarFp.getWebparseMetadata(url, options).then((request) => request(axios, basePath));
        },
        /**
         * 想要将复杂的网页转换为结构清晰的Markdown？这个接口采用异步处理模式，特别适合处理大型网页、复杂网站或需要长时间处理的转换任务。  ## 功能概述  > [!VIP] >本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  UAPI Pro平台推出的异步网页转Markdown API能够将任意网页URL转换为结构清晰、格式优美的Markdown文本。提交任务后立即返回任务ID，不会阻塞客户端等待。您可以通过任务ID实时查询转换进度和处理状态，支持长达60秒的处理时间，轻松应对大型网站、需要JS渲染的单页应用等复杂页面。任务结果会缓存30分钟，期间可重复查询，过期任务自动清理无需手动管理。  此API采用先进算法，自动识别并抓取网页主体内容，精准剔除广告、导航栏、页眉页脚等无关元素。完美保留原文的格式，包括标题、列表、代码块、表格、引用、图片等，并输出为兼容性强的GitHub Flavored Markdown (GFM) 格式。同时会自动解析并提取文章标题、作者、发布日期、站点名称等关键元数据，并将其格式化为标准的YAML Front Matter，方便后续处理和CMS集成。  ## 使用流程  调用本接口提交URL转换任务后，会立即获得一个唯一的任务ID。随后使用任务ID调用查询接口，获取任务状态和进度。任务完成后，从查询接口的响应中获取Markdown内容。
         * @summary 深度抓取网页转Markdown
         * @param {string} url 需要转换的网页URL。URL必须经过编码。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebTomarkdownAsync(url: string, options?: RawAxiosRequestConfig): AxiosPromise<PostWebTomarkdownAsync202Response> {
            return localVarFp.postWebTomarkdownAsync(url, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebParseApi - object-oriented interface
 */
export class WebParseApi extends BaseAPI {
    /**
     * 提交了URL转Markdown任务后，想知道处理进度和结果？这个接口可以帮你实时追踪。  ## 功能概述  通过之前提交任务时获得的任务ID，你可以查询该任务的当前状态、处理进度以及最终结果。任务结果会在缓存中保存30分钟，期间可以重复查询，非常方便。  任务有五种状态：等待处理（pending）时进度为0%；处理中（processing）时进度在10-90%之间；已完成（completed）时进度为100%并返回Markdown内容；失败（failed）时会返回错误信息；超时（timeout）表示任务处理时间超过60秒已被取消。建议采用指数退避策略进行轮询，初始延迟1秒，每次延迟增加20%，最大延迟5秒。当状态为已完成、失败或超时时停止轮询。  系统会自动管理任务生命周期，单个任务最长处理时间为60秒，任务结果保存30分钟后自动清理，每5分钟清理一次过期任务。  ## 任务状态说明  | 状态 | 说明 | 进度 | 轮询建议 | |------|------|------|----------| | `pending` | 等待处理 | 0% | 立即开始轮询 | | `processing` | 处理中 | 10-90% | 每2-5秒轮询一次 | | `completed` | 已完成 | 100% | 停止轮询，获取结果 | | `failed` | 失败 | 100% | 停止轮询，查看错误信息 | | `timeout` | 超时 | 100% | 停止轮询，任务已取消 |
     * @summary 查询网页转换任务状态和结果
     * @param {string} taskId 任务ID（由提交接口返回）
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWebTomarkdownAsyncStatus(taskId: string, options?: RawAxiosRequestConfig) {
        return WebParseApiFp(this.configuration).getWebTomarkdownAsyncStatus(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想一次性“打包”一个网页上的所有图片吗？这个接口可以帮你实现。  ## 功能概述 你提供一个网页的URL，我们会访问该页面，解析其HTML内容，并提取出所有 `<img>` 标签中的图片链接，然后将这些链接列表返回给你。非常适合用于制作图片采集器或素材下载工具。
     * @summary 提取网页中的所有图片
     * @param {string} url 需要提取图片的网页URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWebparseExtractimages(url: string, options?: RawAxiosRequestConfig) {
        return WebParseApiFp(this.configuration).getWebparseExtractimages(url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 当你在应用中需要展示一个链接的预览时（就像微信或Telegram里那样），这个接口能帮你轻松获取所需信息。  ## 功能概述 你提供一个网页的URL，我们会抓取并解析它的 `<head>` 部分，提取出关键的元数据（Metadata），如页面标题（Title）、描述（Description）、关键词（Keywords）以及网站图标（Favicon）等。
     * @summary 抓取并解析网页的元数据
     * @param {string} url 需要提取元数据的网页URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWebparseMetadata(url: string, options?: RawAxiosRequestConfig) {
        return WebParseApiFp(this.configuration).getWebparseMetadata(url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 想要将复杂的网页转换为结构清晰的Markdown？这个接口采用异步处理模式，特别适合处理大型网页、复杂网站或需要长时间处理的转换任务。  ## 功能概述  > [!VIP] >本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  UAPI Pro平台推出的异步网页转Markdown API能够将任意网页URL转换为结构清晰、格式优美的Markdown文本。提交任务后立即返回任务ID，不会阻塞客户端等待。您可以通过任务ID实时查询转换进度和处理状态，支持长达60秒的处理时间，轻松应对大型网站、需要JS渲染的单页应用等复杂页面。任务结果会缓存30分钟，期间可重复查询，过期任务自动清理无需手动管理。  此API采用先进算法，自动识别并抓取网页主体内容，精准剔除广告、导航栏、页眉页脚等无关元素。完美保留原文的格式，包括标题、列表、代码块、表格、引用、图片等，并输出为兼容性强的GitHub Flavored Markdown (GFM) 格式。同时会自动解析并提取文章标题、作者、发布日期、站点名称等关键元数据，并将其格式化为标准的YAML Front Matter，方便后续处理和CMS集成。  ## 使用流程  调用本接口提交URL转换任务后，会立即获得一个唯一的任务ID。随后使用任务ID调用查询接口，获取任务状态和进度。任务完成后，从查询接口的响应中获取Markdown内容。
     * @summary 深度抓取网页转Markdown
     * @param {string} url 需要转换的网页URL。URL必须经过编码。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postWebTomarkdownAsync(url: string, options?: RawAxiosRequestConfig) {
        return WebParseApiFp(this.configuration).postWebTomarkdownAsync(url, options).then((request) => request(this.axios, this.basePath));
    }
}



